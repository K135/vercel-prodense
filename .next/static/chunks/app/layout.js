/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APILoadingStatus: () => (/* binding */ APILoadingStatus),\n/* harmony export */   APIProvider: () => (/* binding */ APIProvider),\n/* harmony export */   APIProviderContext: () => (/* binding */ APIProviderContext),\n/* harmony export */   AdvancedMarker: () => (/* binding */ AdvancedMarker),\n/* harmony export */   AdvancedMarkerAnchorPoint: () => (/* binding */ AdvancedMarkerAnchorPoint),\n/* harmony export */   AdvancedMarkerContext: () => (/* binding */ AdvancedMarkerContext),\n/* harmony export */   CollisionBehavior: () => (/* binding */ CollisionBehavior),\n/* harmony export */   ColorScheme: () => (/* binding */ ColorScheme),\n/* harmony export */   ControlPosition: () => (/* binding */ ControlPosition),\n/* harmony export */   GoogleMapsContext: () => (/* binding */ GoogleMapsContext),\n/* harmony export */   InfoWindow: () => (/* binding */ InfoWindow),\n/* harmony export */   Map: () => (/* binding */ Map),\n/* harmony export */   MapControl: () => (/* binding */ MapControl),\n/* harmony export */   Marker: () => (/* binding */ Marker),\n/* harmony export */   Pin: () => (/* binding */ Pin),\n/* harmony export */   RenderingType: () => (/* binding */ RenderingType),\n/* harmony export */   StaticMap: () => (/* binding */ StaticMap),\n/* harmony export */   createStaticMapsUrl: () => (/* binding */ createStaticMapsUrl),\n/* harmony export */   isAdvancedMarker: () => (/* binding */ isAdvancedMarker),\n/* harmony export */   isLatLngLiteral: () => (/* binding */ isLatLngLiteral),\n/* harmony export */   latLngEquals: () => (/* binding */ latLngEquals),\n/* harmony export */   limitTiltRange: () => (/* binding */ limitTiltRange),\n/* harmony export */   toLatLngLiteral: () => (/* binding */ toLatLngLiteral),\n/* harmony export */   useAdvancedMarkerRef: () => (/* binding */ useAdvancedMarkerRef),\n/* harmony export */   useApiIsLoaded: () => (/* binding */ useApiIsLoaded),\n/* harmony export */   useApiLoadingStatus: () => (/* binding */ useApiLoadingStatus),\n/* harmony export */   useMap: () => (/* binding */ useMap),\n/* harmony export */   useMapsLibrary: () => (/* binding */ useMapsLibrary),\n/* harmony export */   useMarkerRef: () => (/* binding */ useMarkerRef)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fast-deep-equal */ \"(app-pages-browser)/./node_modules/fast-deep-equal/index.js\");\n\n\n\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nconst APILoadingStatus = {\n  NOT_LOADED: 'NOT_LOADED',\n  LOADING: 'LOADING',\n  LOADED: 'LOADED',\n  FAILED: 'FAILED',\n  AUTH_FAILURE: 'AUTH_FAILURE'\n};\n\nconst MAPS_API_BASE_URL = 'https://maps.googleapis.com/maps/api/js';\n/**\n * A GoogleMapsApiLoader to reliably load and unload the Google Maps JavaScript API.\n *\n * The actual loading and unloading is delayed into the microtask queue, to\n * allow using the API in an useEffect hook, without worrying about multiple API loads.\n */\nclass GoogleMapsApiLoader {\n  /**\n   * Loads the Maps JavaScript API with the specified parameters.\n   * Since the Maps library can only be loaded once per page, this will\n   * produce a warning when called multiple times with different\n   * parameters.\n   *\n   * The returned promise resolves when loading completes\n   * and rejects in case of an error or when the loading was aborted.\n   */\n  static async load(params, onLoadingStatusChange) {\n    var _window$google;\n    const libraries = params.libraries ? params.libraries.split(',') : [];\n    const serializedParams = this.serializeParams(params);\n    this.listeners.push(onLoadingStatusChange);\n    // Note: if `google.maps.importLibrary` has been defined externally, we\n    //   assume that loading is complete and successful.\n    //   If it was defined by a previous call to this method, a warning\n    //   message is logged if there are differences in api-parameters used\n    //   for both calls.\n    if ((_window$google = window.google) != null && (_window$google = _window$google.maps) != null && _window$google.importLibrary) {\n      // no serialized parameters means it was loaded externally\n      if (!this.serializedApiParams) {\n        this.loadingStatus = APILoadingStatus.LOADED;\n      }\n      this.notifyLoadingStatusListeners();\n    } else {\n      this.serializedApiParams = serializedParams;\n      this.initImportLibrary(params);\n    }\n    if (this.serializedApiParams && this.serializedApiParams !== serializedParams) {\n      console.warn(`[google-maps-api-loader] The maps API has already been loaded ` + `with different parameters and will not be loaded again. Refresh the ` + `page for new values to have effect.`);\n    }\n    const librariesToLoad = ['maps', ...libraries];\n    await Promise.all(librariesToLoad.map(name => google.maps.importLibrary(name)));\n  }\n  /**\n   * Serialize the parameters used to load the library for easier comparison.\n   */\n  static serializeParams(params) {\n    return [params.v, params.key, params.language, params.region, params.authReferrerPolicy, params.solutionChannel].join('/');\n  }\n  /**\n   * Creates the global `google.maps.importLibrary` function for bootstrapping.\n   * This is essentially a formatted version of the dynamic loading script\n   * from the official documentation with some minor adjustments.\n   *\n   * The created importLibrary function will load the Google Maps JavaScript API,\n   * which will then replace the `google.maps.importLibrary` function with the full\n   * implementation.\n   *\n   * @see https://developers.google.com/maps/documentation/javascript/load-maps-js-api#dynamic-library-import\n   */\n  static initImportLibrary(params) {\n    if (!window.google) window.google = {};\n    if (!window.google.maps) window.google.maps = {};\n    if (window.google.maps['importLibrary']) {\n      console.error('[google-maps-api-loader-internal]: initImportLibrary must only be called once');\n      return;\n    }\n    let apiPromise = null;\n    const loadApi = () => {\n      if (apiPromise) return apiPromise;\n      apiPromise = new Promise((resolve, reject) => {\n        var _document$querySelect;\n        const scriptElement = document.createElement('script');\n        const urlParams = new URLSearchParams();\n        for (const [key, value] of Object.entries(params)) {\n          const urlParamName = key.replace(/[A-Z]/g, t => '_' + t[0].toLowerCase());\n          urlParams.set(urlParamName, String(value));\n        }\n        urlParams.set('loading', 'async');\n        urlParams.set('callback', '__googleMapsCallback__');\n        scriptElement.async = true;\n        scriptElement.src = MAPS_API_BASE_URL + `?` + urlParams.toString();\n        scriptElement.nonce = ((_document$querySelect = document.querySelector('script[nonce]')) == null ? void 0 : _document$querySelect.nonce) || '';\n        scriptElement.onerror = () => {\n          this.loadingStatus = APILoadingStatus.FAILED;\n          this.notifyLoadingStatusListeners();\n          reject(new Error('The Google Maps JavaScript API could not load.'));\n        };\n        window.__googleMapsCallback__ = () => {\n          this.loadingStatus = APILoadingStatus.LOADED;\n          this.notifyLoadingStatusListeners();\n          resolve();\n        };\n        window.gm_authFailure = () => {\n          this.loadingStatus = APILoadingStatus.AUTH_FAILURE;\n          this.notifyLoadingStatusListeners();\n        };\n        this.loadingStatus = APILoadingStatus.LOADING;\n        this.notifyLoadingStatusListeners();\n        document.head.append(scriptElement);\n      });\n      return apiPromise;\n    };\n    // for the first load, we declare an importLibrary function that will\n    // be overwritten once the api is loaded.\n    google.maps.importLibrary = libraryName => loadApi().then(() => google.maps.importLibrary(libraryName));\n  }\n  /**\n   * Calls all registered loadingStatusListeners after a status update.\n   */\n  static notifyLoadingStatusListeners() {\n    for (const fn of this.listeners) {\n      fn(this.loadingStatus);\n    }\n  }\n}\n/**\n * The current loadingStatus of the API.\n */\nGoogleMapsApiLoader.loadingStatus = APILoadingStatus.NOT_LOADED;\n/**\n * The parameters used for first loading the API.\n */\nGoogleMapsApiLoader.serializedApiParams = void 0;\n/**\n * A list of functions to be notified when the loading status changes.\n */\nGoogleMapsApiLoader.listeners = [];\n\nconst _excluded$3 = [\"onLoad\", \"onError\", \"apiKey\", \"version\", \"libraries\"],\n  _excluded2$1 = [\"children\"];\nconst DEFAULT_SOLUTION_CHANNEL = 'GMP_visgl_rgmlibrary_v1_default';\nconst APIProviderContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * local hook to set up the map-instance management context.\n */\nfunction useMapInstances() {\n  const [mapInstances, setMapInstances] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n  const addMapInstance = (mapInstance, id = 'default') => {\n    setMapInstances(instances => _extends({}, instances, {\n      [id]: mapInstance\n    }));\n  };\n  const removeMapInstance = (id = 'default') => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setMapInstances(_ref => {\n      let remaining = _objectWithoutPropertiesLoose(_ref, [id].map(_toPropertyKey));\n      return remaining;\n    });\n  };\n  const clearMapInstances = () => {\n    setMapInstances({});\n  };\n  return {\n    mapInstances,\n    addMapInstance,\n    removeMapInstance,\n    clearMapInstances\n  };\n}\n/**\n * local hook to handle the loading of the maps API, returns the current loading status\n * @param props\n */\nfunction useGoogleMapsApiLoader(props) {\n  const {\n      onLoad,\n      onError,\n      apiKey,\n      version,\n      libraries = []\n    } = props,\n    otherApiParams = _objectWithoutPropertiesLoose(props, _excluded$3);\n  const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(GoogleMapsApiLoader.loadingStatus);\n  const [loadedLibraries, addLoadedLibrary] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((loadedLibraries, action) => {\n    return loadedLibraries[action.name] ? loadedLibraries : _extends({}, loadedLibraries, {\n      [action.name]: action.value\n    });\n  }, {});\n  const librariesString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => libraries == null ? void 0 : libraries.join(','), [libraries]);\n  const serializedParams = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => JSON.stringify(_extends({\n    apiKey,\n    version\n  }, otherApiParams)), [apiKey, version, otherApiParams]);\n  const importLibrary = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async name => {\n    var _google;\n    if (loadedLibraries[name]) {\n      return loadedLibraries[name];\n    }\n    if (!((_google = google) != null && (_google = _google.maps) != null && _google.importLibrary)) {\n      throw new Error('[api-provider-internal] importLibrary was called before ' + 'google.maps.importLibrary was defined.');\n    }\n    const res = await window.google.maps.importLibrary(name);\n    addLoadedLibrary({\n      name,\n      value: res\n    });\n    return res;\n  }, [loadedLibraries]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    (async () => {\n      try {\n        const params = _extends({\n          key: apiKey\n        }, otherApiParams);\n        if (version) params.v = version;\n        if ((librariesString == null ? void 0 : librariesString.length) > 0) params.libraries = librariesString;\n        if (params.channel === undefined || params.channel < 0 || params.channel > 999) delete params.channel;\n        if (params.solutionChannel === undefined) params.solutionChannel = DEFAULT_SOLUTION_CHANNEL;else if (params.solutionChannel === '') delete params.solutionChannel;\n        await GoogleMapsApiLoader.load(params, status => setStatus(status));\n        for (const name of ['core', 'maps', ...libraries]) {\n          await importLibrary(name);\n        }\n        if (onLoad) {\n          onLoad();\n        }\n      } catch (error) {\n        if (onError) {\n          onError(error);\n        } else {\n          console.error('<ApiProvider> failed to load the Google Maps JavaScript API', error);\n        }\n      }\n    })();\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [apiKey, librariesString, serializedParams]);\n  return {\n    status,\n    loadedLibraries,\n    importLibrary\n  };\n}\n/**\n * Component to wrap the components from this library and load the Google Maps JavaScript API\n */\nconst APIProvider = props => {\n  const {\n      children\n    } = props,\n    loaderProps = _objectWithoutPropertiesLoose(props, _excluded2$1);\n  const {\n    mapInstances,\n    addMapInstance,\n    removeMapInstance,\n    clearMapInstances\n  } = useMapInstances();\n  const {\n    status,\n    loadedLibraries,\n    importLibrary\n  } = useGoogleMapsApiLoader(loaderProps);\n  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n    mapInstances,\n    addMapInstance,\n    removeMapInstance,\n    clearMapInstances,\n    status,\n    loadedLibraries,\n    importLibrary\n  }), [mapInstances, addMapInstance, removeMapInstance, clearMapInstances, status, loadedLibraries, importLibrary]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(APIProviderContext.Provider, {\n    value: contextValue\n  }, children);\n};\n\n/**\n * Sets up effects to bind event-handlers for all event-props in MapEventProps.\n * @internal\n */\nfunction useMapEvents(map, props) {\n  // note: calling a useEffect hook from within a loop is prohibited by the\n  // rules of hooks, but it's ok here since it's unconditional and the number\n  // and order of iterations is always strictly the same.\n  // (see https://legacy.reactjs.org/docs/hooks-rules.html)\n  for (const propName of eventPropNames) {\n    // fixme: this cast is essentially a 'trust me, bro' for typescript, but\n    //   a proper solution seems way too complicated right now\n    const handler = props[propName];\n    const eventType = propNameToEventType[propName];\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      if (!map) return;\n      if (!handler) return;\n      const listener = google.maps.event.addListener(map, eventType, ev => {\n        handler(createMapEvent(eventType, map, ev));\n      });\n      return () => listener.remove();\n    }, [map, eventType, handler]);\n  }\n}\n/**\n * Create the wrapped map-events used for the event-props.\n * @param type the event type as it is specified to the maps api\n * @param map the map instance the event originates from\n * @param srcEvent the source-event if there is one.\n */\nfunction createMapEvent(type, map, srcEvent) {\n  const ev = {\n    type,\n    map,\n    detail: {},\n    stoppable: false,\n    stop: () => {}\n  };\n  if (cameraEventTypes.includes(type)) {\n    const camEvent = ev;\n    const center = map.getCenter();\n    const zoom = map.getZoom();\n    const heading = map.getHeading() || 0;\n    const tilt = map.getTilt() || 0;\n    const bounds = map.getBounds();\n    if (!center || !bounds || !Number.isFinite(zoom)) {\n      console.warn('[createEvent] at least one of the values from the map ' + 'returned undefined. This is not expected to happen. Please ' + 'report an issue at https://github.com/visgl/react-google-maps/issues/new');\n    }\n    camEvent.detail = {\n      center: (center == null ? void 0 : center.toJSON()) || {\n        lat: 0,\n        lng: 0\n      },\n      zoom: zoom || 0,\n      heading: heading,\n      tilt: tilt,\n      bounds: (bounds == null ? void 0 : bounds.toJSON()) || {\n        north: 90,\n        east: 180,\n        south: -90,\n        west: -180\n      }\n    };\n    return camEvent;\n  } else if (mouseEventTypes.includes(type)) {\n    var _srcEvent$latLng;\n    if (!srcEvent) throw new Error('[createEvent] mouse events must provide a srcEvent');\n    const mouseEvent = ev;\n    mouseEvent.domEvent = srcEvent.domEvent;\n    mouseEvent.stoppable = true;\n    mouseEvent.stop = () => srcEvent.stop();\n    mouseEvent.detail = {\n      latLng: ((_srcEvent$latLng = srcEvent.latLng) == null ? void 0 : _srcEvent$latLng.toJSON()) || null,\n      placeId: srcEvent.placeId\n    };\n    return mouseEvent;\n  }\n  return ev;\n}\n/**\n * maps the camelCased names of event-props to the corresponding event-types\n * used in the maps API.\n */\nconst propNameToEventType = {\n  onBoundsChanged: 'bounds_changed',\n  onCenterChanged: 'center_changed',\n  onClick: 'click',\n  onContextmenu: 'contextmenu',\n  onDblclick: 'dblclick',\n  onDrag: 'drag',\n  onDragend: 'dragend',\n  onDragstart: 'dragstart',\n  onHeadingChanged: 'heading_changed',\n  onIdle: 'idle',\n  onIsFractionalZoomEnabledChanged: 'isfractionalzoomenabled_changed',\n  onMapCapabilitiesChanged: 'mapcapabilities_changed',\n  onMapTypeIdChanged: 'maptypeid_changed',\n  onMousemove: 'mousemove',\n  onMouseout: 'mouseout',\n  onMouseover: 'mouseover',\n  onProjectionChanged: 'projection_changed',\n  onRenderingTypeChanged: 'renderingtype_changed',\n  onTilesLoaded: 'tilesloaded',\n  onTiltChanged: 'tilt_changed',\n  onZoomChanged: 'zoom_changed',\n  // note: onCameraChanged is an alias for the bounds_changed event,\n  // since that is going to be fired in every situation where the camera is\n  // updated.\n  onCameraChanged: 'bounds_changed'\n};\nconst cameraEventTypes = ['bounds_changed', 'center_changed', 'heading_changed', 'tilt_changed', 'zoom_changed'];\nconst mouseEventTypes = ['click', 'contextmenu', 'dblclick', 'mousemove', 'mouseout', 'mouseover'];\nconst eventPropNames = Object.keys(propNameToEventType);\n\nfunction useDeepCompareEffect(effect, deps) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n  if (!ref.current || !fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__(deps, ref.current)) {\n    ref.current = deps;\n  }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(effect, ref.current);\n}\n\nconst mapOptionKeys = new Set(['backgroundColor', 'clickableIcons', 'controlSize', 'disableDefaultUI', 'disableDoubleClickZoom', 'draggable', 'draggableCursor', 'draggingCursor', 'fullscreenControl', 'fullscreenControlOptions', 'gestureHandling', 'headingInteractionEnabled', 'isFractionalZoomEnabled', 'keyboardShortcuts', 'mapTypeControl', 'mapTypeControlOptions', 'mapTypeId', 'maxZoom', 'minZoom', 'noClear', 'panControl', 'panControlOptions', 'restriction', 'rotateControl', 'rotateControlOptions', 'scaleControl', 'scaleControlOptions', 'scrollwheel', 'streetView', 'streetViewControl', 'streetViewControlOptions', 'styles', 'tiltInteractionEnabled', 'zoomControl', 'zoomControlOptions']);\n/**\n * Internal hook to update the map-options when props are changed.\n *\n * @param map the map instance\n * @param mapProps the props to update the map-instance with\n * @internal\n */\nfunction useMapOptions(map, mapProps) {\n  /* eslint-disable react-hooks/exhaustive-deps --\n   *\n   * The following effects aren't triggered when the map is changed.\n   * In that case, the values will be or have been passed to the map\n   * constructor via mapOptions.\n   */\n  const mapOptions = {};\n  const keys = Object.keys(mapProps);\n  for (const key of keys) {\n    if (!mapOptionKeys.has(key)) continue;\n    mapOptions[key] = mapProps[key];\n  }\n  // update the map options when mapOptions is changed\n  // Note: due to the destructuring above, mapOptions will be seen as changed\n  //   with every re-render, so we're assuming the maps-api will properly\n  //   deal with unchanged option-values passed into setOptions.\n  useDeepCompareEffect(() => {\n    if (!map) return;\n    map.setOptions(mapOptions);\n  }, [mapOptions]);\n  /* eslint-enable react-hooks/exhaustive-deps */\n}\n\nfunction useApiLoadingStatus() {\n  var _useContext;\n  return ((_useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext)) == null ? void 0 : _useContext.status) || APILoadingStatus.NOT_LOADED;\n}\n\n/**\n * Internal hook that updates the camera when deck.gl viewState changes.\n * @internal\n */\nfunction useDeckGLCameraUpdate(map, props) {\n  const {\n    viewport,\n    viewState\n  } = props;\n  const isDeckGlControlled = !!viewport;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (!map || !viewState) return;\n    const {\n      latitude,\n      longitude,\n      bearing: heading,\n      pitch: tilt,\n      zoom\n    } = viewState;\n    map.moveCamera({\n      center: {\n        lat: latitude,\n        lng: longitude\n      },\n      heading,\n      tilt,\n      zoom: zoom + 1\n    });\n  }, [map, viewState]);\n  return isDeckGlControlled;\n}\n\nfunction isLatLngLiteral(obj) {\n  if (!obj || typeof obj !== 'object') return false;\n  if (!('lat' in obj && 'lng' in obj)) return false;\n  return Number.isFinite(obj.lat) && Number.isFinite(obj.lng);\n}\nfunction latLngEquals(a, b) {\n  if (!a || !b) return false;\n  const A = toLatLngLiteral(a);\n  const B = toLatLngLiteral(b);\n  if (A.lat !== B.lat || A.lng !== B.lng) return false;\n  return true;\n}\nfunction toLatLngLiteral(obj) {\n  if (isLatLngLiteral(obj)) return obj;\n  return obj.toJSON();\n}\n\nfunction useMapCameraParams(map, cameraStateRef, mapProps) {\n  const center = mapProps.center ? toLatLngLiteral(mapProps.center) : null;\n  let lat = null;\n  let lng = null;\n  if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n    lat = center.lat;\n    lng = center.lng;\n  }\n  const zoom = Number.isFinite(mapProps.zoom) ? mapProps.zoom : null;\n  const heading = Number.isFinite(mapProps.heading) ? mapProps.heading : null;\n  const tilt = Number.isFinite(mapProps.tilt) ? mapProps.tilt : null;\n  // the following effect runs for every render of the map component and checks\n  // if there are differences between the known state of the map instance\n  // (cameraStateRef, which is updated by all bounds_changed events) and the\n  // desired state in the props.\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (!map) return;\n    const nextCamera = {};\n    let needsUpdate = false;\n    if (lat !== null && lng !== null && (cameraStateRef.current.center.lat !== lat || cameraStateRef.current.center.lng !== lng)) {\n      nextCamera.center = {\n        lat,\n        lng\n      };\n      needsUpdate = true;\n    }\n    if (zoom !== null && cameraStateRef.current.zoom !== zoom) {\n      nextCamera.zoom = zoom;\n      needsUpdate = true;\n    }\n    if (heading !== null && cameraStateRef.current.heading !== heading) {\n      nextCamera.heading = heading;\n      needsUpdate = true;\n    }\n    if (tilt !== null && cameraStateRef.current.tilt !== tilt) {\n      nextCamera.tilt = tilt;\n      needsUpdate = true;\n    }\n    if (needsUpdate) {\n      map.moveCamera(nextCamera);\n    }\n  });\n}\n\nconst AuthFailureMessage = () => {\n  const style = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0,\n    zIndex: 999,\n    display: 'flex',\n    flexFlow: 'column nowrap',\n    textAlign: 'center',\n    justifyContent: 'center',\n    fontSize: '.8rem',\n    color: 'rgba(0,0,0,0.6)',\n    background: '#dddddd',\n    padding: '1rem 1.5rem'\n  };\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    style: style\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h2\", null, \"Error: AuthFailure\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"A problem with your API key prevents the map from rendering correctly. Please make sure the value of the \", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", null, \"APIProvider.apiKey\"), \" prop is correct. Check the error-message in the console for further details.\"));\n};\n\nfunction useCallbackRef() {\n  const [el, setEl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(value => setEl(value), [setEl]);\n  return [el, ref];\n}\n\n/**\n * Hook to check if the Maps JavaScript API is loaded\n */\nfunction useApiIsLoaded() {\n  const status = useApiLoadingStatus();\n  return status === APILoadingStatus.LOADED;\n}\n\nfunction useForceUpdate() {\n  const [, forceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(x => x + 1, 0);\n  return forceUpdate;\n}\n\nfunction handleBoundsChange(map, ref) {\n  const center = map.getCenter();\n  const zoom = map.getZoom();\n  const heading = map.getHeading() || 0;\n  const tilt = map.getTilt() || 0;\n  const bounds = map.getBounds();\n  if (!center || !bounds || !Number.isFinite(zoom)) {\n    console.warn('[useTrackedCameraState] at least one of the values from the map ' + 'returned undefined. This is not expected to happen. Please ' + 'report an issue at https://github.com/visgl/react-google-maps/issues/new');\n  }\n  // fixme: do we need the `undefined` cases for the camera-params? When are they used in the maps API?\n  Object.assign(ref.current, {\n    center: (center == null ? void 0 : center.toJSON()) || {\n      lat: 0,\n      lng: 0\n    },\n    zoom: zoom || 0,\n    heading: heading,\n    tilt: tilt\n  });\n}\n/**\n * Creates a mutable ref object to track the last known state of the map camera.\n * This is used in `useMapCameraParams` to reduce stuttering in normal operation\n * by avoiding updates of the map camera with values that have already been processed.\n */\nfunction useTrackedCameraStateRef(map) {\n  const forceUpdate = useForceUpdate();\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    center: {\n      lat: 0,\n      lng: 0\n    },\n    heading: 0,\n    tilt: 0,\n    zoom: 0\n  });\n  // Record camera state with every bounds_changed event dispatched by the map.\n  // This data is used to prevent feeding these values back to the\n  // map-instance when a typical \"controlled component\" setup (state variable is\n  // fed into and updated by the map).\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!map) return;\n    const listener = google.maps.event.addListener(map, 'bounds_changed', () => {\n      handleBoundsChange(map, ref);\n      // When an event is occured, we have to update during the next cycle.\n      // The application could decide to ignore the event and not update any\n      // camera props of the map, meaning that in that case we will have to\n      // 'undo' the change to the camera.\n      forceUpdate();\n    });\n    return () => listener.remove();\n  }, [map, forceUpdate]);\n  return ref;\n}\n\nconst _excluded$2 = [\"id\", \"defaultBounds\", \"defaultCenter\", \"defaultZoom\", \"defaultHeading\", \"defaultTilt\", \"reuseMaps\", \"renderingType\", \"colorScheme\"],\n  _excluded2 = [\"padding\"];\n/**\n * Stores a stack of map-instances for each mapId. Whenever an\n * instance is used, it is removed from the stack while in use,\n * and returned to the stack when the component unmounts.\n * This allows us to correctly implement caching for multiple\n * maps om the same page, while reusing as much as possible.\n *\n * FIXME: while it should in theory be possible to reuse maps solely\n *   based on the mapId (as all other parameters can be changed at\n *   runtime), we don't yet have good enough tracking of options to\n *   reliably unset all the options that have been set.\n */\nclass CachedMapStack {\n  static has(key) {\n    return this.entries[key] && this.entries[key].length > 0;\n  }\n  static pop(key) {\n    if (!this.entries[key]) return null;\n    return this.entries[key].pop() || null;\n  }\n  static push(key, value) {\n    if (!this.entries[key]) this.entries[key] = [];\n    this.entries[key].push(value);\n  }\n}\n/**\n * The main hook takes care of creating map-instances and registering them in\n * the api-provider context.\n * @return a tuple of the map-instance created (or null) and the callback\n *   ref that will be used to pass the map-container into this hook.\n * @internal\n */\nCachedMapStack.entries = {};\nfunction useMapInstance(props, context) {\n  const apiIsLoaded = useApiIsLoaded();\n  const [map, setMap] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const [container, containerRef] = useCallbackRef();\n  const cameraStateRef = useTrackedCameraStateRef(map);\n  const {\n      id,\n      defaultBounds,\n      defaultCenter,\n      defaultZoom,\n      defaultHeading,\n      defaultTilt,\n      reuseMaps,\n      renderingType,\n      colorScheme\n    } = props,\n    mapOptions = _objectWithoutPropertiesLoose(props, _excluded$2);\n  const hasZoom = props.zoom !== undefined || props.defaultZoom !== undefined;\n  const hasCenter = props.center !== undefined || props.defaultCenter !== undefined;\n  if (!defaultBounds && (!hasZoom || !hasCenter)) {\n    console.warn('<Map> component is missing configuration. ' + 'You have to provide zoom and center (via the `zoom`/`defaultZoom` and ' + '`center`/`defaultCenter` props) or specify the region to show using ' + '`defaultBounds`. See ' + 'https://visgl.github.io/react-google-maps/docs/api-reference/components/map#required');\n  }\n  // apply default camera props if available and not overwritten by controlled props\n  if (!mapOptions.center && defaultCenter) mapOptions.center = defaultCenter;\n  if (!mapOptions.zoom && Number.isFinite(defaultZoom)) mapOptions.zoom = defaultZoom;\n  if (!mapOptions.heading && Number.isFinite(defaultHeading)) mapOptions.heading = defaultHeading;\n  if (!mapOptions.tilt && Number.isFinite(defaultTilt)) mapOptions.tilt = defaultTilt;\n  for (const key of Object.keys(mapOptions)) if (mapOptions[key] === undefined) delete mapOptions[key];\n  const savedMapStateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n  // create the map instance and register it in the context\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!container || !apiIsLoaded) return;\n    const {\n      addMapInstance,\n      removeMapInstance\n    } = context;\n    // note: colorScheme (upcoming feature) isn't yet in the typings, remove once that is fixed:\n    const {\n      mapId\n    } = props;\n    const cacheKey = `${mapId || 'default'}:${renderingType || 'default'}:${colorScheme || 'LIGHT'}`;\n    let mapDiv;\n    let map;\n    if (reuseMaps && CachedMapStack.has(cacheKey)) {\n      map = CachedMapStack.pop(cacheKey);\n      mapDiv = map.getDiv();\n      container.appendChild(mapDiv);\n      map.setOptions(mapOptions);\n      // detaching the element from the DOM lets the map fall back to its default\n      // size, setting the center will trigger reloading the map.\n      setTimeout(() => map.setCenter(map.getCenter()), 0);\n    } else {\n      mapDiv = document.createElement('div');\n      mapDiv.style.height = '100%';\n      container.appendChild(mapDiv);\n      map = new google.maps.Map(mapDiv, _extends({}, mapOptions, renderingType ? {\n        renderingType: renderingType\n      } : {}, colorScheme ? {\n        colorScheme: colorScheme\n      } : {}));\n    }\n    setMap(map);\n    addMapInstance(map, id);\n    if (defaultBounds) {\n      const {\n          padding\n        } = defaultBounds,\n        defBounds = _objectWithoutPropertiesLoose(defaultBounds, _excluded2);\n      map.fitBounds(defBounds, padding);\n    }\n    // prevent map not rendering due to missing configuration\n    else if (!hasZoom || !hasCenter) {\n      map.fitBounds({\n        east: 180,\n        west: -180,\n        south: -90,\n        north: 90\n      });\n    }\n    // the savedMapState is used to restore the camera parameters when the mapId is changed\n    if (savedMapStateRef.current) {\n      const {\n        mapId: savedMapId,\n        cameraState: savedCameraState\n      } = savedMapStateRef.current;\n      if (savedMapId !== mapId) {\n        map.setOptions(savedCameraState);\n      }\n    }\n    return () => {\n      savedMapStateRef.current = {\n        mapId,\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        cameraState: cameraStateRef.current\n      };\n      // detach the map-div from the dom\n      mapDiv.remove();\n      if (reuseMaps) {\n        // push back on the stack\n        CachedMapStack.push(cacheKey, map);\n      } else {\n        // remove all event-listeners to minimize the possibility of memory-leaks\n        google.maps.event.clearInstanceListeners(map);\n      }\n      setMap(null);\n      removeMapInstance(id);\n    };\n  },\n  // some dependencies are ignored in the list below:\n  //  - defaultBounds and the default* camera props will only be used once, and\n  //    changes should be ignored\n  //  - mapOptions has special hooks that take care of updating the options\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [container, apiIsLoaded, id,\n  // these props can't be changed after initialization and require a new\n  // instance to be created\n  props.mapId, props.renderingType, props.colorScheme]);\n  return [map, containerRef, cameraStateRef];\n}\n\nconst GoogleMapsContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n// ColorScheme and RenderingType are redefined here to make them usable before the\n// maps API has been fully loaded.\nconst ColorScheme = {\n  DARK: 'DARK',\n  LIGHT: 'LIGHT',\n  FOLLOW_SYSTEM: 'FOLLOW_SYSTEM'\n};\nconst RenderingType = {\n  VECTOR: 'VECTOR',\n  RASTER: 'RASTER',\n  UNINITIALIZED: 'UNINITIALIZED'\n};\nconst Map = props => {\n  const {\n    children,\n    id,\n    className,\n    style\n  } = props;\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n  const loadingStatus = useApiLoadingStatus();\n  if (!context) {\n    throw new Error('<Map> can only be used inside an <ApiProvider> component.');\n  }\n  const [map, mapRef, cameraStateRef] = useMapInstance(props, context);\n  useMapCameraParams(map, cameraStateRef, props);\n  useMapEvents(map, props);\n  useMapOptions(map, props);\n  const isDeckGlControlled = useDeckGLCameraUpdate(map, props);\n  const isControlledExternally = !!props.controlled;\n  // disable interactions with the map for externally controlled maps\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!map) return;\n    // fixme: this doesn't seem to belong here (and it's mostly there for convenience anyway).\n    //   The reasoning is that a deck.gl canvas will be put on top of the map, rendering\n    //   any default map controls pretty much useless\n    if (isDeckGlControlled) {\n      map.setOptions({\n        disableDefaultUI: true\n      });\n    }\n    // disable all control-inputs when the map is controlled externally\n    if (isDeckGlControlled || isControlledExternally) {\n      map.setOptions({\n        gestureHandling: 'none',\n        keyboardShortcuts: false\n      });\n    }\n    return () => {\n      map.setOptions({\n        gestureHandling: props.gestureHandling,\n        keyboardShortcuts: props.keyboardShortcuts\n      });\n    };\n  }, [map, isDeckGlControlled, isControlledExternally, props.gestureHandling, props.keyboardShortcuts]);\n  // setup a stable cameraOptions object that can be used as dependency\n  const center = props.center ? toLatLngLiteral(props.center) : null;\n  let lat = null;\n  let lng = null;\n  if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n    lat = center.lat;\n    lng = center.lng;\n  }\n  const cameraOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    var _lat, _lng, _props$zoom, _props$heading, _props$tilt;\n    return {\n      center: {\n        lat: (_lat = lat) != null ? _lat : 0,\n        lng: (_lng = lng) != null ? _lng : 0\n      },\n      zoom: (_props$zoom = props.zoom) != null ? _props$zoom : 0,\n      heading: (_props$heading = props.heading) != null ? _props$heading : 0,\n      tilt: (_props$tilt = props.tilt) != null ? _props$tilt : 0\n    };\n  }, [lat, lng, props.zoom, props.heading, props.tilt]);\n  // externally controlled mode: reject all camera changes that don't correspond to changes in props\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (!map || !isControlledExternally) return;\n    map.moveCamera(cameraOptions);\n    const listener = map.addListener('bounds_changed', () => {\n      map.moveCamera(cameraOptions);\n    });\n    return () => listener.remove();\n  }, [map, isControlledExternally, cameraOptions]);\n  const combinedStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => _extends({\n    width: '100%',\n    height: '100%',\n    position: 'relative',\n    // when using deckgl, the map should be sent to the back\n    zIndex: isDeckGlControlled ? -1 : 0\n  }, style), [style, isDeckGlControlled]);\n  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n    map\n  }), [map]);\n  if (loadingStatus === APILoadingStatus.AUTH_FAILURE) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      style: _extends({\n        position: 'relative'\n      }, className ? {} : combinedStyle),\n      className: className\n    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(AuthFailureMessage, null));\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", _extends({\n    ref: mapRef,\n    \"data-testid\": 'map',\n    style: className ? undefined : combinedStyle,\n    className: className\n  }, id ? {\n    id\n  } : {}), map ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(GoogleMapsContext.Provider, {\n    value: contextValue\n  }, children) : null);\n};\n// The deckGLViewProps flag here indicates to deck.gl that the Map component is\n// able to handle viewProps from deck.gl when deck.gl is used to control the map.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nMap.deckGLViewProps = true;\n\nconst shownMessages = new Set();\nfunction logErrorOnce(...args) {\n  const key = JSON.stringify(args);\n  if (!shownMessages.has(key)) {\n    shownMessages.add(key);\n    console.error(...args);\n  }\n}\n\n/**\n * Retrieves a map-instance from the context. This is either an instance\n * identified by id or the parent map instance if no id is specified.\n * Returns null if neither can be found.\n */\nconst useMap = (id = null) => {\n  const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n  const {\n    map\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(GoogleMapsContext) || {};\n  if (ctx === null) {\n    logErrorOnce('useMap(): failed to retrieve APIProviderContext. ' + 'Make sure that the <APIProvider> component exists and that the ' + 'component you are calling `useMap()` from is a sibling of the ' + '<APIProvider>.');\n    return null;\n  }\n  const {\n    mapInstances\n  } = ctx;\n  // if an id is specified, the corresponding map or null is returned\n  if (id !== null) return mapInstances[id] || null;\n  // otherwise, return the closest ancestor\n  if (map) return map;\n  // finally, return the default map instance\n  return mapInstances['default'] || null;\n};\n\nfunction useMapsLibrary(name) {\n  const apiIsLoaded = useApiIsLoaded();\n  const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!apiIsLoaded || !ctx) return;\n    // Trigger loading the libraries via our proxy-method.\n    // The returned promise is ignored, since importLibrary will update loadedLibraries\n    // list in the context, triggering a re-render.\n    void ctx.importLibrary(name);\n  }, [apiIsLoaded, ctx, name]);\n  return (ctx == null ? void 0 : ctx.loadedLibraries[name]) || null;\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Internally used to bind events to Maps JavaScript API objects.\n * @internal\n */\nfunction useMapsEventListener(target, name, callback) {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!target || !name || !callback) return;\n    const listener = google.maps.event.addListener(target, name, callback);\n    return () => listener.remove();\n  }, [target, name, callback]);\n}\n\n/**\n * Internally used to copy values from props into API-Objects\n * whenever they change.\n *\n * @example\n *   usePropBinding(marker, 'position', position);\n *\n * @internal\n */\nfunction usePropBinding(object, prop, value) {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!object) return;\n    object[prop] = value;\n  }, [object, prop, value]);\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Internally used to bind events to DOM nodes.\n * @internal\n */\nfunction useDomEventListener(target, name, callback) {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!target || !name || !callback) return;\n    target.addEventListener(name, callback);\n    return () => target.removeEventListener(name, callback);\n  }, [target, name, callback]);\n}\n\n/* eslint-disable complexity */\nfunction isAdvancedMarker(marker) {\n  return marker.content !== undefined;\n}\nfunction isElementNode(node) {\n  return node.nodeType === Node.ELEMENT_NODE;\n}\n/**\n * Copy of the `google.maps.CollisionBehavior` constants.\n * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.\n */\nconst CollisionBehavior = {\n  REQUIRED: 'REQUIRED',\n  REQUIRED_AND_HIDES_OPTIONAL: 'REQUIRED_AND_HIDES_OPTIONAL',\n  OPTIONAL_AND_HIDES_LOWER_PRIORITY: 'OPTIONAL_AND_HIDES_LOWER_PRIORITY'\n};\nconst AdvancedMarkerContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n// [xPosition, yPosition] when the top left corner is [0, 0]\nconst AdvancedMarkerAnchorPoint = {\n  TOP_LEFT: ['0%', '0%'],\n  TOP_CENTER: ['50%', '0%'],\n  TOP: ['50%', '0%'],\n  TOP_RIGHT: ['100%', '0%'],\n  LEFT_CENTER: ['0%', '50%'],\n  LEFT_TOP: ['0%', '0%'],\n  LEFT: ['0%', '50%'],\n  LEFT_BOTTOM: ['0%', '100%'],\n  RIGHT_TOP: ['100%', '0%'],\n  RIGHT: ['100%', '50%'],\n  RIGHT_CENTER: ['100%', '50%'],\n  RIGHT_BOTTOM: ['100%', '100%'],\n  BOTTOM_LEFT: ['0%', '100%'],\n  BOTTOM_CENTER: ['50%', '100%'],\n  BOTTOM: ['50%', '100%'],\n  BOTTOM_RIGHT: ['100%', '100%'],\n  CENTER: ['50%', '50%']\n};\nconst MarkerContent = ({\n  children,\n  styles,\n  className,\n  anchorPoint\n}) => {\n  const [xTranslation, yTranslation] = anchorPoint != null ? anchorPoint : AdvancedMarkerAnchorPoint['BOTTOM'];\n  let xTranslationFlipped = `-${xTranslation}`;\n  let yTranslationFlipped = `-${yTranslation}`;\n  if (xTranslation.trimStart().startsWith('-')) {\n    xTranslationFlipped = xTranslation.substring(1);\n  }\n  if (yTranslation.trimStart().startsWith('-')) {\n    yTranslationFlipped = yTranslation.substring(1);\n  }\n  // The \"translate(50%, 100%)\" is here to counter and reset the default anchoring of the advanced marker element\n  // that comes from the api\n  const transformStyle = `translate(50%, 100%) translate(${xTranslationFlipped}, ${yTranslationFlipped})`;\n  return (\n    /*#__PURE__*/\n    // anchoring container\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      style: {\n        transform: transformStyle\n      }\n    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      className: className,\n      style: styles\n    }, children))\n  );\n};\nfunction useAdvancedMarker(props) {\n  const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const [contentContainer, setContentContainer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const map = useMap();\n  const markerLibrary = useMapsLibrary('marker');\n  const {\n    children,\n    onClick,\n    className,\n    onMouseEnter,\n    onMouseLeave,\n    onDrag,\n    onDragStart,\n    onDragEnd,\n    collisionBehavior,\n    clickable,\n    draggable,\n    position,\n    title,\n    zIndex\n  } = props;\n  const numChildren = react__WEBPACK_IMPORTED_MODULE_0__.Children.count(children);\n  // create an AdvancedMarkerElement instance and add it to the map once available\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!map || !markerLibrary) return;\n    const newMarker = new markerLibrary.AdvancedMarkerElement();\n    newMarker.map = map;\n    setMarker(newMarker);\n    // create the container for marker content if there are children\n    let contentElement = null;\n    if (numChildren > 0) {\n      contentElement = document.createElement('div');\n      // We need some kind of flag to identify the custom marker content\n      // in the infowindow component. Choosing a custom property instead of a className\n      // to not encourage users to style the marker content directly.\n      contentElement.isCustomMarker = true;\n      newMarker.content = contentElement;\n      setContentContainer(contentElement);\n    }\n    return () => {\n      var _contentElement;\n      newMarker.map = null;\n      (_contentElement = contentElement) == null || _contentElement.remove();\n      setMarker(null);\n      setContentContainer(null);\n    };\n  }, [map, markerLibrary, numChildren]);\n  // When no children are present we don't have our own wrapper div\n  // which usually gets the user provided className. In this case\n  // we set the className directly on the marker.content element that comes\n  // with the AdvancedMarker.\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!(marker != null && marker.content) || !isElementNode(marker.content) || numChildren > 0) return;\n    marker.content.className = className != null ? className : '';\n  }, [marker, className, numChildren]);\n  // copy other props\n  usePropBinding(marker, 'position', position);\n  usePropBinding(marker, 'title', title != null ? title : '');\n  usePropBinding(marker, 'zIndex', zIndex);\n  usePropBinding(marker, 'collisionBehavior', collisionBehavior);\n  // set gmpDraggable from props (when unspecified, it's true if any drag-event\n  // callbacks are specified)\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!marker) return;\n    if (draggable !== undefined) marker.gmpDraggable = draggable;else if (onDrag || onDragStart || onDragEnd) marker.gmpDraggable = true;else marker.gmpDraggable = false;\n  }, [marker, draggable, onDrag, onDragEnd, onDragStart]);\n  // set gmpClickable from props (when unspecified, it's true if the onClick or one of\n  // the hover events callbacks are specified)\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!marker) return;\n    const gmpClickable = clickable !== undefined || Boolean(onClick) || Boolean(onMouseEnter) || Boolean(onMouseLeave);\n    // gmpClickable is only available in beta version of the\n    // maps api (as of 2024-10-10)\n    marker.gmpClickable = gmpClickable;\n    // enable pointer events for the markers with custom content\n    if (gmpClickable && marker != null && marker.content && isElementNode(marker.content)) {\n      marker.content.style.pointerEvents = 'none';\n      if (marker.content.firstElementChild) {\n        marker.content.firstElementChild.style.pointerEvents = 'all';\n      }\n    }\n  }, [marker, clickable, onClick, onMouseEnter, onMouseLeave]);\n  useMapsEventListener(marker, 'click', onClick);\n  useMapsEventListener(marker, 'drag', onDrag);\n  useMapsEventListener(marker, 'dragstart', onDragStart);\n  useMapsEventListener(marker, 'dragend', onDragEnd);\n  useDomEventListener(marker == null ? void 0 : marker.element, 'mouseenter', onMouseEnter);\n  useDomEventListener(marker == null ? void 0 : marker.element, 'mouseleave', onMouseLeave);\n  return [marker, contentContainer];\n}\nconst AdvancedMarker = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref) => {\n  const {\n    children,\n    style,\n    className,\n    anchorPoint\n  } = props;\n  const [marker, contentContainer] = useAdvancedMarker(props);\n  const advancedMarkerContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => marker ? {\n    marker\n  } : null, [marker]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => marker, [marker]);\n  if (!contentContainer) return null;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(AdvancedMarkerContext.Provider, {\n    value: advancedMarkerContextValue\n  }, (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkerContent, {\n    anchorPoint: anchorPoint,\n    styles: style,\n    className: className\n  }, children), contentContainer));\n});\nfunction useAdvancedMarkerRef() {\n  const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const refCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(m => {\n    setMarker(m);\n  }, []);\n  return [refCallback, marker];\n}\n\nfunction setValueForStyles(element, styles, prevStyles) {\n  if (styles != null && typeof styles !== 'object') {\n    throw new Error('The `style` prop expects a mapping from style properties to values, ' + \"not a string. For example, style={{marginRight: spacing + 'em'}} when \" + 'using JSX.');\n  }\n  const elementStyle = element.style;\n  // without `prevStyles`, just set all values\n  if (prevStyles == null) {\n    if (styles == null) return;\n    for (const styleName in styles) {\n      if (!styles.hasOwnProperty(styleName)) continue;\n      setValueForStyle(elementStyle, styleName, styles[styleName]);\n    }\n    return;\n  }\n  // unset all styles in `prevStyles` that aren't in `styles`\n  for (const styleName in prevStyles) {\n    if (prevStyles.hasOwnProperty(styleName) && (styles == null || !styles.hasOwnProperty(styleName))) {\n      // Clear style\n      const isCustomProperty = styleName.indexOf('--') === 0;\n      if (isCustomProperty) {\n        elementStyle.setProperty(styleName, '');\n      } else if (styleName === 'float') {\n        elementStyle.cssFloat = '';\n      } else {\n        elementStyle[styleName] = '';\n      }\n    }\n  }\n  // only assign values from `styles` that are different from `prevStyles`\n  if (styles == null) return;\n  for (const styleName in styles) {\n    const value = styles[styleName];\n    if (styles.hasOwnProperty(styleName) && prevStyles[styleName] !== value) {\n      setValueForStyle(elementStyle, styleName, value);\n    }\n  }\n}\nfunction setValueForStyle(elementStyle, styleName, value) {\n  const isCustomProperty = styleName.indexOf('--') === 0;\n  // falsy values will unset the style property\n  if (value == null || typeof value === 'boolean' || value === '') {\n    if (isCustomProperty) {\n      elementStyle.setProperty(styleName, '');\n    } else if (styleName === 'float') {\n      elementStyle.cssFloat = '';\n    } else {\n      elementStyle[styleName] = '';\n    }\n  }\n  // custom properties can't be directly assigned\n  else if (isCustomProperty) {\n    elementStyle.setProperty(styleName, value);\n  }\n  // numeric values are treated as 'px' unless the style property expects unitless numbers\n  else if (typeof value === 'number' && value !== 0 && !isUnitlessNumber(styleName)) {\n    elementStyle[styleName] = value + 'px'; // Presumes implicit 'px' suffix for unitless numbers\n  }\n  // everything else can just be assigned\n  else {\n    if (styleName === 'float') {\n      elementStyle.cssFloat = value;\n    } else {\n      elementStyle[styleName] = ('' + value).trim();\n    }\n  }\n}\n// CSS properties which accept numbers but are not in units of \"px\".\nconst unitlessNumbers = new Set(['animationIterationCount', 'aspectRatio', 'borderImageOutset', 'borderImageSlice', 'borderImageWidth', 'boxFlex', 'boxFlexGroup', 'boxOrdinalGroup', 'columnCount', 'columns', 'flex', 'flexGrow', 'flexPositive', 'flexShrink', 'flexNegative', 'flexOrder', 'gridArea', 'gridRow', 'gridRowEnd', 'gridRowSpan', 'gridRowStart', 'gridColumn', 'gridColumnEnd', 'gridColumnSpan', 'gridColumnStart', 'fontWeight', 'lineClamp', 'lineHeight', 'opacity', 'order', 'orphans', 'scale', 'tabSize', 'widows', 'zIndex', 'zoom', 'fillOpacity',\n// SVG-related properties\n'floodOpacity', 'stopOpacity', 'strokeDasharray', 'strokeDashoffset', 'strokeMiterlimit', 'strokeOpacity', 'strokeWidth']);\nfunction isUnitlessNumber(name) {\n  return unitlessNumbers.has(name);\n}\n\nconst _excluded$1 = [\"children\", \"headerContent\", \"style\", \"className\", \"pixelOffset\", \"anchor\", \"shouldFocus\", \"onClose\", \"onCloseClick\"];\n/**\n * Component to render an Info Window with the Maps JavaScript API\n */\nconst InfoWindow = props => {\n  const {\n      // content options\n      children,\n      headerContent,\n      style,\n      className,\n      pixelOffset,\n      // open options\n      anchor,\n      shouldFocus,\n      // events\n      onClose,\n      onCloseClick\n      // other options\n    } = props,\n    infoWindowOptions = _objectWithoutPropertiesLoose(props, _excluded$1);\n  // ## create infowindow instance once the mapsLibrary is available.\n  const mapsLibrary = useMapsLibrary('maps');\n  const [infoWindow, setInfoWindow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const contentContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const headerContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!mapsLibrary) return;\n    contentContainerRef.current = document.createElement('div');\n    headerContainerRef.current = document.createElement('div');\n    const opts = infoWindowOptions;\n    if (pixelOffset) {\n      opts.pixelOffset = new google.maps.Size(pixelOffset[0], pixelOffset[1]);\n    }\n    if (headerContent) {\n      // if headerContent is specified as string we can directly forward it,\n      // otherwise we'll pass the element the portal will render into\n      opts.headerContent = typeof headerContent === 'string' ? headerContent : headerContainerRef.current;\n    }\n    // intentionally shadowing the state variables here\n    const infoWindow = new google.maps.InfoWindow(infoWindowOptions);\n    infoWindow.setContent(contentContainerRef.current);\n    setInfoWindow(infoWindow);\n    // unmount: remove infoWindow and content elements (note: close is called in a different effect-cleanup)\n    return () => {\n      var _contentContainerRef$, _headerContainerRef$c;\n      infoWindow.setContent(null);\n      (_contentContainerRef$ = contentContainerRef.current) == null || _contentContainerRef$.remove();\n      (_headerContainerRef$c = headerContainerRef.current) == null || _headerContainerRef$c.remove();\n      contentContainerRef.current = null;\n      headerContainerRef.current = null;\n      setInfoWindow(null);\n    };\n  },\n  // `infoWindowOptions` and other props are missing from dependencies:\n  //\n  // We don't want to re-create the infowindow instance\n  // when the options change.\n  // Updating the options is handled in the useEffect below.\n  //\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [mapsLibrary]);\n  // ## update className and styles for `contentContainer`\n  // stores previously applied style properties, so they can be removed when unset\n  const prevStyleRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!infoWindow || !contentContainerRef.current) return;\n    setValueForStyles(contentContainerRef.current, style || null, prevStyleRef.current);\n    prevStyleRef.current = style || null;\n    if (className !== contentContainerRef.current.className) contentContainerRef.current.className = className || '';\n  }, [infoWindow, className, style]);\n  // ## update options\n  useDeepCompareEffect(() => {\n    if (!infoWindow) return;\n    const opts = infoWindowOptions;\n    if (!pixelOffset) {\n      opts.pixelOffset = null;\n    } else {\n      opts.pixelOffset = new google.maps.Size(pixelOffset[0], pixelOffset[1]);\n    }\n    if (!headerContent) {\n      opts.headerContent = null;\n    } else {\n      opts.headerContent = typeof headerContent === 'string' ? headerContent : headerContainerRef.current;\n    }\n    infoWindow.setOptions(infoWindowOptions);\n  },\n  // dependency `infoWindow` isn't needed since options are also passed\n  // to the constructor when a new infoWindow is created.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [infoWindowOptions, pixelOffset, headerContent]);\n  // ## bind event handlers\n  useMapsEventListener(infoWindow, 'close', onClose);\n  useMapsEventListener(infoWindow, 'closeclick', onCloseClick);\n  // ## open info window when content and map are available\n  const map = useMap();\n  useDeepCompareEffect(() => {\n    // `anchor === null` means an anchor is defined but not ready yet.\n    if (!map || !infoWindow || anchor === null) return;\n    const isOpenedWithAnchor = !!anchor;\n    const openOptions = {\n      map\n    };\n    if (anchor) {\n      openOptions.anchor = anchor;\n      // Only do the infowindow adjusting when dealing with an AdvancedMarker\n      if (isAdvancedMarker(anchor) && anchor.content instanceof Element) {\n        const wrapper = anchor.content;\n        const wrapperBcr = wrapper == null ? void 0 : wrapper.getBoundingClientRect();\n        // This checks whether or not the anchor has custom content with our own\n        // div wrapper. If not, that means we have a regular AdvancedMarker without any children.\n        // In that case we do not want to adjust the infowindow since it is all handled correctly\n        // by the Google Maps API.\n        if (wrapperBcr && wrapper != null && wrapper.isCustomMarker) {\n          var _anchor$content$first;\n          // We can safely typecast here since we control that element and we know that\n          // it is a div\n          const anchorDomContent = (_anchor$content$first = anchor.content.firstElementChild) == null ? void 0 : _anchor$content$first.firstElementChild;\n          const contentBcr = anchorDomContent == null ? void 0 : anchorDomContent.getBoundingClientRect();\n          // center infowindow above marker\n          const anchorOffsetX = contentBcr.x - wrapperBcr.x + (contentBcr.width - wrapperBcr.width) / 2;\n          const anchorOffsetY = contentBcr.y - wrapperBcr.y;\n          const opts = infoWindowOptions;\n          opts.pixelOffset = new google.maps.Size(pixelOffset ? pixelOffset[0] + anchorOffsetX : anchorOffsetX, pixelOffset ? pixelOffset[1] + anchorOffsetY : anchorOffsetY);\n          infoWindow.setOptions(opts);\n        }\n      }\n    }\n    if (shouldFocus !== undefined) {\n      openOptions.shouldFocus = shouldFocus;\n    }\n    infoWindow.open(openOptions);\n    return () => {\n      // Note: when the infowindow has an anchor, it will automatically show up again when the\n      // anchor was removed from the map before infoWindow.close() is called but the it gets\n      // added back to the map after that.\n      // More information here: https://issuetracker.google.com/issues/343750849\n      if (isOpenedWithAnchor) infoWindow.set('anchor', null);\n      infoWindow.close();\n    };\n  }, [infoWindow, anchor, map, shouldFocus, infoWindowOptions, pixelOffset]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, contentContainerRef.current && (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, contentContainerRef.current), headerContainerRef.current !== null && (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(headerContent, headerContainerRef.current));\n};\n\n/**\n * Formats a location into a string representation suitable for Google Static Maps API.\n *\n * @param location - The location to format, can be either a string or an object with lat/lng properties\n * @returns A string representation of the location in the format \"lat,lng\" or the original string\n *\n * @example\n * // Returns \"40.714728,-73.998672\"\n * formatLocation({ lat: 40.714728, lng: -73.998672 })\n *\n * @example\n * // Returns \"New York, NY\"\n * formatLocation(\"New York, NY\")\n */\nfunction formatLocation(location) {\n  return typeof location === 'string' ? location : `${location.lat},${location.lng}`;\n}\n// Used for removing the leading pipe from the param string\nfunction formatParam(string) {\n  return string.slice(1);\n}\n\n/**\n * Assembles marker parameters for static maps.\n *\n * This function takes an array of markers and groups them by their style properties.\n * It then creates a string representation of these markers, including their styles and locations,\n * which can be used as parameters for static map APIs.\n *\n * @param {StaticMapsMarker[]} [markers=[]] - An array of markers to be processed. Each marker can have properties such as color, label, size, scale, icon, anchor, and location.\n * @returns {string[]} An array of strings, each representing a group of markers with their styles and locations.\n *\n * @example\n * const markers = [\n *   { color: 'blue', label: 'A', size: 'mid', location: '40.714728,-73.998672' },\n *   { color: 'blue', label: 'B', size: 'mid', location: '40.714728,-73.998672' },\n *   { icon: 'http://example.com/icon.png', location: { lat: 40.714728, lng: -73.998672 } }\n * ];\n * const params = assembleMarkerParams(markers);\n * // Params will be an array of strings representing the marker parameters\n * Example output: [\n *   \"color:blue|label:A|size:mid|40.714728,-73.998672|40.714728,-73.998672\",\n *   \"color:blue|label:B|size:mid|40.714728,-73.998672|40.714728,-73.998672\",\n *   \"icon:http://example.com/icon.png|40.714728,-73.998672\"\n * ]\n */\nfunction assembleMarkerParams(markers = []) {\n  const markerParams = [];\n  // Group markers by style\n  const markersByStyle = markers == null ? void 0 : markers.reduce((styles, marker) => {\n    const {\n      color = 'red',\n      label,\n      size,\n      scale,\n      icon,\n      anchor\n    } = marker;\n    // Create a unique style key based on either icon properties or standard marker properties\n    const relevantProps = icon ? [icon, anchor, scale] : [color, label, size];\n    const key = relevantProps.filter(Boolean).join('-');\n    styles[key] = styles[key] || [];\n    styles[key].push(marker);\n    return styles;\n  }, {});\n  Object.values(markersByStyle != null ? markersByStyle : {}).forEach(markers => {\n    let markerParam = '';\n    const {\n      icon\n    } = markers[0];\n    // Create marker style from first marker in group since all markers share the same style.\n    Object.entries(markers[0]).forEach(([key, value]) => {\n      // Determine which properties to include based on whether marker uses custom icon\n      const relevantKeys = icon ? ['icon', 'anchor', 'scale'] : ['color', 'label', 'size'];\n      if (relevantKeys.includes(key)) {\n        markerParam += `|${key}:${value}`;\n      }\n    });\n    // Add location coordinates for each marker in the style group\n    // Handles both string locations and lat/lng object formats.\n    for (const marker of markers) {\n      const location = typeof marker.location === 'string' ? marker.location : `${marker.location.lat},${marker.location.lng}`;\n      markerParam += `|${location}`;\n    }\n    markerParams.push(markerParam);\n  });\n  return markerParams.map(formatParam);\n}\n\n/**\n * Assembles path parameters for the Static Maps Api from an array of paths.\n *\n * This function groups paths by their style properties (color, weight, fillcolor, geodesic)\n * and then constructs a string of path parameters for each group. Each path parameter string\n * includes the style properties and the coordinates of the paths.\n *\n * @param {Array<StaticMapsPath>} [paths=[]] - An array of paths to be assembled into path parameters.\n * @returns {Array<string>} An array of path parameter strings.\n *\n * @example\n * const paths = [\n *   {\n *     color: 'red',\n *     weight: 5,\n *     coordinates: [\n *       { lat: 40.714728, lng: -73.998672 },\n *       { lat: 40.718217, lng: -73.998284 }\n *     ]\n *   }\n * ];\n *\n * const pathParams = assemblePathParams(paths);\n * Output: [\n *    'color:red|weight:5|40.714728,-73.998672|40.718217,-73.998284'\n *  ]\n */\nfunction assemblePathParams(paths = []) {\n  const pathParams = [];\n  // Group paths by their style properties (color, weight, fillcolor, geodesic)\n  // to combine paths with identical styles into single parameter strings\n  const pathsByStyle = paths == null ? void 0 : paths.reduce((styles, path) => {\n    const {\n      color = 'default',\n      weight,\n      fillcolor,\n      geodesic\n    } = path;\n    // Create unique key for this style combination\n    const key = [color, weight, fillcolor, geodesic].filter(Boolean).join('-');\n    styles[key] = styles[key] || [];\n    styles[key].push(path);\n    return styles;\n  }, {});\n  // Process each group of paths with identical styles\n  Object.values(pathsByStyle != null ? pathsByStyle : {}).forEach(paths => {\n    let pathParam = '';\n    // Build style parameter string using properties from first path in group\n    // since all paths in this group share the same style\n    Object.entries(paths[0]).forEach(([key, value]) => {\n      if (['color', 'weight', 'fillcolor', 'geodesic'].includes(key)) {\n        pathParam += `|${key}:${value}`;\n      }\n    });\n    // Add location for all marker in style group\n    for (const path of paths) {\n      if (typeof path.coordinates === 'string') {\n        pathParam += `|${decodeURIComponent(path.coordinates)}`;\n      } else {\n        for (const location of path.coordinates) {\n          pathParam += `|${formatLocation(location)}`;\n        }\n      }\n    }\n    pathParams.push(pathParam);\n  });\n  return pathParams.map(formatParam);\n}\n\n/**\n * Converts an array of Google Maps style objects into an array of style strings\n * compatible with the Google Static Maps API.\n *\n * @param styles - An array of Google Maps MapTypeStyle objects that define the styling rules\n * @returns An array of formatted style strings ready to be used with the Static Maps API\n *\n * @example\n * const styles = [{\n *   featureType: \"road\",\n *   elementType: \"geometry\",\n *   stylers: [{color: \"#ff0000\"}, {weight: 1}]\n * }];\n *\n * const styleStrings = assembleMapTypeStyles(styles);\n * // Returns: [\"|feature:road|element:geometry|color:0xff0000|weight:1\"]\n *\n * Each style string follows the format:\n * \"feature:{featureType}|element:{elementType}|{stylerName}:{stylerValue}\"\n *\n * Note: Color values with hexadecimal notation (#) are automatically converted\n * to the required 0x format for the Static Maps API.\n */\nfunction assembleMapTypeStyles(styles) {\n  return styles.map(mapTypeStyle => {\n    const {\n      featureType,\n      elementType,\n      stylers = []\n    } = mapTypeStyle;\n    let styleString = '';\n    if (featureType) {\n      styleString += `|feature:${featureType}`;\n    }\n    if (elementType) {\n      styleString += `|element:${elementType}`;\n    }\n    for (const styler of stylers) {\n      Object.entries(styler).forEach(([name, value]) => {\n        styleString += `|${name}:${String(value).replace('#', '0x')}`;\n      });\n    }\n    return styleString;\n  }).map(formatParam);\n}\n\nconst STATIC_MAPS_BASE = 'https://maps.googleapis.com/maps/api/staticmap';\n/**\n * Creates a URL for the Google Static Maps API with the specified parameters.\n *\n * @param {Object} options - The configuration options for the static map\n * @param {string} options.apiKey - Your Google Maps API key (required)\n * @param {number} options.width - The width of the map image in pixels (required)\n * @param {number} options.height - The height of the map image in pixels (required)\n * @param {StaticMapsLocation} [options.center] - The center point of the map (lat/lng or address).\n *  Required if no markers or paths or \"visible locations\" are provided.\n * @param {number} [options.zoom] - The zoom level of the map. Required if no markers or paths or \"visible locations\" are provided.\n * @param {1|2|4} [options.scale] - The resolution of the map (1, 2, or 4)\n * @param {string} [options.format] - The image format (png, png8, png32, gif, jpg, jpg-baseline)\n * @param {string} [options.mapType] - The type of map (roadmap, satellite, terrain, hybrid)\n * @param {string} [options.language] - The language of the map labels\n * @param {string} [options.region] - The region code for the map\n * @param {string} [options.map_id] - The Cloud-based map style ID\n * @param {StaticMapsMarker[]} [options.markers=[]] - Array of markers to display on the map\n * @param {StaticMapsPath[]} [options.paths=[]] - Array of paths to display on the map\n * @param {StaticMapsLocation[]} [options.visible=[]] - Array of locations that should be visible on the map\n * @param {MapTypeStyle[]} [options.style=[]] - Array of style objects to customize the map appearance\n *\n * @returns {string} The complete Google Static Maps API URL\n *\n * @throws {Error} If API key is not provided\n * @throws {Error} If width or height is not provided\n *\n * @example\n * const url = createStaticMapsUrl({\n *   apiKey: 'YOUR_API_KEY',\n *   width: 600,\n *   height: 400,\n *   center: { lat: 40.714728, lng: -73.998672 },\n *   zoom: 12,\n *   markers: [\n *     {\n *       location: { lat: 40.714728, lng: -73.998672 },\n *       color: 'red',\n *       label: 'A'\n *     }\n *   ],\n *   paths: [\n *     {\n *       coordinates: [\n *         { lat: 40.714728, lng: -73.998672 },\n *         { lat: 40.719728, lng: -73.991672 }\n *       ],\n *       color: '0x0000ff',\n *       weight: 5\n *     }\n *   ],\n *   style: [\n *     {\n *       featureType: 'road',\n *       elementType: 'geometry',\n *       stylers: [{color: '#00ff00'}]\n *     }\n *   ]\n * });\n *\n * // Results in URL similar to:\n * // https://maps.googleapis.com/maps/api/staticmap?key=YOUR_API_KEY\n * // &size=600x400\n * // &center=40.714728,-73.998672&zoom=12\n * // &markers=color:red|label:A|40.714728,-73.998672\n * // &path=color:0x0000ff|weight:5|40.714728,-73.998672|40.719728,-73.991672\n * // &style=feature:road|element:geometry|color:0x00ff00\n */\nfunction createStaticMapsUrl({\n  apiKey,\n  width,\n  height,\n  center,\n  zoom,\n  scale,\n  format,\n  mapType,\n  language,\n  region,\n  mapId,\n  markers = [],\n  paths = [],\n  visible = [],\n  style = []\n}) {\n  if (!apiKey) {\n    console.warn('API key is required');\n  }\n  if (!width || !height) {\n    console.warn('Width and height are required');\n  }\n  const params = _extends({\n    key: apiKey,\n    size: `${width}x${height}`\n  }, center && {\n    center: formatLocation(center)\n  }, zoom && {\n    zoom\n  }, scale && {\n    scale\n  }, format && {\n    format\n  }, mapType && {\n    maptype: mapType\n  }, language && {\n    language\n  }, region && {\n    region\n  }, mapId && {\n    map_id: mapId\n  });\n  const url = new URL(STATIC_MAPS_BASE);\n  // Params that don't need special handling\n  Object.entries(params).forEach(([key, value]) => {\n    url.searchParams.append(key, String(value));\n  });\n  // Assemble Markers\n  for (const markerParam of assembleMarkerParams(markers)) {\n    url.searchParams.append('markers', markerParam);\n  }\n  // Assemble Paths\n  for (const pathParam of assemblePathParams(paths)) {\n    url.searchParams.append('path', pathParam);\n  }\n  // Assemble visible locations\n  if (visible.length) {\n    url.searchParams.append('visible', visible.map(location => formatLocation(location)).join('|'));\n  }\n  // Assemble Map Type Styles\n  for (const styleString of assembleMapTypeStyles(style)) {\n    url.searchParams.append('style', styleString);\n  }\n  return url.toString();\n}\n\nconst StaticMap = props => {\n  const {\n    url,\n    className\n  } = props;\n  if (!url) throw new Error('URL is required');\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", {\n    className: className,\n    src: url,\n    width: \"100%\"\n  });\n};\n\n/**\n * Copy of the `google.maps.ControlPosition` constants.\n * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.\n */\nconst ControlPosition = {\n  TOP_LEFT: 1,\n  TOP_CENTER: 2,\n  TOP: 2,\n  TOP_RIGHT: 3,\n  LEFT_CENTER: 4,\n  LEFT_TOP: 5,\n  LEFT: 5,\n  LEFT_BOTTOM: 6,\n  RIGHT_TOP: 7,\n  RIGHT: 7,\n  RIGHT_CENTER: 8,\n  RIGHT_BOTTOM: 9,\n  BOTTOM_LEFT: 10,\n  BOTTOM_CENTER: 11,\n  BOTTOM: 11,\n  BOTTOM_RIGHT: 12,\n  CENTER: 13,\n  BLOCK_START_INLINE_START: 14,\n  BLOCK_START_INLINE_CENTER: 15,\n  BLOCK_START_INLINE_END: 16,\n  INLINE_START_BLOCK_CENTER: 17,\n  INLINE_START_BLOCK_START: 18,\n  INLINE_START_BLOCK_END: 19,\n  INLINE_END_BLOCK_START: 20,\n  INLINE_END_BLOCK_CENTER: 21,\n  INLINE_END_BLOCK_END: 22,\n  BLOCK_END_INLINE_START: 23,\n  BLOCK_END_INLINE_CENTER: 24,\n  BLOCK_END_INLINE_END: 25\n};\nconst MapControl = ({\n  children,\n  position\n}) => {\n  const controlContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => document.createElement('div'), []);\n  const map = useMap();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!map) return;\n    const controls = map.controls[position];\n    controls.push(controlContainer);\n    return () => {\n      const controlsArray = controls.getArray();\n      // controlsArray could be undefined if the map is in an undefined state (e.g. invalid API-key, see #276\n      if (!controlsArray) return;\n      const index = controlsArray.indexOf(controlContainer);\n      controls.removeAt(index);\n    };\n  }, [controlContainer, map, position]);\n  return (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, controlContainer);\n};\n\nconst _excluded = [\"onClick\", \"onDrag\", \"onDragStart\", \"onDragEnd\", \"onMouseOver\", \"onMouseOut\"];\nfunction useMarker(props) {\n  const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const map = useMap();\n  const {\n      onClick,\n      onDrag,\n      onDragStart,\n      onDragEnd,\n      onMouseOver,\n      onMouseOut\n    } = props,\n    markerOptions = _objectWithoutPropertiesLoose(props, _excluded);\n  const {\n    position,\n    draggable\n  } = markerOptions;\n  // create marker instance and add to the map once the map is available\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!map) {\n      if (map === undefined) console.error('<Marker> has to be inside a Map component.');\n      return;\n    }\n    const newMarker = new google.maps.Marker(markerOptions);\n    newMarker.setMap(map);\n    setMarker(newMarker);\n    return () => {\n      newMarker.setMap(null);\n      setMarker(null);\n    };\n    // We do not want to re-render the whole marker when the options change.\n    // Marker options update is handled in a useEffect below.\n    // Excluding markerOptions from dependency array on purpose here.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [map]);\n  // attach and re-attach event-handlers when any of the properties change\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!marker) return;\n    const m = marker;\n    // Add event listeners\n    const gme = google.maps.event;\n    if (onClick) gme.addListener(m, 'click', onClick);\n    if (onDrag) gme.addListener(m, 'drag', onDrag);\n    if (onDragStart) gme.addListener(m, 'dragstart', onDragStart);\n    if (onDragEnd) gme.addListener(m, 'dragend', onDragEnd);\n    if (onMouseOver) gme.addListener(m, 'mouseover', onMouseOver);\n    if (onMouseOut) gme.addListener(m, 'mouseout', onMouseOut);\n    marker.setDraggable(Boolean(draggable));\n    return () => {\n      gme.clearInstanceListeners(m);\n    };\n  }, [marker, draggable, onClick, onDrag, onDragStart, onDragEnd, onMouseOver, onMouseOut]);\n  // update markerOptions (note the dependencies aren't properly checked\n  // here, we just assume that setOptions is smart enough to not waste a\n  // lot of time updating values that didn't change)\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!marker) return;\n    if (markerOptions) marker.setOptions(markerOptions);\n  }, [marker, markerOptions]);\n  // update position when changed\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    // Should not update position when draggable\n    if (draggable || !position || !marker) return;\n    marker.setPosition(position);\n  }, [draggable, position, marker]);\n  return marker;\n}\n/**\n * Component to render a marker on a map\n */\nconst Marker = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref) => {\n  const marker = useMarker(props);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => marker, [marker]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);\n});\nfunction useMarkerRef() {\n  const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const refCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(m => {\n    setMarker(m);\n  }, []);\n  return [refCallback, marker];\n}\n\n/**\n * Component to configure the appearance of an AdvancedMarker\n */\nconst Pin = props => {\n  var _useContext;\n  const advancedMarker = (_useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AdvancedMarkerContext)) == null ? void 0 : _useContext.marker;\n  const glyphContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => document.createElement('div'), []);\n  // Create Pin View instance\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    var _advancedMarker$conte;\n    if (!advancedMarker) {\n      if (advancedMarker === undefined) {\n        console.error('The <Pin> component can only be used inside <AdvancedMarker>.');\n      }\n      return;\n    }\n    if (props.glyph && props.children) {\n      logErrorOnce('The <Pin> component only uses children to render the glyph if both the glyph property and children are present.');\n    }\n    if (react__WEBPACK_IMPORTED_MODULE_0__.Children.count(props.children) > 1) {\n      logErrorOnce('Passing multiple children to the <Pin> component might lead to unexpected results.');\n    }\n    const pinViewOptions = _extends({}, props);\n    const pinElement = new google.maps.marker.PinElement(pinViewOptions);\n    // Set glyph to glyph container if children are present (rendered via portal).\n    // If both props.glyph and props.children are present, props.children takes priority.\n    if (props.children) {\n      pinElement.glyph = glyphContainer;\n    }\n    // Set content of Advanced Marker View to the Pin View element\n    // Here we are selecting the anchor container.\n    // The hierarchy is as follows:\n    // \"advancedMarker.content\" (from google) -> \"pointer events reset div\" -> \"anchor container\"\n    const markerContent = (_advancedMarker$conte = advancedMarker.content) == null || (_advancedMarker$conte = _advancedMarker$conte.firstChild) == null ? void 0 : _advancedMarker$conte.firstChild;\n    while (markerContent != null && markerContent.firstChild) {\n      markerContent.removeChild(markerContent.firstChild);\n    }\n    if (markerContent) {\n      markerContent.appendChild(pinElement.element);\n    }\n  }, [advancedMarker, glyphContainer, props]);\n  return (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(props.children, glyphContainer);\n};\n\nconst mapLinear = (x, a1, a2, b1, b2) => b1 + (x - a1) * (b2 - b1) / (a2 - a1);\nconst getMapMaxTilt = zoom => {\n  if (zoom <= 10) {\n    return 30;\n  }\n  if (zoom >= 15.5) {\n    return 67.5;\n  }\n  // range [10...14]\n  if (zoom <= 14) {\n    return mapLinear(zoom, 10, 14, 30, 45);\n  }\n  // range [14...15.5]\n  return mapLinear(zoom, 14, 15.5, 45, 67.5);\n};\n/**\n * Function to limit the tilt range of the Google map when updating the view state\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst limitTiltRange = ({\n  viewState\n}) => {\n  const pitch = viewState.pitch;\n  const gmZoom = viewState.zoom + 1;\n  const maxTilt = getMapMaxTilt(gmZoom);\n  return _extends({}, viewState, {\n    fovy: 25,\n    pitch: Math.min(maxTilt, pitch)\n  });\n};\n\n\n//# sourceMappingURL=index.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdmlzLmdsL3JlYWN0LWdvb2dsZS1tYXBzL2Rpc3QvaW5kZXgubW9kZXJuLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxSztBQUM1SDtBQUNDOztBQUUxQztBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsdURBQVk7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUUrYztBQUMvYyIsInNvdXJjZXMiOlsiL1VzZXJzL2FwcGxlL1Byb2plY3RzL1Byb2RhbmNlL0ZFL25vZGVfbW9kdWxlcy9AdmlzLmdsL3JlYWN0LWdvb2dsZS1tYXBzL2Rpc3QvaW5kZXgubW9kZXJuLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlTWVtbywgdXNlU3RhdGUsIHVzZVJlZHVjZXIsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlQ29udGV4dCwgdXNlTGF5b3V0RWZmZWN0LCBmb3J3YXJkUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgaXNEZWVwRXF1YWwgZnJvbSAnZmFzdC1kZWVwLWVxdWFsJztcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIHJldHVybiBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgZm9yICh2YXIgZSA9IDE7IGUgPCBhcmd1bWVudHMubGVuZ3RoOyBlKyspIHtcbiAgICAgIHZhciB0ID0gYXJndW1lbnRzW2VdO1xuICAgICAgZm9yICh2YXIgciBpbiB0KSAoe30pLmhhc093blByb3BlcnR5LmNhbGwodCwgcikgJiYgKG5bcl0gPSB0W3JdKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH0sIF9leHRlbmRzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShyLCBlKSB7XG4gIGlmIChudWxsID09IHIpIHJldHVybiB7fTtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgbiBpbiByKSBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChyLCBuKSkge1xuICAgIGlmICgtMSAhPT0gZS5pbmRleE9mKG4pKSBjb250aW51ZTtcbiAgICB0W25dID0gcltuXTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjtcbn1cblxuY29uc3QgQVBJTG9hZGluZ1N0YXR1cyA9IHtcbiAgTk9UX0xPQURFRDogJ05PVF9MT0FERUQnLFxuICBMT0FESU5HOiAnTE9BRElORycsXG4gIExPQURFRDogJ0xPQURFRCcsXG4gIEZBSUxFRDogJ0ZBSUxFRCcsXG4gIEFVVEhfRkFJTFVSRTogJ0FVVEhfRkFJTFVSRSdcbn07XG5cbmNvbnN0IE1BUFNfQVBJX0JBU0VfVVJMID0gJ2h0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9qcyc7XG4vKipcbiAqIEEgR29vZ2xlTWFwc0FwaUxvYWRlciB0byByZWxpYWJseSBsb2FkIGFuZCB1bmxvYWQgdGhlIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJLlxuICpcbiAqIFRoZSBhY3R1YWwgbG9hZGluZyBhbmQgdW5sb2FkaW5nIGlzIGRlbGF5ZWQgaW50byB0aGUgbWljcm90YXNrIHF1ZXVlLCB0b1xuICogYWxsb3cgdXNpbmcgdGhlIEFQSSBpbiBhbiB1c2VFZmZlY3QgaG9vaywgd2l0aG91dCB3b3JyeWluZyBhYm91dCBtdWx0aXBsZSBBUEkgbG9hZHMuXG4gKi9cbmNsYXNzIEdvb2dsZU1hcHNBcGlMb2FkZXIge1xuICAvKipcbiAgICogTG9hZHMgdGhlIE1hcHMgSmF2YVNjcmlwdCBBUEkgd2l0aCB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnMuXG4gICAqIFNpbmNlIHRoZSBNYXBzIGxpYnJhcnkgY2FuIG9ubHkgYmUgbG9hZGVkIG9uY2UgcGVyIHBhZ2UsIHRoaXMgd2lsbFxuICAgKiBwcm9kdWNlIGEgd2FybmluZyB3aGVuIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudFxuICAgKiBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBUaGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcyB3aGVuIGxvYWRpbmcgY29tcGxldGVzXG4gICAqIGFuZCByZWplY3RzIGluIGNhc2Ugb2YgYW4gZXJyb3Igb3Igd2hlbiB0aGUgbG9hZGluZyB3YXMgYWJvcnRlZC5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBsb2FkKHBhcmFtcywgb25Mb2FkaW5nU3RhdHVzQ2hhbmdlKSB7XG4gICAgdmFyIF93aW5kb3ckZ29vZ2xlO1xuICAgIGNvbnN0IGxpYnJhcmllcyA9IHBhcmFtcy5saWJyYXJpZXMgPyBwYXJhbXMubGlicmFyaWVzLnNwbGl0KCcsJykgOiBbXTtcbiAgICBjb25zdCBzZXJpYWxpemVkUGFyYW1zID0gdGhpcy5zZXJpYWxpemVQYXJhbXMocGFyYW1zKTtcbiAgICB0aGlzLmxpc3RlbmVycy5wdXNoKG9uTG9hZGluZ1N0YXR1c0NoYW5nZSk7XG4gICAgLy8gTm90ZTogaWYgYGdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnlgIGhhcyBiZWVuIGRlZmluZWQgZXh0ZXJuYWxseSwgd2VcbiAgICAvLyAgIGFzc3VtZSB0aGF0IGxvYWRpbmcgaXMgY29tcGxldGUgYW5kIHN1Y2Nlc3NmdWwuXG4gICAgLy8gICBJZiBpdCB3YXMgZGVmaW5lZCBieSBhIHByZXZpb3VzIGNhbGwgdG8gdGhpcyBtZXRob2QsIGEgd2FybmluZ1xuICAgIC8vICAgbWVzc2FnZSBpcyBsb2dnZWQgaWYgdGhlcmUgYXJlIGRpZmZlcmVuY2VzIGluIGFwaS1wYXJhbWV0ZXJzIHVzZWRcbiAgICAvLyAgIGZvciBib3RoIGNhbGxzLlxuICAgIGlmICgoX3dpbmRvdyRnb29nbGUgPSB3aW5kb3cuZ29vZ2xlKSAhPSBudWxsICYmIChfd2luZG93JGdvb2dsZSA9IF93aW5kb3ckZ29vZ2xlLm1hcHMpICE9IG51bGwgJiYgX3dpbmRvdyRnb29nbGUuaW1wb3J0TGlicmFyeSkge1xuICAgICAgLy8gbm8gc2VyaWFsaXplZCBwYXJhbWV0ZXJzIG1lYW5zIGl0IHdhcyBsb2FkZWQgZXh0ZXJuYWxseVxuICAgICAgaWYgKCF0aGlzLnNlcmlhbGl6ZWRBcGlQYXJhbXMpIHtcbiAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gQVBJTG9hZGluZ1N0YXR1cy5MT0FERUQ7XG4gICAgICB9XG4gICAgICB0aGlzLm5vdGlmeUxvYWRpbmdTdGF0dXNMaXN0ZW5lcnMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXJpYWxpemVkQXBpUGFyYW1zID0gc2VyaWFsaXplZFBhcmFtcztcbiAgICAgIHRoaXMuaW5pdEltcG9ydExpYnJhcnkocGFyYW1zKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2VyaWFsaXplZEFwaVBhcmFtcyAmJiB0aGlzLnNlcmlhbGl6ZWRBcGlQYXJhbXMgIT09IHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICAgIGNvbnNvbGUud2FybihgW2dvb2dsZS1tYXBzLWFwaS1sb2FkZXJdIFRoZSBtYXBzIEFQSSBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZCBgICsgYHdpdGggZGlmZmVyZW50IHBhcmFtZXRlcnMgYW5kIHdpbGwgbm90IGJlIGxvYWRlZCBhZ2Fpbi4gUmVmcmVzaCB0aGUgYCArIGBwYWdlIGZvciBuZXcgdmFsdWVzIHRvIGhhdmUgZWZmZWN0LmApO1xuICAgIH1cbiAgICBjb25zdCBsaWJyYXJpZXNUb0xvYWQgPSBbJ21hcHMnLCAuLi5saWJyYXJpZXNdO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKGxpYnJhcmllc1RvTG9hZC5tYXAobmFtZSA9PiBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5KG5hbWUpKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgcGFyYW1ldGVycyB1c2VkIHRvIGxvYWQgdGhlIGxpYnJhcnkgZm9yIGVhc2llciBjb21wYXJpc29uLlxuICAgKi9cbiAgc3RhdGljIHNlcmlhbGl6ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICByZXR1cm4gW3BhcmFtcy52LCBwYXJhbXMua2V5LCBwYXJhbXMubGFuZ3VhZ2UsIHBhcmFtcy5yZWdpb24sIHBhcmFtcy5hdXRoUmVmZXJyZXJQb2xpY3ksIHBhcmFtcy5zb2x1dGlvbkNoYW5uZWxdLmpvaW4oJy8nKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgZ2xvYmFsIGBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5YCBmdW5jdGlvbiBmb3IgYm9vdHN0cmFwcGluZy5cbiAgICogVGhpcyBpcyBlc3NlbnRpYWxseSBhIGZvcm1hdHRlZCB2ZXJzaW9uIG9mIHRoZSBkeW5hbWljIGxvYWRpbmcgc2NyaXB0XG4gICAqIGZyb20gdGhlIG9mZmljaWFsIGRvY3VtZW50YXRpb24gd2l0aCBzb21lIG1pbm9yIGFkanVzdG1lbnRzLlxuICAgKlxuICAgKiBUaGUgY3JlYXRlZCBpbXBvcnRMaWJyYXJ5IGZ1bmN0aW9uIHdpbGwgbG9hZCB0aGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEksXG4gICAqIHdoaWNoIHdpbGwgdGhlbiByZXBsYWNlIHRoZSBgZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeWAgZnVuY3Rpb24gd2l0aCB0aGUgZnVsbFxuICAgKiBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9sb2FkLW1hcHMtanMtYXBpI2R5bmFtaWMtbGlicmFyeS1pbXBvcnRcbiAgICovXG4gIHN0YXRpYyBpbml0SW1wb3J0TGlicmFyeShwYXJhbXMpIHtcbiAgICBpZiAoIXdpbmRvdy5nb29nbGUpIHdpbmRvdy5nb29nbGUgPSB7fTtcbiAgICBpZiAoIXdpbmRvdy5nb29nbGUubWFwcykgd2luZG93Lmdvb2dsZS5tYXBzID0ge307XG4gICAgaWYgKHdpbmRvdy5nb29nbGUubWFwc1snaW1wb3J0TGlicmFyeSddKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbZ29vZ2xlLW1hcHMtYXBpLWxvYWRlci1pbnRlcm5hbF06IGluaXRJbXBvcnRMaWJyYXJ5IG11c3Qgb25seSBiZSBjYWxsZWQgb25jZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgYXBpUHJvbWlzZSA9IG51bGw7XG4gICAgY29uc3QgbG9hZEFwaSA9ICgpID0+IHtcbiAgICAgIGlmIChhcGlQcm9taXNlKSByZXR1cm4gYXBpUHJvbWlzZTtcbiAgICAgIGFwaVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHZhciBfZG9jdW1lbnQkcXVlcnlTZWxlY3Q7XG4gICAgICAgIGNvbnN0IHNjcmlwdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbXMpKSB7XG4gICAgICAgICAgY29uc3QgdXJsUGFyYW1OYW1lID0ga2V5LnJlcGxhY2UoL1tBLVpdL2csIHQgPT4gJ18nICsgdFswXS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB1cmxQYXJhbXMuc2V0KHVybFBhcmFtTmFtZSwgU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdXJsUGFyYW1zLnNldCgnbG9hZGluZycsICdhc3luYycpO1xuICAgICAgICB1cmxQYXJhbXMuc2V0KCdjYWxsYmFjaycsICdfX2dvb2dsZU1hcHNDYWxsYmFja19fJyk7XG4gICAgICAgIHNjcmlwdEVsZW1lbnQuYXN5bmMgPSB0cnVlO1xuICAgICAgICBzY3JpcHRFbGVtZW50LnNyYyA9IE1BUFNfQVBJX0JBU0VfVVJMICsgYD9gICsgdXJsUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICAgIHNjcmlwdEVsZW1lbnQubm9uY2UgPSAoKF9kb2N1bWVudCRxdWVyeVNlbGVjdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3NjcmlwdFtub25jZV0nKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kb2N1bWVudCRxdWVyeVNlbGVjdC5ub25jZSkgfHwgJyc7XG4gICAgICAgIHNjcmlwdEVsZW1lbnQub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLkZBSUxFRDtcbiAgICAgICAgICB0aGlzLm5vdGlmeUxvYWRpbmdTdGF0dXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEkgY291bGQgbm90IGxvYWQuJykpO1xuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuX19nb29nbGVNYXBzQ2FsbGJhY2tfXyA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLkxPQURFRDtcbiAgICAgICAgICB0aGlzLm5vdGlmeUxvYWRpbmdTdGF0dXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5nbV9hdXRoRmFpbHVyZSA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLkFVVEhfRkFJTFVSRTtcbiAgICAgICAgICB0aGlzLm5vdGlmeUxvYWRpbmdTdGF0dXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gQVBJTG9hZGluZ1N0YXR1cy5MT0FESU5HO1xuICAgICAgICB0aGlzLm5vdGlmeUxvYWRpbmdTdGF0dXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmQoc2NyaXB0RWxlbWVudCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhcGlQcm9taXNlO1xuICAgIH07XG4gICAgLy8gZm9yIHRoZSBmaXJzdCBsb2FkLCB3ZSBkZWNsYXJlIGFuIGltcG9ydExpYnJhcnkgZnVuY3Rpb24gdGhhdCB3aWxsXG4gICAgLy8gYmUgb3ZlcndyaXR0ZW4gb25jZSB0aGUgYXBpIGlzIGxvYWRlZC5cbiAgICBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5ID0gbGlicmFyeU5hbWUgPT4gbG9hZEFwaSgpLnRoZW4oKCkgPT4gZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeShsaWJyYXJ5TmFtZSkpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxscyBhbGwgcmVnaXN0ZXJlZCBsb2FkaW5nU3RhdHVzTGlzdGVuZXJzIGFmdGVyIGEgc3RhdHVzIHVwZGF0ZS5cbiAgICovXG4gIHN0YXRpYyBub3RpZnlMb2FkaW5nU3RhdHVzTGlzdGVuZXJzKCkge1xuICAgIGZvciAoY29uc3QgZm4gb2YgdGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgIGZuKHRoaXMubG9hZGluZ1N0YXR1cyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFRoZSBjdXJyZW50IGxvYWRpbmdTdGF0dXMgb2YgdGhlIEFQSS5cbiAqL1xuR29vZ2xlTWFwc0FwaUxvYWRlci5sb2FkaW5nU3RhdHVzID0gQVBJTG9hZGluZ1N0YXR1cy5OT1RfTE9BREVEO1xuLyoqXG4gKiBUaGUgcGFyYW1ldGVycyB1c2VkIGZvciBmaXJzdCBsb2FkaW5nIHRoZSBBUEkuXG4gKi9cbkdvb2dsZU1hcHNBcGlMb2FkZXIuc2VyaWFsaXplZEFwaVBhcmFtcyA9IHZvaWQgMDtcbi8qKlxuICogQSBsaXN0IG9mIGZ1bmN0aW9ucyB0byBiZSBub3RpZmllZCB3aGVuIHRoZSBsb2FkaW5nIHN0YXR1cyBjaGFuZ2VzLlxuICovXG5Hb29nbGVNYXBzQXBpTG9hZGVyLmxpc3RlbmVycyA9IFtdO1xuXG5jb25zdCBfZXhjbHVkZWQkMyA9IFtcIm9uTG9hZFwiLCBcIm9uRXJyb3JcIiwgXCJhcGlLZXlcIiwgXCJ2ZXJzaW9uXCIsIFwibGlicmFyaWVzXCJdLFxuICBfZXhjbHVkZWQyJDEgPSBbXCJjaGlsZHJlblwiXTtcbmNvbnN0IERFRkFVTFRfU09MVVRJT05fQ0hBTk5FTCA9ICdHTVBfdmlzZ2xfcmdtbGlicmFyeV92MV9kZWZhdWx0JztcbmNvbnN0IEFQSVByb3ZpZGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcbiAqIGxvY2FsIGhvb2sgdG8gc2V0IHVwIHRoZSBtYXAtaW5zdGFuY2UgbWFuYWdlbWVudCBjb250ZXh0LlxuICovXG5mdW5jdGlvbiB1c2VNYXBJbnN0YW5jZXMoKSB7XG4gIGNvbnN0IFttYXBJbnN0YW5jZXMsIHNldE1hcEluc3RhbmNlc10gPSB1c2VTdGF0ZSh7fSk7XG4gIGNvbnN0IGFkZE1hcEluc3RhbmNlID0gKG1hcEluc3RhbmNlLCBpZCA9ICdkZWZhdWx0JykgPT4ge1xuICAgIHNldE1hcEluc3RhbmNlcyhpbnN0YW5jZXMgPT4gX2V4dGVuZHMoe30sIGluc3RhbmNlcywge1xuICAgICAgW2lkXTogbWFwSW5zdGFuY2VcbiAgICB9KSk7XG4gIH07XG4gIGNvbnN0IHJlbW92ZU1hcEluc3RhbmNlID0gKGlkID0gJ2RlZmF1bHQnKSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHNldE1hcEluc3RhbmNlcyhfcmVmID0+IHtcbiAgICAgIGxldCByZW1haW5pbmcgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbaWRdLm1hcChfdG9Qcm9wZXJ0eUtleSkpO1xuICAgICAgcmV0dXJuIHJlbWFpbmluZztcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgY2xlYXJNYXBJbnN0YW5jZXMgPSAoKSA9PiB7XG4gICAgc2V0TWFwSW5zdGFuY2VzKHt9KTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBtYXBJbnN0YW5jZXMsXG4gICAgYWRkTWFwSW5zdGFuY2UsXG4gICAgcmVtb3ZlTWFwSW5zdGFuY2UsXG4gICAgY2xlYXJNYXBJbnN0YW5jZXNcbiAgfTtcbn1cbi8qKlxuICogbG9jYWwgaG9vayB0byBoYW5kbGUgdGhlIGxvYWRpbmcgb2YgdGhlIG1hcHMgQVBJLCByZXR1cm5zIHRoZSBjdXJyZW50IGxvYWRpbmcgc3RhdHVzXG4gKiBAcGFyYW0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gdXNlR29vZ2xlTWFwc0FwaUxvYWRlcihwcm9wcykge1xuICBjb25zdCB7XG4gICAgICBvbkxvYWQsXG4gICAgICBvbkVycm9yLFxuICAgICAgYXBpS2V5LFxuICAgICAgdmVyc2lvbixcbiAgICAgIGxpYnJhcmllcyA9IFtdXG4gICAgfSA9IHByb3BzLFxuICAgIG90aGVyQXBpUGFyYW1zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCQzKTtcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IHVzZVN0YXRlKEdvb2dsZU1hcHNBcGlMb2FkZXIubG9hZGluZ1N0YXR1cyk7XG4gIGNvbnN0IFtsb2FkZWRMaWJyYXJpZXMsIGFkZExvYWRlZExpYnJhcnldID0gdXNlUmVkdWNlcigobG9hZGVkTGlicmFyaWVzLCBhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gbG9hZGVkTGlicmFyaWVzW2FjdGlvbi5uYW1lXSA/IGxvYWRlZExpYnJhcmllcyA6IF9leHRlbmRzKHt9LCBsb2FkZWRMaWJyYXJpZXMsIHtcbiAgICAgIFthY3Rpb24ubmFtZV06IGFjdGlvbi52YWx1ZVxuICAgIH0pO1xuICB9LCB7fSk7XG4gIGNvbnN0IGxpYnJhcmllc1N0cmluZyA9IHVzZU1lbW8oKCkgPT4gbGlicmFyaWVzID09IG51bGwgPyB2b2lkIDAgOiBsaWJyYXJpZXMuam9pbignLCcpLCBbbGlicmFyaWVzXSk7XG4gIGNvbnN0IHNlcmlhbGl6ZWRQYXJhbXMgPSB1c2VNZW1vKCgpID0+IEpTT04uc3RyaW5naWZ5KF9leHRlbmRzKHtcbiAgICBhcGlLZXksXG4gICAgdmVyc2lvblxuICB9LCBvdGhlckFwaVBhcmFtcykpLCBbYXBpS2V5LCB2ZXJzaW9uLCBvdGhlckFwaVBhcmFtc10pO1xuICBjb25zdCBpbXBvcnRMaWJyYXJ5ID0gdXNlQ2FsbGJhY2soYXN5bmMgbmFtZSA9PiB7XG4gICAgdmFyIF9nb29nbGU7XG4gICAgaWYgKGxvYWRlZExpYnJhcmllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIGxvYWRlZExpYnJhcmllc1tuYW1lXTtcbiAgICB9XG4gICAgaWYgKCEoKF9nb29nbGUgPSBnb29nbGUpICE9IG51bGwgJiYgKF9nb29nbGUgPSBfZ29vZ2xlLm1hcHMpICE9IG51bGwgJiYgX2dvb2dsZS5pbXBvcnRMaWJyYXJ5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbYXBpLXByb3ZpZGVyLWludGVybmFsXSBpbXBvcnRMaWJyYXJ5IHdhcyBjYWxsZWQgYmVmb3JlICcgKyAnZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeSB3YXMgZGVmaW5lZC4nKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgd2luZG93Lmdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnkobmFtZSk7XG4gICAgYWRkTG9hZGVkTGlicmFyeSh7XG4gICAgICBuYW1lLFxuICAgICAgdmFsdWU6IHJlc1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH0sIFtsb2FkZWRMaWJyYXJpZXNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gX2V4dGVuZHMoe1xuICAgICAgICAgIGtleTogYXBpS2V5XG4gICAgICAgIH0sIG90aGVyQXBpUGFyYW1zKTtcbiAgICAgICAgaWYgKHZlcnNpb24pIHBhcmFtcy52ID0gdmVyc2lvbjtcbiAgICAgICAgaWYgKChsaWJyYXJpZXNTdHJpbmcgPT0gbnVsbCA/IHZvaWQgMCA6IGxpYnJhcmllc1N0cmluZy5sZW5ndGgpID4gMCkgcGFyYW1zLmxpYnJhcmllcyA9IGxpYnJhcmllc1N0cmluZztcbiAgICAgICAgaWYgKHBhcmFtcy5jaGFubmVsID09PSB1bmRlZmluZWQgfHwgcGFyYW1zLmNoYW5uZWwgPCAwIHx8IHBhcmFtcy5jaGFubmVsID4gOTk5KSBkZWxldGUgcGFyYW1zLmNoYW5uZWw7XG4gICAgICAgIGlmIChwYXJhbXMuc29sdXRpb25DaGFubmVsID09PSB1bmRlZmluZWQpIHBhcmFtcy5zb2x1dGlvbkNoYW5uZWwgPSBERUZBVUxUX1NPTFVUSU9OX0NIQU5ORUw7ZWxzZSBpZiAocGFyYW1zLnNvbHV0aW9uQ2hhbm5lbCA9PT0gJycpIGRlbGV0ZSBwYXJhbXMuc29sdXRpb25DaGFubmVsO1xuICAgICAgICBhd2FpdCBHb29nbGVNYXBzQXBpTG9hZGVyLmxvYWQocGFyYW1zLCBzdGF0dXMgPT4gc2V0U3RhdHVzKHN0YXR1cykpO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgWydjb3JlJywgJ21hcHMnLCAuLi5saWJyYXJpZXNdKSB7XG4gICAgICAgICAgYXdhaXQgaW1wb3J0TGlicmFyeShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgb25Mb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignPEFwaVByb3ZpZGVyPiBmYWlsZWQgdG8gbG9hZCB0aGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEknLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSgpO1xuICB9LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFthcGlLZXksIGxpYnJhcmllc1N0cmluZywgc2VyaWFsaXplZFBhcmFtc10pO1xuICByZXR1cm4ge1xuICAgIHN0YXR1cyxcbiAgICBsb2FkZWRMaWJyYXJpZXMsXG4gICAgaW1wb3J0TGlicmFyeVxuICB9O1xufVxuLyoqXG4gKiBDb21wb25lbnQgdG8gd3JhcCB0aGUgY29tcG9uZW50cyBmcm9tIHRoaXMgbGlicmFyeSBhbmQgbG9hZCB0aGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUElcbiAqL1xuY29uc3QgQVBJUHJvdmlkZXIgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IHByb3BzLFxuICAgIGxvYWRlclByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZDIkMSk7XG4gIGNvbnN0IHtcbiAgICBtYXBJbnN0YW5jZXMsXG4gICAgYWRkTWFwSW5zdGFuY2UsXG4gICAgcmVtb3ZlTWFwSW5zdGFuY2UsXG4gICAgY2xlYXJNYXBJbnN0YW5jZXNcbiAgfSA9IHVzZU1hcEluc3RhbmNlcygpO1xuICBjb25zdCB7XG4gICAgc3RhdHVzLFxuICAgIGxvYWRlZExpYnJhcmllcyxcbiAgICBpbXBvcnRMaWJyYXJ5XG4gIH0gPSB1c2VHb29nbGVNYXBzQXBpTG9hZGVyKGxvYWRlclByb3BzKTtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIG1hcEluc3RhbmNlcyxcbiAgICBhZGRNYXBJbnN0YW5jZSxcbiAgICByZW1vdmVNYXBJbnN0YW5jZSxcbiAgICBjbGVhck1hcEluc3RhbmNlcyxcbiAgICBzdGF0dXMsXG4gICAgbG9hZGVkTGlicmFyaWVzLFxuICAgIGltcG9ydExpYnJhcnlcbiAgfSksIFttYXBJbnN0YW5jZXMsIGFkZE1hcEluc3RhbmNlLCByZW1vdmVNYXBJbnN0YW5jZSwgY2xlYXJNYXBJbnN0YW5jZXMsIHN0YXR1cywgbG9hZGVkTGlicmFyaWVzLCBpbXBvcnRMaWJyYXJ5XSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBUElQcm92aWRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFZhbHVlXG4gIH0sIGNoaWxkcmVuKTtcbn07XG5cbi8qKlxuICogU2V0cyB1cCBlZmZlY3RzIHRvIGJpbmQgZXZlbnQtaGFuZGxlcnMgZm9yIGFsbCBldmVudC1wcm9wcyBpbiBNYXBFdmVudFByb3BzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZU1hcEV2ZW50cyhtYXAsIHByb3BzKSB7XG4gIC8vIG5vdGU6IGNhbGxpbmcgYSB1c2VFZmZlY3QgaG9vayBmcm9tIHdpdGhpbiBhIGxvb3AgaXMgcHJvaGliaXRlZCBieSB0aGVcbiAgLy8gcnVsZXMgb2YgaG9va3MsIGJ1dCBpdCdzIG9rIGhlcmUgc2luY2UgaXQncyB1bmNvbmRpdGlvbmFsIGFuZCB0aGUgbnVtYmVyXG4gIC8vIGFuZCBvcmRlciBvZiBpdGVyYXRpb25zIGlzIGFsd2F5cyBzdHJpY3RseSB0aGUgc2FtZS5cbiAgLy8gKHNlZSBodHRwczovL2xlZ2FjeS5yZWFjdGpzLm9yZy9kb2NzL2hvb2tzLXJ1bGVzLmh0bWwpXG4gIGZvciAoY29uc3QgcHJvcE5hbWUgb2YgZXZlbnRQcm9wTmFtZXMpIHtcbiAgICAvLyBmaXhtZTogdGhpcyBjYXN0IGlzIGVzc2VudGlhbGx5IGEgJ3RydXN0IG1lLCBicm8nIGZvciB0eXBlc2NyaXB0LCBidXRcbiAgICAvLyAgIGEgcHJvcGVyIHNvbHV0aW9uIHNlZW1zIHdheSB0b28gY29tcGxpY2F0ZWQgcmlnaHQgbm93XG4gICAgY29uc3QgaGFuZGxlciA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBjb25zdCBldmVudFR5cGUgPSBwcm9wTmFtZVRvRXZlbnRUeXBlW3Byb3BOYW1lXTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKCFtYXApIHJldHVybjtcbiAgICAgIGlmICghaGFuZGxlcikgcmV0dXJuO1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsIGV2ZW50VHlwZSwgZXYgPT4ge1xuICAgICAgICBoYW5kbGVyKGNyZWF0ZU1hcEV2ZW50KGV2ZW50VHlwZSwgbWFwLCBldikpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgfSwgW21hcCwgZXZlbnRUeXBlLCBoYW5kbGVyXSk7XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlIHRoZSB3cmFwcGVkIG1hcC1ldmVudHMgdXNlZCBmb3IgdGhlIGV2ZW50LXByb3BzLlxuICogQHBhcmFtIHR5cGUgdGhlIGV2ZW50IHR5cGUgYXMgaXQgaXMgc3BlY2lmaWVkIHRvIHRoZSBtYXBzIGFwaVxuICogQHBhcmFtIG1hcCB0aGUgbWFwIGluc3RhbmNlIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb21cbiAqIEBwYXJhbSBzcmNFdmVudCB0aGUgc291cmNlLWV2ZW50IGlmIHRoZXJlIGlzIG9uZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWFwRXZlbnQodHlwZSwgbWFwLCBzcmNFdmVudCkge1xuICBjb25zdCBldiA9IHtcbiAgICB0eXBlLFxuICAgIG1hcCxcbiAgICBkZXRhaWw6IHt9LFxuICAgIHN0b3BwYWJsZTogZmFsc2UsXG4gICAgc3RvcDogKCkgPT4ge31cbiAgfTtcbiAgaWYgKGNhbWVyYUV2ZW50VHlwZXMuaW5jbHVkZXModHlwZSkpIHtcbiAgICBjb25zdCBjYW1FdmVudCA9IGV2O1xuICAgIGNvbnN0IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTtcbiAgICBjb25zdCB6b29tID0gbWFwLmdldFpvb20oKTtcbiAgICBjb25zdCBoZWFkaW5nID0gbWFwLmdldEhlYWRpbmcoKSB8fCAwO1xuICAgIGNvbnN0IHRpbHQgPSBtYXAuZ2V0VGlsdCgpIHx8IDA7XG4gICAgY29uc3QgYm91bmRzID0gbWFwLmdldEJvdW5kcygpO1xuICAgIGlmICghY2VudGVyIHx8ICFib3VuZHMgfHwgIU51bWJlci5pc0Zpbml0ZSh6b29tKSkge1xuICAgICAgY29uc29sZS53YXJuKCdbY3JlYXRlRXZlbnRdIGF0IGxlYXN0IG9uZSBvZiB0aGUgdmFsdWVzIGZyb20gdGhlIG1hcCAnICsgJ3JldHVybmVkIHVuZGVmaW5lZC4gVGhpcyBpcyBub3QgZXhwZWN0ZWQgdG8gaGFwcGVuLiBQbGVhc2UgJyArICdyZXBvcnQgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3Zpc2dsL3JlYWN0LWdvb2dsZS1tYXBzL2lzc3Vlcy9uZXcnKTtcbiAgICB9XG4gICAgY2FtRXZlbnQuZGV0YWlsID0ge1xuICAgICAgY2VudGVyOiAoY2VudGVyID09IG51bGwgPyB2b2lkIDAgOiBjZW50ZXIudG9KU09OKCkpIHx8IHtcbiAgICAgICAgbGF0OiAwLFxuICAgICAgICBsbmc6IDBcbiAgICAgIH0sXG4gICAgICB6b29tOiB6b29tIHx8IDAsXG4gICAgICBoZWFkaW5nOiBoZWFkaW5nLFxuICAgICAgdGlsdDogdGlsdCxcbiAgICAgIGJvdW5kczogKGJvdW5kcyA9PSBudWxsID8gdm9pZCAwIDogYm91bmRzLnRvSlNPTigpKSB8fCB7XG4gICAgICAgIG5vcnRoOiA5MCxcbiAgICAgICAgZWFzdDogMTgwLFxuICAgICAgICBzb3V0aDogLTkwLFxuICAgICAgICB3ZXN0OiAtMTgwXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gY2FtRXZlbnQ7XG4gIH0gZWxzZSBpZiAobW91c2VFdmVudFR5cGVzLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgdmFyIF9zcmNFdmVudCRsYXRMbmc7XG4gICAgaWYgKCFzcmNFdmVudCkgdGhyb3cgbmV3IEVycm9yKCdbY3JlYXRlRXZlbnRdIG1vdXNlIGV2ZW50cyBtdXN0IHByb3ZpZGUgYSBzcmNFdmVudCcpO1xuICAgIGNvbnN0IG1vdXNlRXZlbnQgPSBldjtcbiAgICBtb3VzZUV2ZW50LmRvbUV2ZW50ID0gc3JjRXZlbnQuZG9tRXZlbnQ7XG4gICAgbW91c2VFdmVudC5zdG9wcGFibGUgPSB0cnVlO1xuICAgIG1vdXNlRXZlbnQuc3RvcCA9ICgpID0+IHNyY0V2ZW50LnN0b3AoKTtcbiAgICBtb3VzZUV2ZW50LmRldGFpbCA9IHtcbiAgICAgIGxhdExuZzogKChfc3JjRXZlbnQkbGF0TG5nID0gc3JjRXZlbnQubGF0TG5nKSA9PSBudWxsID8gdm9pZCAwIDogX3NyY0V2ZW50JGxhdExuZy50b0pTT04oKSkgfHwgbnVsbCxcbiAgICAgIHBsYWNlSWQ6IHNyY0V2ZW50LnBsYWNlSWRcbiAgICB9O1xuICAgIHJldHVybiBtb3VzZUV2ZW50O1xuICB9XG4gIHJldHVybiBldjtcbn1cbi8qKlxuICogbWFwcyB0aGUgY2FtZWxDYXNlZCBuYW1lcyBvZiBldmVudC1wcm9wcyB0byB0aGUgY29ycmVzcG9uZGluZyBldmVudC10eXBlc1xuICogdXNlZCBpbiB0aGUgbWFwcyBBUEkuXG4gKi9cbmNvbnN0IHByb3BOYW1lVG9FdmVudFR5cGUgPSB7XG4gIG9uQm91bmRzQ2hhbmdlZDogJ2JvdW5kc19jaGFuZ2VkJyxcbiAgb25DZW50ZXJDaGFuZ2VkOiAnY2VudGVyX2NoYW5nZWQnLFxuICBvbkNsaWNrOiAnY2xpY2snLFxuICBvbkNvbnRleHRtZW51OiAnY29udGV4dG1lbnUnLFxuICBvbkRibGNsaWNrOiAnZGJsY2xpY2snLFxuICBvbkRyYWc6ICdkcmFnJyxcbiAgb25EcmFnZW5kOiAnZHJhZ2VuZCcsXG4gIG9uRHJhZ3N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgb25IZWFkaW5nQ2hhbmdlZDogJ2hlYWRpbmdfY2hhbmdlZCcsXG4gIG9uSWRsZTogJ2lkbGUnLFxuICBvbklzRnJhY3Rpb25hbFpvb21FbmFibGVkQ2hhbmdlZDogJ2lzZnJhY3Rpb25hbHpvb21lbmFibGVkX2NoYW5nZWQnLFxuICBvbk1hcENhcGFiaWxpdGllc0NoYW5nZWQ6ICdtYXBjYXBhYmlsaXRpZXNfY2hhbmdlZCcsXG4gIG9uTWFwVHlwZUlkQ2hhbmdlZDogJ21hcHR5cGVpZF9jaGFuZ2VkJyxcbiAgb25Nb3VzZW1vdmU6ICdtb3VzZW1vdmUnLFxuICBvbk1vdXNlb3V0OiAnbW91c2VvdXQnLFxuICBvbk1vdXNlb3ZlcjogJ21vdXNlb3ZlcicsXG4gIG9uUHJvamVjdGlvbkNoYW5nZWQ6ICdwcm9qZWN0aW9uX2NoYW5nZWQnLFxuICBvblJlbmRlcmluZ1R5cGVDaGFuZ2VkOiAncmVuZGVyaW5ndHlwZV9jaGFuZ2VkJyxcbiAgb25UaWxlc0xvYWRlZDogJ3RpbGVzbG9hZGVkJyxcbiAgb25UaWx0Q2hhbmdlZDogJ3RpbHRfY2hhbmdlZCcsXG4gIG9uWm9vbUNoYW5nZWQ6ICd6b29tX2NoYW5nZWQnLFxuICAvLyBub3RlOiBvbkNhbWVyYUNoYW5nZWQgaXMgYW4gYWxpYXMgZm9yIHRoZSBib3VuZHNfY2hhbmdlZCBldmVudCxcbiAgLy8gc2luY2UgdGhhdCBpcyBnb2luZyB0byBiZSBmaXJlZCBpbiBldmVyeSBzaXR1YXRpb24gd2hlcmUgdGhlIGNhbWVyYSBpc1xuICAvLyB1cGRhdGVkLlxuICBvbkNhbWVyYUNoYW5nZWQ6ICdib3VuZHNfY2hhbmdlZCdcbn07XG5jb25zdCBjYW1lcmFFdmVudFR5cGVzID0gWydib3VuZHNfY2hhbmdlZCcsICdjZW50ZXJfY2hhbmdlZCcsICdoZWFkaW5nX2NoYW5nZWQnLCAndGlsdF9jaGFuZ2VkJywgJ3pvb21fY2hhbmdlZCddO1xuY29uc3QgbW91c2VFdmVudFR5cGVzID0gWydjbGljaycsICdjb250ZXh0bWVudScsICdkYmxjbGljaycsICdtb3VzZW1vdmUnLCAnbW91c2VvdXQnLCAnbW91c2VvdmVyJ107XG5jb25zdCBldmVudFByb3BOYW1lcyA9IE9iamVjdC5rZXlzKHByb3BOYW1lVG9FdmVudFR5cGUpO1xuXG5mdW5jdGlvbiB1c2VEZWVwQ29tcGFyZUVmZmVjdChlZmZlY3QsIGRlcHMpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKHVuZGVmaW5lZCk7XG4gIGlmICghcmVmLmN1cnJlbnQgfHwgIWlzRGVlcEVxdWFsKGRlcHMsIHJlZi5jdXJyZW50KSkge1xuICAgIHJlZi5jdXJyZW50ID0gZGVwcztcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIHVzZUVmZmVjdChlZmZlY3QsIHJlZi5jdXJyZW50KTtcbn1cblxuY29uc3QgbWFwT3B0aW9uS2V5cyA9IG5ldyBTZXQoWydiYWNrZ3JvdW5kQ29sb3InLCAnY2xpY2thYmxlSWNvbnMnLCAnY29udHJvbFNpemUnLCAnZGlzYWJsZURlZmF1bHRVSScsICdkaXNhYmxlRG91YmxlQ2xpY2tab29tJywgJ2RyYWdnYWJsZScsICdkcmFnZ2FibGVDdXJzb3InLCAnZHJhZ2dpbmdDdXJzb3InLCAnZnVsbHNjcmVlbkNvbnRyb2wnLCAnZnVsbHNjcmVlbkNvbnRyb2xPcHRpb25zJywgJ2dlc3R1cmVIYW5kbGluZycsICdoZWFkaW5nSW50ZXJhY3Rpb25FbmFibGVkJywgJ2lzRnJhY3Rpb25hbFpvb21FbmFibGVkJywgJ2tleWJvYXJkU2hvcnRjdXRzJywgJ21hcFR5cGVDb250cm9sJywgJ21hcFR5cGVDb250cm9sT3B0aW9ucycsICdtYXBUeXBlSWQnLCAnbWF4Wm9vbScsICdtaW5ab29tJywgJ25vQ2xlYXInLCAncGFuQ29udHJvbCcsICdwYW5Db250cm9sT3B0aW9ucycsICdyZXN0cmljdGlvbicsICdyb3RhdGVDb250cm9sJywgJ3JvdGF0ZUNvbnRyb2xPcHRpb25zJywgJ3NjYWxlQ29udHJvbCcsICdzY2FsZUNvbnRyb2xPcHRpb25zJywgJ3Njcm9sbHdoZWVsJywgJ3N0cmVldFZpZXcnLCAnc3RyZWV0Vmlld0NvbnRyb2wnLCAnc3RyZWV0Vmlld0NvbnRyb2xPcHRpb25zJywgJ3N0eWxlcycsICd0aWx0SW50ZXJhY3Rpb25FbmFibGVkJywgJ3pvb21Db250cm9sJywgJ3pvb21Db250cm9sT3B0aW9ucyddKTtcbi8qKlxuICogSW50ZXJuYWwgaG9vayB0byB1cGRhdGUgdGhlIG1hcC1vcHRpb25zIHdoZW4gcHJvcHMgYXJlIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIG1hcCB0aGUgbWFwIGluc3RhbmNlXG4gKiBAcGFyYW0gbWFwUHJvcHMgdGhlIHByb3BzIHRvIHVwZGF0ZSB0aGUgbWFwLWluc3RhbmNlIHdpdGhcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VNYXBPcHRpb25zKG1hcCwgbWFwUHJvcHMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzIC0tXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZWZmZWN0cyBhcmVuJ3QgdHJpZ2dlcmVkIHdoZW4gdGhlIG1hcCBpcyBjaGFuZ2VkLlxuICAgKiBJbiB0aGF0IGNhc2UsIHRoZSB2YWx1ZXMgd2lsbCBiZSBvciBoYXZlIGJlZW4gcGFzc2VkIHRvIHRoZSBtYXBcbiAgICogY29uc3RydWN0b3IgdmlhIG1hcE9wdGlvbnMuXG4gICAqL1xuICBjb25zdCBtYXBPcHRpb25zID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhtYXBQcm9wcyk7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBpZiAoIW1hcE9wdGlvbktleXMuaGFzKGtleSkpIGNvbnRpbnVlO1xuICAgIG1hcE9wdGlvbnNba2V5XSA9IG1hcFByb3BzW2tleV07XG4gIH1cbiAgLy8gdXBkYXRlIHRoZSBtYXAgb3B0aW9ucyB3aGVuIG1hcE9wdGlvbnMgaXMgY2hhbmdlZFxuICAvLyBOb3RlOiBkdWUgdG8gdGhlIGRlc3RydWN0dXJpbmcgYWJvdmUsIG1hcE9wdGlvbnMgd2lsbCBiZSBzZWVuIGFzIGNoYW5nZWRcbiAgLy8gICB3aXRoIGV2ZXJ5IHJlLXJlbmRlciwgc28gd2UncmUgYXNzdW1pbmcgdGhlIG1hcHMtYXBpIHdpbGwgcHJvcGVybHlcbiAgLy8gICBkZWFsIHdpdGggdW5jaGFuZ2VkIG9wdGlvbi12YWx1ZXMgcGFzc2VkIGludG8gc2V0T3B0aW9ucy5cbiAgdXNlRGVlcENvbXBhcmVFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFwKSByZXR1cm47XG4gICAgbWFwLnNldE9wdGlvbnMobWFwT3B0aW9ucyk7XG4gIH0sIFttYXBPcHRpb25zXSk7XG4gIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzICovXG59XG5cbmZ1bmN0aW9uIHVzZUFwaUxvYWRpbmdTdGF0dXMoKSB7XG4gIHZhciBfdXNlQ29udGV4dDtcbiAgcmV0dXJuICgoX3VzZUNvbnRleHQgPSB1c2VDb250ZXh0KEFQSVByb3ZpZGVyQ29udGV4dCkpID09IG51bGwgPyB2b2lkIDAgOiBfdXNlQ29udGV4dC5zdGF0dXMpIHx8IEFQSUxvYWRpbmdTdGF0dXMuTk9UX0xPQURFRDtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBob29rIHRoYXQgdXBkYXRlcyB0aGUgY2FtZXJhIHdoZW4gZGVjay5nbCB2aWV3U3RhdGUgY2hhbmdlcy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VEZWNrR0xDYW1lcmFVcGRhdGUobWFwLCBwcm9wcykge1xuICBjb25zdCB7XG4gICAgdmlld3BvcnQsXG4gICAgdmlld1N0YXRlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgaXNEZWNrR2xDb250cm9sbGVkID0gISF2aWV3cG9ydDtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1hcCB8fCAhdmlld1N0YXRlKSByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgbGF0aXR1ZGUsXG4gICAgICBsb25naXR1ZGUsXG4gICAgICBiZWFyaW5nOiBoZWFkaW5nLFxuICAgICAgcGl0Y2g6IHRpbHQsXG4gICAgICB6b29tXG4gICAgfSA9IHZpZXdTdGF0ZTtcbiAgICBtYXAubW92ZUNhbWVyYSh7XG4gICAgICBjZW50ZXI6IHtcbiAgICAgICAgbGF0OiBsYXRpdHVkZSxcbiAgICAgICAgbG5nOiBsb25naXR1ZGVcbiAgICAgIH0sXG4gICAgICBoZWFkaW5nLFxuICAgICAgdGlsdCxcbiAgICAgIHpvb206IHpvb20gKyAxXG4gICAgfSk7XG4gIH0sIFttYXAsIHZpZXdTdGF0ZV0pO1xuICByZXR1cm4gaXNEZWNrR2xDb250cm9sbGVkO1xufVxuXG5mdW5jdGlvbiBpc0xhdExuZ0xpdGVyYWwob2JqKSB7XG4gIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gIGlmICghKCdsYXQnIGluIG9iaiAmJiAnbG5nJyBpbiBvYmopKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUob2JqLmxhdCkgJiYgTnVtYmVyLmlzRmluaXRlKG9iai5sbmcpO1xufVxuZnVuY3Rpb24gbGF0TG5nRXF1YWxzKGEsIGIpIHtcbiAgaWYgKCFhIHx8ICFiKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IEEgPSB0b0xhdExuZ0xpdGVyYWwoYSk7XG4gIGNvbnN0IEIgPSB0b0xhdExuZ0xpdGVyYWwoYik7XG4gIGlmIChBLmxhdCAhPT0gQi5sYXQgfHwgQS5sbmcgIT09IEIubG5nKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdG9MYXRMbmdMaXRlcmFsKG9iaikge1xuICBpZiAoaXNMYXRMbmdMaXRlcmFsKG9iaikpIHJldHVybiBvYmo7XG4gIHJldHVybiBvYmoudG9KU09OKCk7XG59XG5cbmZ1bmN0aW9uIHVzZU1hcENhbWVyYVBhcmFtcyhtYXAsIGNhbWVyYVN0YXRlUmVmLCBtYXBQcm9wcykge1xuICBjb25zdCBjZW50ZXIgPSBtYXBQcm9wcy5jZW50ZXIgPyB0b0xhdExuZ0xpdGVyYWwobWFwUHJvcHMuY2VudGVyKSA6IG51bGw7XG4gIGxldCBsYXQgPSBudWxsO1xuICBsZXQgbG5nID0gbnVsbDtcbiAgaWYgKGNlbnRlciAmJiBOdW1iZXIuaXNGaW5pdGUoY2VudGVyLmxhdCkgJiYgTnVtYmVyLmlzRmluaXRlKGNlbnRlci5sbmcpKSB7XG4gICAgbGF0ID0gY2VudGVyLmxhdDtcbiAgICBsbmcgPSBjZW50ZXIubG5nO1xuICB9XG4gIGNvbnN0IHpvb20gPSBOdW1iZXIuaXNGaW5pdGUobWFwUHJvcHMuem9vbSkgPyBtYXBQcm9wcy56b29tIDogbnVsbDtcbiAgY29uc3QgaGVhZGluZyA9IE51bWJlci5pc0Zpbml0ZShtYXBQcm9wcy5oZWFkaW5nKSA/IG1hcFByb3BzLmhlYWRpbmcgOiBudWxsO1xuICBjb25zdCB0aWx0ID0gTnVtYmVyLmlzRmluaXRlKG1hcFByb3BzLnRpbHQpID8gbWFwUHJvcHMudGlsdCA6IG51bGw7XG4gIC8vIHRoZSBmb2xsb3dpbmcgZWZmZWN0IHJ1bnMgZm9yIGV2ZXJ5IHJlbmRlciBvZiB0aGUgbWFwIGNvbXBvbmVudCBhbmQgY2hlY2tzXG4gIC8vIGlmIHRoZXJlIGFyZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSBrbm93biBzdGF0ZSBvZiB0aGUgbWFwIGluc3RhbmNlXG4gIC8vIChjYW1lcmFTdGF0ZVJlZiwgd2hpY2ggaXMgdXBkYXRlZCBieSBhbGwgYm91bmRzX2NoYW5nZWQgZXZlbnRzKSBhbmQgdGhlXG4gIC8vIGRlc2lyZWQgc3RhdGUgaW4gdGhlIHByb3BzLlxuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFwKSByZXR1cm47XG4gICAgY29uc3QgbmV4dENhbWVyYSA9IHt9O1xuICAgIGxldCBuZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgIGlmIChsYXQgIT09IG51bGwgJiYgbG5nICE9PSBudWxsICYmIChjYW1lcmFTdGF0ZVJlZi5jdXJyZW50LmNlbnRlci5sYXQgIT09IGxhdCB8fCBjYW1lcmFTdGF0ZVJlZi5jdXJyZW50LmNlbnRlci5sbmcgIT09IGxuZykpIHtcbiAgICAgIG5leHRDYW1lcmEuY2VudGVyID0ge1xuICAgICAgICBsYXQsXG4gICAgICAgIGxuZ1xuICAgICAgfTtcbiAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHpvb20gIT09IG51bGwgJiYgY2FtZXJhU3RhdGVSZWYuY3VycmVudC56b29tICE9PSB6b29tKSB7XG4gICAgICBuZXh0Q2FtZXJhLnpvb20gPSB6b29tO1xuICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaGVhZGluZyAhPT0gbnVsbCAmJiBjYW1lcmFTdGF0ZVJlZi5jdXJyZW50LmhlYWRpbmcgIT09IGhlYWRpbmcpIHtcbiAgICAgIG5leHRDYW1lcmEuaGVhZGluZyA9IGhlYWRpbmc7XG4gICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aWx0ICE9PSBudWxsICYmIGNhbWVyYVN0YXRlUmVmLmN1cnJlbnQudGlsdCAhPT0gdGlsdCkge1xuICAgICAgbmV4dENhbWVyYS50aWx0ID0gdGlsdDtcbiAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5lZWRzVXBkYXRlKSB7XG4gICAgICBtYXAubW92ZUNhbWVyYShuZXh0Q2FtZXJhKTtcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCBBdXRoRmFpbHVyZU1lc3NhZ2UgPSAoKSA9PiB7XG4gIGNvbnN0IHN0eWxlID0ge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICByaWdodDogMCxcbiAgICB6SW5kZXg6IDk5OSxcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgZmxleEZsb3c6ICdjb2x1bW4gbm93cmFwJyxcbiAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICBmb250U2l6ZTogJy44cmVtJyxcbiAgICBjb2xvcjogJ3JnYmEoMCwwLDAsMC42KScsXG4gICAgYmFja2dyb3VuZDogJyNkZGRkZGQnLFxuICAgIHBhZGRpbmc6ICcxcmVtIDEuNXJlbSdcbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBzdHlsZTogc3R5bGVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoMlwiLCBudWxsLCBcIkVycm9yOiBBdXRoRmFpbHVyZVwiKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIG51bGwsIFwiQSBwcm9ibGVtIHdpdGggeW91ciBBUEkga2V5IHByZXZlbnRzIHRoZSBtYXAgZnJvbSByZW5kZXJpbmcgY29ycmVjdGx5LiBQbGVhc2UgbWFrZSBzdXJlIHRoZSB2YWx1ZSBvZiB0aGUgXCIsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCBudWxsLCBcIkFQSVByb3ZpZGVyLmFwaUtleVwiKSwgXCIgcHJvcCBpcyBjb3JyZWN0LiBDaGVjayB0aGUgZXJyb3ItbWVzc2FnZSBpbiB0aGUgY29uc29sZSBmb3IgZnVydGhlciBkZXRhaWxzLlwiKSk7XG59O1xuXG5mdW5jdGlvbiB1c2VDYWxsYmFja1JlZigpIHtcbiAgY29uc3QgW2VsLCBzZXRFbF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgcmVmID0gdXNlQ2FsbGJhY2sodmFsdWUgPT4gc2V0RWwodmFsdWUpLCBbc2V0RWxdKTtcbiAgcmV0dXJuIFtlbCwgcmVmXTtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGNoZWNrIGlmIHRoZSBNYXBzIEphdmFTY3JpcHQgQVBJIGlzIGxvYWRlZFxuICovXG5mdW5jdGlvbiB1c2VBcGlJc0xvYWRlZCgpIHtcbiAgY29uc3Qgc3RhdHVzID0gdXNlQXBpTG9hZGluZ1N0YXR1cygpO1xuICByZXR1cm4gc3RhdHVzID09PSBBUElMb2FkaW5nU3RhdHVzLkxPQURFRDtcbn1cblxuZnVuY3Rpb24gdXNlRm9yY2VVcGRhdGUoKSB7XG4gIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IHVzZVJlZHVjZXIoeCA9PiB4ICsgMSwgMCk7XG4gIHJldHVybiBmb3JjZVVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQm91bmRzQ2hhbmdlKG1hcCwgcmVmKSB7XG4gIGNvbnN0IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTtcbiAgY29uc3Qgem9vbSA9IG1hcC5nZXRab29tKCk7XG4gIGNvbnN0IGhlYWRpbmcgPSBtYXAuZ2V0SGVhZGluZygpIHx8IDA7XG4gIGNvbnN0IHRpbHQgPSBtYXAuZ2V0VGlsdCgpIHx8IDA7XG4gIGNvbnN0IGJvdW5kcyA9IG1hcC5nZXRCb3VuZHMoKTtcbiAgaWYgKCFjZW50ZXIgfHwgIWJvdW5kcyB8fCAhTnVtYmVyLmlzRmluaXRlKHpvb20pKSB7XG4gICAgY29uc29sZS53YXJuKCdbdXNlVHJhY2tlZENhbWVyYVN0YXRlXSBhdCBsZWFzdCBvbmUgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBtYXAgJyArICdyZXR1cm5lZCB1bmRlZmluZWQuIFRoaXMgaXMgbm90IGV4cGVjdGVkIHRvIGhhcHBlbi4gUGxlYXNlICcgKyAncmVwb3J0IGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS92aXNnbC9yZWFjdC1nb29nbGUtbWFwcy9pc3N1ZXMvbmV3Jyk7XG4gIH1cbiAgLy8gZml4bWU6IGRvIHdlIG5lZWQgdGhlIGB1bmRlZmluZWRgIGNhc2VzIGZvciB0aGUgY2FtZXJhLXBhcmFtcz8gV2hlbiBhcmUgdGhleSB1c2VkIGluIHRoZSBtYXBzIEFQST9cbiAgT2JqZWN0LmFzc2lnbihyZWYuY3VycmVudCwge1xuICAgIGNlbnRlcjogKGNlbnRlciA9PSBudWxsID8gdm9pZCAwIDogY2VudGVyLnRvSlNPTigpKSB8fCB7XG4gICAgICBsYXQ6IDAsXG4gICAgICBsbmc6IDBcbiAgICB9LFxuICAgIHpvb206IHpvb20gfHwgMCxcbiAgICBoZWFkaW5nOiBoZWFkaW5nLFxuICAgIHRpbHQ6IHRpbHRcbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtdXRhYmxlIHJlZiBvYmplY3QgdG8gdHJhY2sgdGhlIGxhc3Qga25vd24gc3RhdGUgb2YgdGhlIG1hcCBjYW1lcmEuXG4gKiBUaGlzIGlzIHVzZWQgaW4gYHVzZU1hcENhbWVyYVBhcmFtc2AgdG8gcmVkdWNlIHN0dXR0ZXJpbmcgaW4gbm9ybWFsIG9wZXJhdGlvblxuICogYnkgYXZvaWRpbmcgdXBkYXRlcyBvZiB0aGUgbWFwIGNhbWVyYSB3aXRoIHZhbHVlcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZC5cbiAqL1xuZnVuY3Rpb24gdXNlVHJhY2tlZENhbWVyYVN0YXRlUmVmKG1hcCkge1xuICBjb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKCk7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZih7XG4gICAgY2VudGVyOiB7XG4gICAgICBsYXQ6IDAsXG4gICAgICBsbmc6IDBcbiAgICB9LFxuICAgIGhlYWRpbmc6IDAsXG4gICAgdGlsdDogMCxcbiAgICB6b29tOiAwXG4gIH0pO1xuICAvLyBSZWNvcmQgY2FtZXJhIHN0YXRlIHdpdGggZXZlcnkgYm91bmRzX2NoYW5nZWQgZXZlbnQgZGlzcGF0Y2hlZCBieSB0aGUgbWFwLlxuICAvLyBUaGlzIGRhdGEgaXMgdXNlZCB0byBwcmV2ZW50IGZlZWRpbmcgdGhlc2UgdmFsdWVzIGJhY2sgdG8gdGhlXG4gIC8vIG1hcC1pbnN0YW5jZSB3aGVuIGEgdHlwaWNhbCBcImNvbnRyb2xsZWQgY29tcG9uZW50XCIgc2V0dXAgKHN0YXRlIHZhcmlhYmxlIGlzXG4gIC8vIGZlZCBpbnRvIGFuZCB1cGRhdGVkIGJ5IHRoZSBtYXApLlxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFwKSByZXR1cm47XG4gICAgY29uc3QgbGlzdGVuZXIgPSBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICdib3VuZHNfY2hhbmdlZCcsICgpID0+IHtcbiAgICAgIGhhbmRsZUJvdW5kc0NoYW5nZShtYXAsIHJlZik7XG4gICAgICAvLyBXaGVuIGFuIGV2ZW50IGlzIG9jY3VyZWQsIHdlIGhhdmUgdG8gdXBkYXRlIGR1cmluZyB0aGUgbmV4dCBjeWNsZS5cbiAgICAgIC8vIFRoZSBhcHBsaWNhdGlvbiBjb3VsZCBkZWNpZGUgdG8gaWdub3JlIHRoZSBldmVudCBhbmQgbm90IHVwZGF0ZSBhbnlcbiAgICAgIC8vIGNhbWVyYSBwcm9wcyBvZiB0aGUgbWFwLCBtZWFuaW5nIHRoYXQgaW4gdGhhdCBjYXNlIHdlIHdpbGwgaGF2ZSB0b1xuICAgICAgLy8gJ3VuZG8nIHRoZSBjaGFuZ2UgdG8gdGhlIGNhbWVyYS5cbiAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IGxpc3RlbmVyLnJlbW92ZSgpO1xuICB9LCBbbWFwLCBmb3JjZVVwZGF0ZV0pO1xuICByZXR1cm4gcmVmO1xufVxuXG5jb25zdCBfZXhjbHVkZWQkMiA9IFtcImlkXCIsIFwiZGVmYXVsdEJvdW5kc1wiLCBcImRlZmF1bHRDZW50ZXJcIiwgXCJkZWZhdWx0Wm9vbVwiLCBcImRlZmF1bHRIZWFkaW5nXCIsIFwiZGVmYXVsdFRpbHRcIiwgXCJyZXVzZU1hcHNcIiwgXCJyZW5kZXJpbmdUeXBlXCIsIFwiY29sb3JTY2hlbWVcIl0sXG4gIF9leGNsdWRlZDIgPSBbXCJwYWRkaW5nXCJdO1xuLyoqXG4gKiBTdG9yZXMgYSBzdGFjayBvZiBtYXAtaW5zdGFuY2VzIGZvciBlYWNoIG1hcElkLiBXaGVuZXZlciBhblxuICogaW5zdGFuY2UgaXMgdXNlZCwgaXQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBzdGFjayB3aGlsZSBpbiB1c2UsXG4gKiBhbmQgcmV0dXJuZWQgdG8gdGhlIHN0YWNrIHdoZW4gdGhlIGNvbXBvbmVudCB1bm1vdW50cy5cbiAqIFRoaXMgYWxsb3dzIHVzIHRvIGNvcnJlY3RseSBpbXBsZW1lbnQgY2FjaGluZyBmb3IgbXVsdGlwbGVcbiAqIG1hcHMgb20gdGhlIHNhbWUgcGFnZSwgd2hpbGUgcmV1c2luZyBhcyBtdWNoIGFzIHBvc3NpYmxlLlxuICpcbiAqIEZJWE1FOiB3aGlsZSBpdCBzaG91bGQgaW4gdGhlb3J5IGJlIHBvc3NpYmxlIHRvIHJldXNlIG1hcHMgc29sZWx5XG4gKiAgIGJhc2VkIG9uIHRoZSBtYXBJZCAoYXMgYWxsIG90aGVyIHBhcmFtZXRlcnMgY2FuIGJlIGNoYW5nZWQgYXRcbiAqICAgcnVudGltZSksIHdlIGRvbid0IHlldCBoYXZlIGdvb2QgZW5vdWdoIHRyYWNraW5nIG9mIG9wdGlvbnMgdG9cbiAqICAgcmVsaWFibHkgdW5zZXQgYWxsIHRoZSBvcHRpb25zIHRoYXQgaGF2ZSBiZWVuIHNldC5cbiAqL1xuY2xhc3MgQ2FjaGVkTWFwU3RhY2sge1xuICBzdGF0aWMgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXNba2V5XSAmJiB0aGlzLmVudHJpZXNba2V5XS5sZW5ndGggPiAwO1xuICB9XG4gIHN0YXRpYyBwb3Aoa2V5KSB7XG4gICAgaWYgKCF0aGlzLmVudHJpZXNba2V5XSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllc1trZXldLnBvcCgpIHx8IG51bGw7XG4gIH1cbiAgc3RhdGljIHB1c2goa2V5LCB2YWx1ZSkge1xuICAgIGlmICghdGhpcy5lbnRyaWVzW2tleV0pIHRoaXMuZW50cmllc1trZXldID0gW107XG4gICAgdGhpcy5lbnRyaWVzW2tleV0ucHVzaCh2YWx1ZSk7XG4gIH1cbn1cbi8qKlxuICogVGhlIG1haW4gaG9vayB0YWtlcyBjYXJlIG9mIGNyZWF0aW5nIG1hcC1pbnN0YW5jZXMgYW5kIHJlZ2lzdGVyaW5nIHRoZW0gaW5cbiAqIHRoZSBhcGktcHJvdmlkZXIgY29udGV4dC5cbiAqIEByZXR1cm4gYSB0dXBsZSBvZiB0aGUgbWFwLWluc3RhbmNlIGNyZWF0ZWQgKG9yIG51bGwpIGFuZCB0aGUgY2FsbGJhY2tcbiAqICAgcmVmIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHBhc3MgdGhlIG1hcC1jb250YWluZXIgaW50byB0aGlzIGhvb2suXG4gKiBAaW50ZXJuYWxcbiAqL1xuQ2FjaGVkTWFwU3RhY2suZW50cmllcyA9IHt9O1xuZnVuY3Rpb24gdXNlTWFwSW5zdGFuY2UocHJvcHMsIGNvbnRleHQpIHtcbiAgY29uc3QgYXBpSXNMb2FkZWQgPSB1c2VBcGlJc0xvYWRlZCgpO1xuICBjb25zdCBbbWFwLCBzZXRNYXBdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtjb250YWluZXIsIGNvbnRhaW5lclJlZl0gPSB1c2VDYWxsYmFja1JlZigpO1xuICBjb25zdCBjYW1lcmFTdGF0ZVJlZiA9IHVzZVRyYWNrZWRDYW1lcmFTdGF0ZVJlZihtYXApO1xuICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGRlZmF1bHRCb3VuZHMsXG4gICAgICBkZWZhdWx0Q2VudGVyLFxuICAgICAgZGVmYXVsdFpvb20sXG4gICAgICBkZWZhdWx0SGVhZGluZyxcbiAgICAgIGRlZmF1bHRUaWx0LFxuICAgICAgcmV1c2VNYXBzLFxuICAgICAgcmVuZGVyaW5nVHlwZSxcbiAgICAgIGNvbG9yU2NoZW1lXG4gICAgfSA9IHByb3BzLFxuICAgIG1hcE9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJDIpO1xuICBjb25zdCBoYXNab29tID0gcHJvcHMuem9vbSAhPT0gdW5kZWZpbmVkIHx8IHByb3BzLmRlZmF1bHRab29tICE9PSB1bmRlZmluZWQ7XG4gIGNvbnN0IGhhc0NlbnRlciA9IHByb3BzLmNlbnRlciAhPT0gdW5kZWZpbmVkIHx8IHByb3BzLmRlZmF1bHRDZW50ZXIgIT09IHVuZGVmaW5lZDtcbiAgaWYgKCFkZWZhdWx0Qm91bmRzICYmICghaGFzWm9vbSB8fCAhaGFzQ2VudGVyKSkge1xuICAgIGNvbnNvbGUud2FybignPE1hcD4gY29tcG9uZW50IGlzIG1pc3NpbmcgY29uZmlndXJhdGlvbi4gJyArICdZb3UgaGF2ZSB0byBwcm92aWRlIHpvb20gYW5kIGNlbnRlciAodmlhIHRoZSBgem9vbWAvYGRlZmF1bHRab29tYCBhbmQgJyArICdgY2VudGVyYC9gZGVmYXVsdENlbnRlcmAgcHJvcHMpIG9yIHNwZWNpZnkgdGhlIHJlZ2lvbiB0byBzaG93IHVzaW5nICcgKyAnYGRlZmF1bHRCb3VuZHNgLiBTZWUgJyArICdodHRwczovL3Zpc2dsLmdpdGh1Yi5pby9yZWFjdC1nb29nbGUtbWFwcy9kb2NzL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9tYXAjcmVxdWlyZWQnKTtcbiAgfVxuICAvLyBhcHBseSBkZWZhdWx0IGNhbWVyYSBwcm9wcyBpZiBhdmFpbGFibGUgYW5kIG5vdCBvdmVyd3JpdHRlbiBieSBjb250cm9sbGVkIHByb3BzXG4gIGlmICghbWFwT3B0aW9ucy5jZW50ZXIgJiYgZGVmYXVsdENlbnRlcikgbWFwT3B0aW9ucy5jZW50ZXIgPSBkZWZhdWx0Q2VudGVyO1xuICBpZiAoIW1hcE9wdGlvbnMuem9vbSAmJiBOdW1iZXIuaXNGaW5pdGUoZGVmYXVsdFpvb20pKSBtYXBPcHRpb25zLnpvb20gPSBkZWZhdWx0Wm9vbTtcbiAgaWYgKCFtYXBPcHRpb25zLmhlYWRpbmcgJiYgTnVtYmVyLmlzRmluaXRlKGRlZmF1bHRIZWFkaW5nKSkgbWFwT3B0aW9ucy5oZWFkaW5nID0gZGVmYXVsdEhlYWRpbmc7XG4gIGlmICghbWFwT3B0aW9ucy50aWx0ICYmIE51bWJlci5pc0Zpbml0ZShkZWZhdWx0VGlsdCkpIG1hcE9wdGlvbnMudGlsdCA9IGRlZmF1bHRUaWx0O1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtYXBPcHRpb25zKSkgaWYgKG1hcE9wdGlvbnNba2V5XSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgbWFwT3B0aW9uc1trZXldO1xuICBjb25zdCBzYXZlZE1hcFN0YXRlUmVmID0gdXNlUmVmKHVuZGVmaW5lZCk7XG4gIC8vIGNyZWF0ZSB0aGUgbWFwIGluc3RhbmNlIGFuZCByZWdpc3RlciBpdCBpbiB0aGUgY29udGV4dFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY29udGFpbmVyIHx8ICFhcGlJc0xvYWRlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGFkZE1hcEluc3RhbmNlLFxuICAgICAgcmVtb3ZlTWFwSW5zdGFuY2VcbiAgICB9ID0gY29udGV4dDtcbiAgICAvLyBub3RlOiBjb2xvclNjaGVtZSAodXBjb21pbmcgZmVhdHVyZSkgaXNuJ3QgeWV0IGluIHRoZSB0eXBpbmdzLCByZW1vdmUgb25jZSB0aGF0IGlzIGZpeGVkOlxuICAgIGNvbnN0IHtcbiAgICAgIG1hcElkXG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7bWFwSWQgfHwgJ2RlZmF1bHQnfToke3JlbmRlcmluZ1R5cGUgfHwgJ2RlZmF1bHQnfToke2NvbG9yU2NoZW1lIHx8ICdMSUdIVCd9YDtcbiAgICBsZXQgbWFwRGl2O1xuICAgIGxldCBtYXA7XG4gICAgaWYgKHJldXNlTWFwcyAmJiBDYWNoZWRNYXBTdGFjay5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICBtYXAgPSBDYWNoZWRNYXBTdGFjay5wb3AoY2FjaGVLZXkpO1xuICAgICAgbWFwRGl2ID0gbWFwLmdldERpdigpO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG1hcERpdik7XG4gICAgICBtYXAuc2V0T3B0aW9ucyhtYXBPcHRpb25zKTtcbiAgICAgIC8vIGRldGFjaGluZyB0aGUgZWxlbWVudCBmcm9tIHRoZSBET00gbGV0cyB0aGUgbWFwIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdFxuICAgICAgLy8gc2l6ZSwgc2V0dGluZyB0aGUgY2VudGVyIHdpbGwgdHJpZ2dlciByZWxvYWRpbmcgdGhlIG1hcC5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gbWFwLnNldENlbnRlcihtYXAuZ2V0Q2VudGVyKCkpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFwRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBtYXBEaXYuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG1hcERpdik7XG4gICAgICBtYXAgPSBuZXcgZ29vZ2xlLm1hcHMuTWFwKG1hcERpdiwgX2V4dGVuZHMoe30sIG1hcE9wdGlvbnMsIHJlbmRlcmluZ1R5cGUgPyB7XG4gICAgICAgIHJlbmRlcmluZ1R5cGU6IHJlbmRlcmluZ1R5cGVcbiAgICAgIH0gOiB7fSwgY29sb3JTY2hlbWUgPyB7XG4gICAgICAgIGNvbG9yU2NoZW1lOiBjb2xvclNjaGVtZVxuICAgICAgfSA6IHt9KSk7XG4gICAgfVxuICAgIHNldE1hcChtYXApO1xuICAgIGFkZE1hcEluc3RhbmNlKG1hcCwgaWQpO1xuICAgIGlmIChkZWZhdWx0Qm91bmRzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgICAgcGFkZGluZ1xuICAgICAgICB9ID0gZGVmYXVsdEJvdW5kcyxcbiAgICAgICAgZGVmQm91bmRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoZGVmYXVsdEJvdW5kcywgX2V4Y2x1ZGVkMik7XG4gICAgICBtYXAuZml0Qm91bmRzKGRlZkJvdW5kcywgcGFkZGluZyk7XG4gICAgfVxuICAgIC8vIHByZXZlbnQgbWFwIG5vdCByZW5kZXJpbmcgZHVlIHRvIG1pc3NpbmcgY29uZmlndXJhdGlvblxuICAgIGVsc2UgaWYgKCFoYXNab29tIHx8ICFoYXNDZW50ZXIpIHtcbiAgICAgIG1hcC5maXRCb3VuZHMoe1xuICAgICAgICBlYXN0OiAxODAsXG4gICAgICAgIHdlc3Q6IC0xODAsXG4gICAgICAgIHNvdXRoOiAtOTAsXG4gICAgICAgIG5vcnRoOiA5MFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHRoZSBzYXZlZE1hcFN0YXRlIGlzIHVzZWQgdG8gcmVzdG9yZSB0aGUgY2FtZXJhIHBhcmFtZXRlcnMgd2hlbiB0aGUgbWFwSWQgaXMgY2hhbmdlZFxuICAgIGlmIChzYXZlZE1hcFN0YXRlUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFwSWQ6IHNhdmVkTWFwSWQsXG4gICAgICAgIGNhbWVyYVN0YXRlOiBzYXZlZENhbWVyYVN0YXRlXG4gICAgICB9ID0gc2F2ZWRNYXBTdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgaWYgKHNhdmVkTWFwSWQgIT09IG1hcElkKSB7XG4gICAgICAgIG1hcC5zZXRPcHRpb25zKHNhdmVkQ2FtZXJhU3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2F2ZWRNYXBTdGF0ZVJlZi5jdXJyZW50ID0ge1xuICAgICAgICBtYXBJZCxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICBjYW1lcmFTdGF0ZTogY2FtZXJhU3RhdGVSZWYuY3VycmVudFxuICAgICAgfTtcbiAgICAgIC8vIGRldGFjaCB0aGUgbWFwLWRpdiBmcm9tIHRoZSBkb21cbiAgICAgIG1hcERpdi5yZW1vdmUoKTtcbiAgICAgIGlmIChyZXVzZU1hcHMpIHtcbiAgICAgICAgLy8gcHVzaCBiYWNrIG9uIHRoZSBzdGFja1xuICAgICAgICBDYWNoZWRNYXBTdGFjay5wdXNoKGNhY2hlS2V5LCBtYXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBldmVudC1saXN0ZW5lcnMgdG8gbWluaW1pemUgdGhlIHBvc3NpYmlsaXR5IG9mIG1lbW9yeS1sZWFrc1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5jbGVhckluc3RhbmNlTGlzdGVuZXJzKG1hcCk7XG4gICAgICB9XG4gICAgICBzZXRNYXAobnVsbCk7XG4gICAgICByZW1vdmVNYXBJbnN0YW5jZShpZCk7XG4gICAgfTtcbiAgfSxcbiAgLy8gc29tZSBkZXBlbmRlbmNpZXMgYXJlIGlnbm9yZWQgaW4gdGhlIGxpc3QgYmVsb3c6XG4gIC8vICAtIGRlZmF1bHRCb3VuZHMgYW5kIHRoZSBkZWZhdWx0KiBjYW1lcmEgcHJvcHMgd2lsbCBvbmx5IGJlIHVzZWQgb25jZSwgYW5kXG4gIC8vICAgIGNoYW5nZXMgc2hvdWxkIGJlIGlnbm9yZWRcbiAgLy8gIC0gbWFwT3B0aW9ucyBoYXMgc3BlY2lhbCBob29rcyB0aGF0IHRha2UgY2FyZSBvZiB1cGRhdGluZyB0aGUgb3B0aW9uc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtjb250YWluZXIsIGFwaUlzTG9hZGVkLCBpZCxcbiAgLy8gdGhlc2UgcHJvcHMgY2FuJ3QgYmUgY2hhbmdlZCBhZnRlciBpbml0aWFsaXphdGlvbiBhbmQgcmVxdWlyZSBhIG5ld1xuICAvLyBpbnN0YW5jZSB0byBiZSBjcmVhdGVkXG4gIHByb3BzLm1hcElkLCBwcm9wcy5yZW5kZXJpbmdUeXBlLCBwcm9wcy5jb2xvclNjaGVtZV0pO1xuICByZXR1cm4gW21hcCwgY29udGFpbmVyUmVmLCBjYW1lcmFTdGF0ZVJlZl07XG59XG5cbmNvbnN0IEdvb2dsZU1hcHNDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbi8vIENvbG9yU2NoZW1lIGFuZCBSZW5kZXJpbmdUeXBlIGFyZSByZWRlZmluZWQgaGVyZSB0byBtYWtlIHRoZW0gdXNhYmxlIGJlZm9yZSB0aGVcbi8vIG1hcHMgQVBJIGhhcyBiZWVuIGZ1bGx5IGxvYWRlZC5cbmNvbnN0IENvbG9yU2NoZW1lID0ge1xuICBEQVJLOiAnREFSSycsXG4gIExJR0hUOiAnTElHSFQnLFxuICBGT0xMT1dfU1lTVEVNOiAnRk9MTE9XX1NZU1RFTSdcbn07XG5jb25zdCBSZW5kZXJpbmdUeXBlID0ge1xuICBWRUNUT1I6ICdWRUNUT1InLFxuICBSQVNURVI6ICdSQVNURVInLFxuICBVTklOSVRJQUxJWkVEOiAnVU5JTklUSUFMSVpFRCdcbn07XG5jb25zdCBNYXAgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBpZCxcbiAgICBjbGFzc05hbWUsXG4gICAgc3R5bGVcbiAgfSA9IHByb3BzO1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChBUElQcm92aWRlckNvbnRleHQpO1xuICBjb25zdCBsb2FkaW5nU3RhdHVzID0gdXNlQXBpTG9hZGluZ1N0YXR1cygpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJzxNYXA+IGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGFuIDxBcGlQcm92aWRlcj4gY29tcG9uZW50LicpO1xuICB9XG4gIGNvbnN0IFttYXAsIG1hcFJlZiwgY2FtZXJhU3RhdGVSZWZdID0gdXNlTWFwSW5zdGFuY2UocHJvcHMsIGNvbnRleHQpO1xuICB1c2VNYXBDYW1lcmFQYXJhbXMobWFwLCBjYW1lcmFTdGF0ZVJlZiwgcHJvcHMpO1xuICB1c2VNYXBFdmVudHMobWFwLCBwcm9wcyk7XG4gIHVzZU1hcE9wdGlvbnMobWFwLCBwcm9wcyk7XG4gIGNvbnN0IGlzRGVja0dsQ29udHJvbGxlZCA9IHVzZURlY2tHTENhbWVyYVVwZGF0ZShtYXAsIHByb3BzKTtcbiAgY29uc3QgaXNDb250cm9sbGVkRXh0ZXJuYWxseSA9ICEhcHJvcHMuY29udHJvbGxlZDtcbiAgLy8gZGlzYWJsZSBpbnRlcmFjdGlvbnMgd2l0aCB0aGUgbWFwIGZvciBleHRlcm5hbGx5IGNvbnRyb2xsZWQgbWFwc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFwKSByZXR1cm47XG4gICAgLy8gZml4bWU6IHRoaXMgZG9lc24ndCBzZWVtIHRvIGJlbG9uZyBoZXJlIChhbmQgaXQncyBtb3N0bHkgdGhlcmUgZm9yIGNvbnZlbmllbmNlIGFueXdheSkuXG4gICAgLy8gICBUaGUgcmVhc29uaW5nIGlzIHRoYXQgYSBkZWNrLmdsIGNhbnZhcyB3aWxsIGJlIHB1dCBvbiB0b3Agb2YgdGhlIG1hcCwgcmVuZGVyaW5nXG4gICAgLy8gICBhbnkgZGVmYXVsdCBtYXAgY29udHJvbHMgcHJldHR5IG11Y2ggdXNlbGVzc1xuICAgIGlmIChpc0RlY2tHbENvbnRyb2xsZWQpIHtcbiAgICAgIG1hcC5zZXRPcHRpb25zKHtcbiAgICAgICAgZGlzYWJsZURlZmF1bHRVSTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGRpc2FibGUgYWxsIGNvbnRyb2wtaW5wdXRzIHdoZW4gdGhlIG1hcCBpcyBjb250cm9sbGVkIGV4dGVybmFsbHlcbiAgICBpZiAoaXNEZWNrR2xDb250cm9sbGVkIHx8IGlzQ29udHJvbGxlZEV4dGVybmFsbHkpIHtcbiAgICAgIG1hcC5zZXRPcHRpb25zKHtcbiAgICAgICAgZ2VzdHVyZUhhbmRsaW5nOiAnbm9uZScsXG4gICAgICAgIGtleWJvYXJkU2hvcnRjdXRzOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBtYXAuc2V0T3B0aW9ucyh7XG4gICAgICAgIGdlc3R1cmVIYW5kbGluZzogcHJvcHMuZ2VzdHVyZUhhbmRsaW5nLFxuICAgICAgICBrZXlib2FyZFNob3J0Y3V0czogcHJvcHMua2V5Ym9hcmRTaG9ydGN1dHNcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sIFttYXAsIGlzRGVja0dsQ29udHJvbGxlZCwgaXNDb250cm9sbGVkRXh0ZXJuYWxseSwgcHJvcHMuZ2VzdHVyZUhhbmRsaW5nLCBwcm9wcy5rZXlib2FyZFNob3J0Y3V0c10pO1xuICAvLyBzZXR1cCBhIHN0YWJsZSBjYW1lcmFPcHRpb25zIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGRlcGVuZGVuY3lcbiAgY29uc3QgY2VudGVyID0gcHJvcHMuY2VudGVyID8gdG9MYXRMbmdMaXRlcmFsKHByb3BzLmNlbnRlcikgOiBudWxsO1xuICBsZXQgbGF0ID0gbnVsbDtcbiAgbGV0IGxuZyA9IG51bGw7XG4gIGlmIChjZW50ZXIgJiYgTnVtYmVyLmlzRmluaXRlKGNlbnRlci5sYXQpICYmIE51bWJlci5pc0Zpbml0ZShjZW50ZXIubG5nKSkge1xuICAgIGxhdCA9IGNlbnRlci5sYXQ7XG4gICAgbG5nID0gY2VudGVyLmxuZztcbiAgfVxuICBjb25zdCBjYW1lcmFPcHRpb25zID0gdXNlTWVtbygoKSA9PiB7XG4gICAgdmFyIF9sYXQsIF9sbmcsIF9wcm9wcyR6b29tLCBfcHJvcHMkaGVhZGluZywgX3Byb3BzJHRpbHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNlbnRlcjoge1xuICAgICAgICBsYXQ6IChfbGF0ID0gbGF0KSAhPSBudWxsID8gX2xhdCA6IDAsXG4gICAgICAgIGxuZzogKF9sbmcgPSBsbmcpICE9IG51bGwgPyBfbG5nIDogMFxuICAgICAgfSxcbiAgICAgIHpvb206IChfcHJvcHMkem9vbSA9IHByb3BzLnpvb20pICE9IG51bGwgPyBfcHJvcHMkem9vbSA6IDAsXG4gICAgICBoZWFkaW5nOiAoX3Byb3BzJGhlYWRpbmcgPSBwcm9wcy5oZWFkaW5nKSAhPSBudWxsID8gX3Byb3BzJGhlYWRpbmcgOiAwLFxuICAgICAgdGlsdDogKF9wcm9wcyR0aWx0ID0gcHJvcHMudGlsdCkgIT0gbnVsbCA/IF9wcm9wcyR0aWx0IDogMFxuICAgIH07XG4gIH0sIFtsYXQsIGxuZywgcHJvcHMuem9vbSwgcHJvcHMuaGVhZGluZywgcHJvcHMudGlsdF0pO1xuICAvLyBleHRlcm5hbGx5IGNvbnRyb2xsZWQgbW9kZTogcmVqZWN0IGFsbCBjYW1lcmEgY2hhbmdlcyB0aGF0IGRvbid0IGNvcnJlc3BvbmQgdG8gY2hhbmdlcyBpbiBwcm9wc1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFwIHx8ICFpc0NvbnRyb2xsZWRFeHRlcm5hbGx5KSByZXR1cm47XG4gICAgbWFwLm1vdmVDYW1lcmEoY2FtZXJhT3B0aW9ucyk7XG4gICAgY29uc3QgbGlzdGVuZXIgPSBtYXAuYWRkTGlzdGVuZXIoJ2JvdW5kc19jaGFuZ2VkJywgKCkgPT4ge1xuICAgICAgbWFwLm1vdmVDYW1lcmEoY2FtZXJhT3B0aW9ucyk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IGxpc3RlbmVyLnJlbW92ZSgpO1xuICB9LCBbbWFwLCBpc0NvbnRyb2xsZWRFeHRlcm5hbGx5LCBjYW1lcmFPcHRpb25zXSk7XG4gIGNvbnN0IGNvbWJpbmVkU3R5bGUgPSB1c2VNZW1vKCgpID0+IF9leHRlbmRzKHtcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMCUnLFxuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIC8vIHdoZW4gdXNpbmcgZGVja2dsLCB0aGUgbWFwIHNob3VsZCBiZSBzZW50IHRvIHRoZSBiYWNrXG4gICAgekluZGV4OiBpc0RlY2tHbENvbnRyb2xsZWQgPyAtMSA6IDBcbiAgfSwgc3R5bGUpLCBbc3R5bGUsIGlzRGVja0dsQ29udHJvbGxlZF0pO1xuICBjb25zdCBjb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgbWFwXG4gIH0pLCBbbWFwXSk7XG4gIGlmIChsb2FkaW5nU3RhdHVzID09PSBBUElMb2FkaW5nU3RhdHVzLkFVVEhfRkFJTFVSRSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBzdHlsZTogX2V4dGVuZHMoe1xuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgICAgfSwgY2xhc3NOYW1lID8ge30gOiBjb21iaW5lZFN0eWxlKSxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQXV0aEZhaWx1cmVNZXNzYWdlLCBudWxsKSk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICByZWY6IG1hcFJlZixcbiAgICBcImRhdGEtdGVzdGlkXCI6ICdtYXAnLFxuICAgIHN0eWxlOiBjbGFzc05hbWUgPyB1bmRlZmluZWQgOiBjb21iaW5lZFN0eWxlLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gIH0sIGlkID8ge1xuICAgIGlkXG4gIH0gOiB7fSksIG1hcCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEdvb2dsZU1hcHNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRWYWx1ZVxuICB9LCBjaGlsZHJlbikgOiBudWxsKTtcbn07XG4vLyBUaGUgZGVja0dMVmlld1Byb3BzIGZsYWcgaGVyZSBpbmRpY2F0ZXMgdG8gZGVjay5nbCB0aGF0IHRoZSBNYXAgY29tcG9uZW50IGlzXG4vLyBhYmxlIHRvIGhhbmRsZSB2aWV3UHJvcHMgZnJvbSBkZWNrLmdsIHdoZW4gZGVjay5nbCBpcyB1c2VkIHRvIGNvbnRyb2wgdGhlIG1hcC5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5NYXAuZGVja0dMVmlld1Byb3BzID0gdHJ1ZTtcblxuY29uc3Qgc2hvd25NZXNzYWdlcyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGxvZ0Vycm9yT25jZSguLi5hcmdzKSB7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KGFyZ3MpO1xuICBpZiAoIXNob3duTWVzc2FnZXMuaGFzKGtleSkpIHtcbiAgICBzaG93bk1lc3NhZ2VzLmFkZChrZXkpO1xuICAgIGNvbnNvbGUuZXJyb3IoLi4uYXJncyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBtYXAtaW5zdGFuY2UgZnJvbSB0aGUgY29udGV4dC4gVGhpcyBpcyBlaXRoZXIgYW4gaW5zdGFuY2VcbiAqIGlkZW50aWZpZWQgYnkgaWQgb3IgdGhlIHBhcmVudCBtYXAgaW5zdGFuY2UgaWYgbm8gaWQgaXMgc3BlY2lmaWVkLlxuICogUmV0dXJucyBudWxsIGlmIG5laXRoZXIgY2FuIGJlIGZvdW5kLlxuICovXG5jb25zdCB1c2VNYXAgPSAoaWQgPSBudWxsKSA9PiB7XG4gIGNvbnN0IGN0eCA9IHVzZUNvbnRleHQoQVBJUHJvdmlkZXJDb250ZXh0KTtcbiAgY29uc3Qge1xuICAgIG1hcFxuICB9ID0gdXNlQ29udGV4dChHb29nbGVNYXBzQ29udGV4dCkgfHwge307XG4gIGlmIChjdHggPT09IG51bGwpIHtcbiAgICBsb2dFcnJvck9uY2UoJ3VzZU1hcCgpOiBmYWlsZWQgdG8gcmV0cmlldmUgQVBJUHJvdmlkZXJDb250ZXh0LiAnICsgJ01ha2Ugc3VyZSB0aGF0IHRoZSA8QVBJUHJvdmlkZXI+IGNvbXBvbmVudCBleGlzdHMgYW5kIHRoYXQgdGhlICcgKyAnY29tcG9uZW50IHlvdSBhcmUgY2FsbGluZyBgdXNlTWFwKClgIGZyb20gaXMgYSBzaWJsaW5nIG9mIHRoZSAnICsgJzxBUElQcm92aWRlcj4uJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qge1xuICAgIG1hcEluc3RhbmNlc1xuICB9ID0gY3R4O1xuICAvLyBpZiBhbiBpZCBpcyBzcGVjaWZpZWQsIHRoZSBjb3JyZXNwb25kaW5nIG1hcCBvciBudWxsIGlzIHJldHVybmVkXG4gIGlmIChpZCAhPT0gbnVsbCkgcmV0dXJuIG1hcEluc3RhbmNlc1tpZF0gfHwgbnVsbDtcbiAgLy8gb3RoZXJ3aXNlLCByZXR1cm4gdGhlIGNsb3Nlc3QgYW5jZXN0b3JcbiAgaWYgKG1hcCkgcmV0dXJuIG1hcDtcbiAgLy8gZmluYWxseSwgcmV0dXJuIHRoZSBkZWZhdWx0IG1hcCBpbnN0YW5jZVxuICByZXR1cm4gbWFwSW5zdGFuY2VzWydkZWZhdWx0J10gfHwgbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHVzZU1hcHNMaWJyYXJ5KG5hbWUpIHtcbiAgY29uc3QgYXBpSXNMb2FkZWQgPSB1c2VBcGlJc0xvYWRlZCgpO1xuICBjb25zdCBjdHggPSB1c2VDb250ZXh0KEFQSVByb3ZpZGVyQ29udGV4dCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFhcGlJc0xvYWRlZCB8fCAhY3R4KSByZXR1cm47XG4gICAgLy8gVHJpZ2dlciBsb2FkaW5nIHRoZSBsaWJyYXJpZXMgdmlhIG91ciBwcm94eS1tZXRob2QuXG4gICAgLy8gVGhlIHJldHVybmVkIHByb21pc2UgaXMgaWdub3JlZCwgc2luY2UgaW1wb3J0TGlicmFyeSB3aWxsIHVwZGF0ZSBsb2FkZWRMaWJyYXJpZXNcbiAgICAvLyBsaXN0IGluIHRoZSBjb250ZXh0LCB0cmlnZ2VyaW5nIGEgcmUtcmVuZGVyLlxuICAgIHZvaWQgY3R4LmltcG9ydExpYnJhcnkobmFtZSk7XG4gIH0sIFthcGlJc0xvYWRlZCwgY3R4LCBuYW1lXSk7XG4gIHJldHVybiAoY3R4ID09IG51bGwgPyB2b2lkIDAgOiBjdHgubG9hZGVkTGlicmFyaWVzW25hbWVdKSB8fCBudWxsO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKipcbiAqIEludGVybmFsbHkgdXNlZCB0byBiaW5kIGV2ZW50cyB0byBNYXBzIEphdmFTY3JpcHQgQVBJIG9iamVjdHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlTWFwc0V2ZW50TGlzdGVuZXIodGFyZ2V0LCBuYW1lLCBjYWxsYmFjaykge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghdGFyZ2V0IHx8ICFuYW1lIHx8ICFjYWxsYmFjaykgcmV0dXJuO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIodGFyZ2V0LCBuYW1lLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IGxpc3RlbmVyLnJlbW92ZSgpO1xuICB9LCBbdGFyZ2V0LCBuYW1lLCBjYWxsYmFja10pO1xufVxuXG4vKipcbiAqIEludGVybmFsbHkgdXNlZCB0byBjb3B5IHZhbHVlcyBmcm9tIHByb3BzIGludG8gQVBJLU9iamVjdHNcbiAqIHdoZW5ldmVyIHRoZXkgY2hhbmdlLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIHVzZVByb3BCaW5kaW5nKG1hcmtlciwgJ3Bvc2l0aW9uJywgcG9zaXRpb24pO1xuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VQcm9wQmluZGluZyhvYmplY3QsIHByb3AsIHZhbHVlKSB7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFvYmplY3QpIHJldHVybjtcbiAgICBvYmplY3RbcHJvcF0gPSB2YWx1ZTtcbiAgfSwgW29iamVjdCwgcHJvcCwgdmFsdWVdKTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyoqXG4gKiBJbnRlcm5hbGx5IHVzZWQgdG8gYmluZCBldmVudHMgdG8gRE9NIG5vZGVzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZURvbUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBuYW1lLCBjYWxsYmFjaykge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghdGFyZ2V0IHx8ICFuYW1lIHx8ICFjYWxsYmFjaykgcmV0dXJuO1xuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2spO1xuICB9LCBbdGFyZ2V0LCBuYW1lLCBjYWxsYmFja10pO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG5mdW5jdGlvbiBpc0FkdmFuY2VkTWFya2VyKG1hcmtlcikge1xuICByZXR1cm4gbWFya2VyLmNvbnRlbnQgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG59XG4vKipcbiAqIENvcHkgb2YgdGhlIGBnb29nbGUubWFwcy5Db2xsaXNpb25CZWhhdmlvcmAgY29uc3RhbnRzLlxuICogVGhleSBoYXZlIHRvIGJlIGR1cGxpY2F0ZWQgaGVyZSBzaW5jZSB3ZSBjYW4ndCB3YWl0IGZvciB0aGUgbWFwcyBBUEkgdG8gbG9hZCB0byBiZSBhYmxlIHRvIHVzZSB0aGVtLlxuICovXG5jb25zdCBDb2xsaXNpb25CZWhhdmlvciA9IHtcbiAgUkVRVUlSRUQ6ICdSRVFVSVJFRCcsXG4gIFJFUVVJUkVEX0FORF9ISURFU19PUFRJT05BTDogJ1JFUVVJUkVEX0FORF9ISURFU19PUFRJT05BTCcsXG4gIE9QVElPTkFMX0FORF9ISURFU19MT1dFUl9QUklPUklUWTogJ09QVElPTkFMX0FORF9ISURFU19MT1dFUl9QUklPUklUWSdcbn07XG5jb25zdCBBZHZhbmNlZE1hcmtlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuLy8gW3hQb3NpdGlvbiwgeVBvc2l0aW9uXSB3aGVuIHRoZSB0b3AgbGVmdCBjb3JuZXIgaXMgWzAsIDBdXG5jb25zdCBBZHZhbmNlZE1hcmtlckFuY2hvclBvaW50ID0ge1xuICBUT1BfTEVGVDogWycwJScsICcwJSddLFxuICBUT1BfQ0VOVEVSOiBbJzUwJScsICcwJSddLFxuICBUT1A6IFsnNTAlJywgJzAlJ10sXG4gIFRPUF9SSUdIVDogWycxMDAlJywgJzAlJ10sXG4gIExFRlRfQ0VOVEVSOiBbJzAlJywgJzUwJSddLFxuICBMRUZUX1RPUDogWycwJScsICcwJSddLFxuICBMRUZUOiBbJzAlJywgJzUwJSddLFxuICBMRUZUX0JPVFRPTTogWycwJScsICcxMDAlJ10sXG4gIFJJR0hUX1RPUDogWycxMDAlJywgJzAlJ10sXG4gIFJJR0hUOiBbJzEwMCUnLCAnNTAlJ10sXG4gIFJJR0hUX0NFTlRFUjogWycxMDAlJywgJzUwJSddLFxuICBSSUdIVF9CT1RUT006IFsnMTAwJScsICcxMDAlJ10sXG4gIEJPVFRPTV9MRUZUOiBbJzAlJywgJzEwMCUnXSxcbiAgQk9UVE9NX0NFTlRFUjogWyc1MCUnLCAnMTAwJSddLFxuICBCT1RUT006IFsnNTAlJywgJzEwMCUnXSxcbiAgQk9UVE9NX1JJR0hUOiBbJzEwMCUnLCAnMTAwJSddLFxuICBDRU5URVI6IFsnNTAlJywgJzUwJSddXG59O1xuY29uc3QgTWFya2VyQ29udGVudCA9ICh7XG4gIGNoaWxkcmVuLFxuICBzdHlsZXMsXG4gIGNsYXNzTmFtZSxcbiAgYW5jaG9yUG9pbnRcbn0pID0+IHtcbiAgY29uc3QgW3hUcmFuc2xhdGlvbiwgeVRyYW5zbGF0aW9uXSA9IGFuY2hvclBvaW50ICE9IG51bGwgPyBhbmNob3JQb2ludCA6IEFkdmFuY2VkTWFya2VyQW5jaG9yUG9pbnRbJ0JPVFRPTSddO1xuICBsZXQgeFRyYW5zbGF0aW9uRmxpcHBlZCA9IGAtJHt4VHJhbnNsYXRpb259YDtcbiAgbGV0IHlUcmFuc2xhdGlvbkZsaXBwZWQgPSBgLSR7eVRyYW5zbGF0aW9ufWA7XG4gIGlmICh4VHJhbnNsYXRpb24udHJpbVN0YXJ0KCkuc3RhcnRzV2l0aCgnLScpKSB7XG4gICAgeFRyYW5zbGF0aW9uRmxpcHBlZCA9IHhUcmFuc2xhdGlvbi5zdWJzdHJpbmcoMSk7XG4gIH1cbiAgaWYgKHlUcmFuc2xhdGlvbi50cmltU3RhcnQoKS5zdGFydHNXaXRoKCctJykpIHtcbiAgICB5VHJhbnNsYXRpb25GbGlwcGVkID0geVRyYW5zbGF0aW9uLnN1YnN0cmluZygxKTtcbiAgfVxuICAvLyBUaGUgXCJ0cmFuc2xhdGUoNTAlLCAxMDAlKVwiIGlzIGhlcmUgdG8gY291bnRlciBhbmQgcmVzZXQgdGhlIGRlZmF1bHQgYW5jaG9yaW5nIG9mIHRoZSBhZHZhbmNlZCBtYXJrZXIgZWxlbWVudFxuICAvLyB0aGF0IGNvbWVzIGZyb20gdGhlIGFwaVxuICBjb25zdCB0cmFuc2Zvcm1TdHlsZSA9IGB0cmFuc2xhdGUoNTAlLCAxMDAlKSB0cmFuc2xhdGUoJHt4VHJhbnNsYXRpb25GbGlwcGVkfSwgJHt5VHJhbnNsYXRpb25GbGlwcGVkfSlgO1xuICByZXR1cm4gKFxuICAgIC8qI19fUFVSRV9fKi9cbiAgICAvLyBhbmNob3JpbmcgY29udGFpbmVyXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybVN0eWxlXG4gICAgICB9XG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICBzdHlsZTogc3R5bGVzXG4gICAgfSwgY2hpbGRyZW4pKVxuICApO1xufTtcbmZ1bmN0aW9uIHVzZUFkdmFuY2VkTWFya2VyKHByb3BzKSB7XG4gIGNvbnN0IFttYXJrZXIsIHNldE1hcmtlcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2NvbnRlbnRDb250YWluZXIsIHNldENvbnRlbnRDb250YWluZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IG1hcCA9IHVzZU1hcCgpO1xuICBjb25zdCBtYXJrZXJMaWJyYXJ5ID0gdXNlTWFwc0xpYnJhcnkoJ21hcmtlcicpO1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgb25DbGljayxcbiAgICBjbGFzc05hbWUsXG4gICAgb25Nb3VzZUVudGVyLFxuICAgIG9uTW91c2VMZWF2ZSxcbiAgICBvbkRyYWcsXG4gICAgb25EcmFnU3RhcnQsXG4gICAgb25EcmFnRW5kLFxuICAgIGNvbGxpc2lvbkJlaGF2aW9yLFxuICAgIGNsaWNrYWJsZSxcbiAgICBkcmFnZ2FibGUsXG4gICAgcG9zaXRpb24sXG4gICAgdGl0bGUsXG4gICAgekluZGV4XG4gIH0gPSBwcm9wcztcbiAgY29uc3QgbnVtQ2hpbGRyZW4gPSBDaGlsZHJlbi5jb3VudChjaGlsZHJlbik7XG4gIC8vIGNyZWF0ZSBhbiBBZHZhbmNlZE1hcmtlckVsZW1lbnQgaW5zdGFuY2UgYW5kIGFkZCBpdCB0byB0aGUgbWFwIG9uY2UgYXZhaWxhYmxlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXAgfHwgIW1hcmtlckxpYnJhcnkpIHJldHVybjtcbiAgICBjb25zdCBuZXdNYXJrZXIgPSBuZXcgbWFya2VyTGlicmFyeS5BZHZhbmNlZE1hcmtlckVsZW1lbnQoKTtcbiAgICBuZXdNYXJrZXIubWFwID0gbWFwO1xuICAgIHNldE1hcmtlcihuZXdNYXJrZXIpO1xuICAgIC8vIGNyZWF0ZSB0aGUgY29udGFpbmVyIGZvciBtYXJrZXIgY29udGVudCBpZiB0aGVyZSBhcmUgY2hpbGRyZW5cbiAgICBsZXQgY29udGVudEVsZW1lbnQgPSBudWxsO1xuICAgIGlmIChudW1DaGlsZHJlbiA+IDApIHtcbiAgICAgIGNvbnRlbnRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAvLyBXZSBuZWVkIHNvbWUga2luZCBvZiBmbGFnIHRvIGlkZW50aWZ5IHRoZSBjdXN0b20gbWFya2VyIGNvbnRlbnRcbiAgICAgIC8vIGluIHRoZSBpbmZvd2luZG93IGNvbXBvbmVudC4gQ2hvb3NpbmcgYSBjdXN0b20gcHJvcGVydHkgaW5zdGVhZCBvZiBhIGNsYXNzTmFtZVxuICAgICAgLy8gdG8gbm90IGVuY291cmFnZSB1c2VycyB0byBzdHlsZSB0aGUgbWFya2VyIGNvbnRlbnQgZGlyZWN0bHkuXG4gICAgICBjb250ZW50RWxlbWVudC5pc0N1c3RvbU1hcmtlciA9IHRydWU7XG4gICAgICBuZXdNYXJrZXIuY29udGVudCA9IGNvbnRlbnRFbGVtZW50O1xuICAgICAgc2V0Q29udGVudENvbnRhaW5lcihjb250ZW50RWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB2YXIgX2NvbnRlbnRFbGVtZW50O1xuICAgICAgbmV3TWFya2VyLm1hcCA9IG51bGw7XG4gICAgICAoX2NvbnRlbnRFbGVtZW50ID0gY29udGVudEVsZW1lbnQpID09IG51bGwgfHwgX2NvbnRlbnRFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgc2V0TWFya2VyKG51bGwpO1xuICAgICAgc2V0Q29udGVudENvbnRhaW5lcihudWxsKTtcbiAgICB9O1xuICB9LCBbbWFwLCBtYXJrZXJMaWJyYXJ5LCBudW1DaGlsZHJlbl0pO1xuICAvLyBXaGVuIG5vIGNoaWxkcmVuIGFyZSBwcmVzZW50IHdlIGRvbid0IGhhdmUgb3VyIG93biB3cmFwcGVyIGRpdlxuICAvLyB3aGljaCB1c3VhbGx5IGdldHMgdGhlIHVzZXIgcHJvdmlkZWQgY2xhc3NOYW1lLiBJbiB0aGlzIGNhc2VcbiAgLy8gd2Ugc2V0IHRoZSBjbGFzc05hbWUgZGlyZWN0bHkgb24gdGhlIG1hcmtlci5jb250ZW50IGVsZW1lbnQgdGhhdCBjb21lc1xuICAvLyB3aXRoIHRoZSBBZHZhbmNlZE1hcmtlci5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIShtYXJrZXIgIT0gbnVsbCAmJiBtYXJrZXIuY29udGVudCkgfHwgIWlzRWxlbWVudE5vZGUobWFya2VyLmNvbnRlbnQpIHx8IG51bUNoaWxkcmVuID4gMCkgcmV0dXJuO1xuICAgIG1hcmtlci5jb250ZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZSAhPSBudWxsID8gY2xhc3NOYW1lIDogJyc7XG4gIH0sIFttYXJrZXIsIGNsYXNzTmFtZSwgbnVtQ2hpbGRyZW5dKTtcbiAgLy8gY29weSBvdGhlciBwcm9wc1xuICB1c2VQcm9wQmluZGluZyhtYXJrZXIsICdwb3NpdGlvbicsIHBvc2l0aW9uKTtcbiAgdXNlUHJvcEJpbmRpbmcobWFya2VyLCAndGl0bGUnLCB0aXRsZSAhPSBudWxsID8gdGl0bGUgOiAnJyk7XG4gIHVzZVByb3BCaW5kaW5nKG1hcmtlciwgJ3pJbmRleCcsIHpJbmRleCk7XG4gIHVzZVByb3BCaW5kaW5nKG1hcmtlciwgJ2NvbGxpc2lvbkJlaGF2aW9yJywgY29sbGlzaW9uQmVoYXZpb3IpO1xuICAvLyBzZXQgZ21wRHJhZ2dhYmxlIGZyb20gcHJvcHMgKHdoZW4gdW5zcGVjaWZpZWQsIGl0J3MgdHJ1ZSBpZiBhbnkgZHJhZy1ldmVudFxuICAvLyBjYWxsYmFja3MgYXJlIHNwZWNpZmllZClcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1hcmtlcikgcmV0dXJuO1xuICAgIGlmIChkcmFnZ2FibGUgIT09IHVuZGVmaW5lZCkgbWFya2VyLmdtcERyYWdnYWJsZSA9IGRyYWdnYWJsZTtlbHNlIGlmIChvbkRyYWcgfHwgb25EcmFnU3RhcnQgfHwgb25EcmFnRW5kKSBtYXJrZXIuZ21wRHJhZ2dhYmxlID0gdHJ1ZTtlbHNlIG1hcmtlci5nbXBEcmFnZ2FibGUgPSBmYWxzZTtcbiAgfSwgW21hcmtlciwgZHJhZ2dhYmxlLCBvbkRyYWcsIG9uRHJhZ0VuZCwgb25EcmFnU3RhcnRdKTtcbiAgLy8gc2V0IGdtcENsaWNrYWJsZSBmcm9tIHByb3BzICh3aGVuIHVuc3BlY2lmaWVkLCBpdCdzIHRydWUgaWYgdGhlIG9uQ2xpY2sgb3Igb25lIG9mXG4gIC8vIHRoZSBob3ZlciBldmVudHMgY2FsbGJhY2tzIGFyZSBzcGVjaWZpZWQpXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXJrZXIpIHJldHVybjtcbiAgICBjb25zdCBnbXBDbGlja2FibGUgPSBjbGlja2FibGUgIT09IHVuZGVmaW5lZCB8fCBCb29sZWFuKG9uQ2xpY2spIHx8IEJvb2xlYW4ob25Nb3VzZUVudGVyKSB8fCBCb29sZWFuKG9uTW91c2VMZWF2ZSk7XG4gICAgLy8gZ21wQ2xpY2thYmxlIGlzIG9ubHkgYXZhaWxhYmxlIGluIGJldGEgdmVyc2lvbiBvZiB0aGVcbiAgICAvLyBtYXBzIGFwaSAoYXMgb2YgMjAyNC0xMC0xMClcbiAgICBtYXJrZXIuZ21wQ2xpY2thYmxlID0gZ21wQ2xpY2thYmxlO1xuICAgIC8vIGVuYWJsZSBwb2ludGVyIGV2ZW50cyBmb3IgdGhlIG1hcmtlcnMgd2l0aCBjdXN0b20gY29udGVudFxuICAgIGlmIChnbXBDbGlja2FibGUgJiYgbWFya2VyICE9IG51bGwgJiYgbWFya2VyLmNvbnRlbnQgJiYgaXNFbGVtZW50Tm9kZShtYXJrZXIuY29udGVudCkpIHtcbiAgICAgIG1hcmtlci5jb250ZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICBpZiAobWFya2VyLmNvbnRlbnQuZmlyc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgICAgbWFya2VyLmNvbnRlbnQuZmlyc3RFbGVtZW50Q2hpbGQuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhbGwnO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW21hcmtlciwgY2xpY2thYmxlLCBvbkNsaWNrLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZV0pO1xuICB1c2VNYXBzRXZlbnRMaXN0ZW5lcihtYXJrZXIsICdjbGljaycsIG9uQ2xpY2spO1xuICB1c2VNYXBzRXZlbnRMaXN0ZW5lcihtYXJrZXIsICdkcmFnJywgb25EcmFnKTtcbiAgdXNlTWFwc0V2ZW50TGlzdGVuZXIobWFya2VyLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpO1xuICB1c2VNYXBzRXZlbnRMaXN0ZW5lcihtYXJrZXIsICdkcmFnZW5kJywgb25EcmFnRW5kKTtcbiAgdXNlRG9tRXZlbnRMaXN0ZW5lcihtYXJrZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG1hcmtlci5lbGVtZW50LCAnbW91c2VlbnRlcicsIG9uTW91c2VFbnRlcik7XG4gIHVzZURvbUV2ZW50TGlzdGVuZXIobWFya2VyID09IG51bGwgPyB2b2lkIDAgOiBtYXJrZXIuZWxlbWVudCwgJ21vdXNlbGVhdmUnLCBvbk1vdXNlTGVhdmUpO1xuICByZXR1cm4gW21hcmtlciwgY29udGVudENvbnRhaW5lcl07XG59XG5jb25zdCBBZHZhbmNlZE1hcmtlciA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIHN0eWxlLFxuICAgIGNsYXNzTmFtZSxcbiAgICBhbmNob3JQb2ludFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IFttYXJrZXIsIGNvbnRlbnRDb250YWluZXJdID0gdXNlQWR2YW5jZWRNYXJrZXIocHJvcHMpO1xuICBjb25zdCBhZHZhbmNlZE1hcmtlckNvbnRleHRWYWx1ZSA9IHVzZU1lbW8oKCkgPT4gbWFya2VyID8ge1xuICAgIG1hcmtlclxuICB9IDogbnVsbCwgW21hcmtlcl0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gbWFya2VyLCBbbWFya2VyXSk7XG4gIGlmICghY29udGVudENvbnRhaW5lcikgcmV0dXJuIG51bGw7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBZHZhbmNlZE1hcmtlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogYWR2YW5jZWRNYXJrZXJDb250ZXh0VmFsdWVcbiAgfSwgY3JlYXRlUG9ydGFsKC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtlckNvbnRlbnQsIHtcbiAgICBhbmNob3JQb2ludDogYW5jaG9yUG9pbnQsXG4gICAgc3R5bGVzOiBzdHlsZSxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICB9LCBjaGlsZHJlbiksIGNvbnRlbnRDb250YWluZXIpKTtcbn0pO1xuZnVuY3Rpb24gdXNlQWR2YW5jZWRNYXJrZXJSZWYoKSB7XG4gIGNvbnN0IFttYXJrZXIsIHNldE1hcmtlcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgcmVmQ2FsbGJhY2sgPSB1c2VDYWxsYmFjayhtID0+IHtcbiAgICBzZXRNYXJrZXIobSk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIFtyZWZDYWxsYmFjaywgbWFya2VyXTtcbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVGb3JTdHlsZXMoZWxlbWVudCwgc3R5bGVzLCBwcmV2U3R5bGVzKSB7XG4gIGlmIChzdHlsZXMgIT0gbnVsbCAmJiB0eXBlb2Ygc3R5bGVzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCAnICsgXCJub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgJ2VtJ319IHdoZW4gXCIgKyAndXNpbmcgSlNYLicpO1xuICB9XG4gIGNvbnN0IGVsZW1lbnRTdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gIC8vIHdpdGhvdXQgYHByZXZTdHlsZXNgLCBqdXN0IHNldCBhbGwgdmFsdWVzXG4gIGlmIChwcmV2U3R5bGVzID09IG51bGwpIHtcbiAgICBpZiAoc3R5bGVzID09IG51bGwpIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIGNvbnRpbnVlO1xuICAgICAgc2V0VmFsdWVGb3JTdHlsZShlbGVtZW50U3R5bGUsIHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgLy8gdW5zZXQgYWxsIHN0eWxlcyBpbiBgcHJldlN0eWxlc2AgdGhhdCBhcmVuJ3QgaW4gYHN0eWxlc2BcbiAgZm9yIChjb25zdCBzdHlsZU5hbWUgaW4gcHJldlN0eWxlcykge1xuICAgIGlmIChwcmV2U3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgKHN0eWxlcyA9PSBudWxsIHx8ICFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgIC8vIENsZWFyIHN0eWxlXG4gICAgICBjb25zdCBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAgICBpZiAoaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICBlbGVtZW50U3R5bGUuc2V0UHJvcGVydHkoc3R5bGVOYW1lLCAnJyk7XG4gICAgICB9IGVsc2UgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgICBlbGVtZW50U3R5bGUuY3NzRmxvYXQgPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnRTdHlsZVtzdHlsZU5hbWVdID0gJyc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIG9ubHkgYXNzaWduIHZhbHVlcyBmcm9tIGBzdHlsZXNgIHRoYXQgYXJlIGRpZmZlcmVudCBmcm9tIGBwcmV2U3R5bGVzYFxuICBpZiAoc3R5bGVzID09IG51bGwpIHJldHVybjtcbiAgZm9yIChjb25zdCBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgcHJldlN0eWxlc1tzdHlsZU5hbWVdICE9PSB2YWx1ZSkge1xuICAgICAgc2V0VmFsdWVGb3JTdHlsZShlbGVtZW50U3R5bGUsIHN0eWxlTmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2V0VmFsdWVGb3JTdHlsZShlbGVtZW50U3R5bGUsIHN0eWxlTmFtZSwgdmFsdWUpIHtcbiAgY29uc3QgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAvLyBmYWxzeSB2YWx1ZXMgd2lsbCB1bnNldCB0aGUgc3R5bGUgcHJvcGVydHlcbiAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgIGVsZW1lbnRTdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsICcnKTtcbiAgICB9IGVsc2UgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgZWxlbWVudFN0eWxlLmNzc0Zsb2F0ID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnRTdHlsZVtzdHlsZU5hbWVdID0gJyc7XG4gICAgfVxuICB9XG4gIC8vIGN1c3RvbSBwcm9wZXJ0aWVzIGNhbid0IGJlIGRpcmVjdGx5IGFzc2lnbmVkXG4gIGVsc2UgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICBlbGVtZW50U3R5bGUuc2V0UHJvcGVydHkoc3R5bGVOYW1lLCB2YWx1ZSk7XG4gIH1cbiAgLy8gbnVtZXJpYyB2YWx1ZXMgYXJlIHRyZWF0ZWQgYXMgJ3B4JyB1bmxlc3MgdGhlIHN0eWxlIHByb3BlcnR5IGV4cGVjdHMgdW5pdGxlc3MgbnVtYmVyc1xuICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwICYmICFpc1VuaXRsZXNzTnVtYmVyKHN0eWxlTmFtZSkpIHtcbiAgICBlbGVtZW50U3R5bGVbc3R5bGVOYW1lXSA9IHZhbHVlICsgJ3B4JzsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcbiAgfVxuICAvLyBldmVyeXRoaW5nIGVsc2UgY2FuIGp1c3QgYmUgYXNzaWduZWRcbiAgZWxzZSB7XG4gICAgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgZWxlbWVudFN0eWxlLmNzc0Zsb2F0ID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnRTdHlsZVtzdHlsZU5hbWVdID0gKCcnICsgdmFsdWUpLnRyaW0oKTtcbiAgICB9XG4gIH1cbn1cbi8vIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbmNvbnN0IHVuaXRsZXNzTnVtYmVycyA9IG5ldyBTZXQoWydhbmltYXRpb25JdGVyYXRpb25Db3VudCcsICdhc3BlY3RSYXRpbycsICdib3JkZXJJbWFnZU91dHNldCcsICdib3JkZXJJbWFnZVNsaWNlJywgJ2JvcmRlckltYWdlV2lkdGgnLCAnYm94RmxleCcsICdib3hGbGV4R3JvdXAnLCAnYm94T3JkaW5hbEdyb3VwJywgJ2NvbHVtbkNvdW50JywgJ2NvbHVtbnMnLCAnZmxleCcsICdmbGV4R3JvdycsICdmbGV4UG9zaXRpdmUnLCAnZmxleFNocmluaycsICdmbGV4TmVnYXRpdmUnLCAnZmxleE9yZGVyJywgJ2dyaWRBcmVhJywgJ2dyaWRSb3cnLCAnZ3JpZFJvd0VuZCcsICdncmlkUm93U3BhbicsICdncmlkUm93U3RhcnQnLCAnZ3JpZENvbHVtbicsICdncmlkQ29sdW1uRW5kJywgJ2dyaWRDb2x1bW5TcGFuJywgJ2dyaWRDb2x1bW5TdGFydCcsICdmb250V2VpZ2h0JywgJ2xpbmVDbGFtcCcsICdsaW5lSGVpZ2h0JywgJ29wYWNpdHknLCAnb3JkZXInLCAnb3JwaGFucycsICdzY2FsZScsICd0YWJTaXplJywgJ3dpZG93cycsICd6SW5kZXgnLCAnem9vbScsICdmaWxsT3BhY2l0eScsXG4vLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4nZmxvb2RPcGFjaXR5JywgJ3N0b3BPcGFjaXR5JywgJ3N0cm9rZURhc2hhcnJheScsICdzdHJva2VEYXNob2Zmc2V0JywgJ3N0cm9rZU1pdGVybGltaXQnLCAnc3Ryb2tlT3BhY2l0eScsICdzdHJva2VXaWR0aCddKTtcbmZ1bmN0aW9uIGlzVW5pdGxlc3NOdW1iZXIobmFtZSkge1xuICByZXR1cm4gdW5pdGxlc3NOdW1iZXJzLmhhcyhuYW1lKTtcbn1cblxuY29uc3QgX2V4Y2x1ZGVkJDEgPSBbXCJjaGlsZHJlblwiLCBcImhlYWRlckNvbnRlbnRcIiwgXCJzdHlsZVwiLCBcImNsYXNzTmFtZVwiLCBcInBpeGVsT2Zmc2V0XCIsIFwiYW5jaG9yXCIsIFwic2hvdWxkRm9jdXNcIiwgXCJvbkNsb3NlXCIsIFwib25DbG9zZUNsaWNrXCJdO1xuLyoqXG4gKiBDb21wb25lbnQgdG8gcmVuZGVyIGFuIEluZm8gV2luZG93IHdpdGggdGhlIE1hcHMgSmF2YVNjcmlwdCBBUElcbiAqL1xuY29uc3QgSW5mb1dpbmRvdyA9IHByb3BzID0+IHtcbiAgY29uc3Qge1xuICAgICAgLy8gY29udGVudCBvcHRpb25zXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGhlYWRlckNvbnRlbnQsXG4gICAgICBzdHlsZSxcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIHBpeGVsT2Zmc2V0LFxuICAgICAgLy8gb3BlbiBvcHRpb25zXG4gICAgICBhbmNob3IsXG4gICAgICBzaG91bGRGb2N1cyxcbiAgICAgIC8vIGV2ZW50c1xuICAgICAgb25DbG9zZSxcbiAgICAgIG9uQ2xvc2VDbGlja1xuICAgICAgLy8gb3RoZXIgb3B0aW9uc1xuICAgIH0gPSBwcm9wcyxcbiAgICBpbmZvV2luZG93T3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkMSk7XG4gIC8vICMjIGNyZWF0ZSBpbmZvd2luZG93IGluc3RhbmNlIG9uY2UgdGhlIG1hcHNMaWJyYXJ5IGlzIGF2YWlsYWJsZS5cbiAgY29uc3QgbWFwc0xpYnJhcnkgPSB1c2VNYXBzTGlicmFyeSgnbWFwcycpO1xuICBjb25zdCBbaW5mb1dpbmRvdywgc2V0SW5mb1dpbmRvd10gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgY29udGVudENvbnRhaW5lclJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgaGVhZGVyQ29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFwc0xpYnJhcnkpIHJldHVybjtcbiAgICBjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBoZWFkZXJDb250YWluZXJSZWYuY3VycmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IG9wdHMgPSBpbmZvV2luZG93T3B0aW9ucztcbiAgICBpZiAocGl4ZWxPZmZzZXQpIHtcbiAgICAgIG9wdHMucGl4ZWxPZmZzZXQgPSBuZXcgZ29vZ2xlLm1hcHMuU2l6ZShwaXhlbE9mZnNldFswXSwgcGl4ZWxPZmZzZXRbMV0pO1xuICAgIH1cbiAgICBpZiAoaGVhZGVyQ29udGVudCkge1xuICAgICAgLy8gaWYgaGVhZGVyQ29udGVudCBpcyBzcGVjaWZpZWQgYXMgc3RyaW5nIHdlIGNhbiBkaXJlY3RseSBmb3J3YXJkIGl0LFxuICAgICAgLy8gb3RoZXJ3aXNlIHdlJ2xsIHBhc3MgdGhlIGVsZW1lbnQgdGhlIHBvcnRhbCB3aWxsIHJlbmRlciBpbnRvXG4gICAgICBvcHRzLmhlYWRlckNvbnRlbnQgPSB0eXBlb2YgaGVhZGVyQ29udGVudCA9PT0gJ3N0cmluZycgPyBoZWFkZXJDb250ZW50IDogaGVhZGVyQ29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgfVxuICAgIC8vIGludGVudGlvbmFsbHkgc2hhZG93aW5nIHRoZSBzdGF0ZSB2YXJpYWJsZXMgaGVyZVxuICAgIGNvbnN0IGluZm9XaW5kb3cgPSBuZXcgZ29vZ2xlLm1hcHMuSW5mb1dpbmRvdyhpbmZvV2luZG93T3B0aW9ucyk7XG4gICAgaW5mb1dpbmRvdy5zZXRDb250ZW50KGNvbnRlbnRDb250YWluZXJSZWYuY3VycmVudCk7XG4gICAgc2V0SW5mb1dpbmRvdyhpbmZvV2luZG93KTtcbiAgICAvLyB1bm1vdW50OiByZW1vdmUgaW5mb1dpbmRvdyBhbmQgY29udGVudCBlbGVtZW50cyAobm90ZTogY2xvc2UgaXMgY2FsbGVkIGluIGEgZGlmZmVyZW50IGVmZmVjdC1jbGVhbnVwKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB2YXIgX2NvbnRlbnRDb250YWluZXJSZWYkLCBfaGVhZGVyQ29udGFpbmVyUmVmJGM7XG4gICAgICBpbmZvV2luZG93LnNldENvbnRlbnQobnVsbCk7XG4gICAgICAoX2NvbnRlbnRDb250YWluZXJSZWYkID0gY29udGVudENvbnRhaW5lclJlZi5jdXJyZW50KSA9PSBudWxsIHx8IF9jb250ZW50Q29udGFpbmVyUmVmJC5yZW1vdmUoKTtcbiAgICAgIChfaGVhZGVyQ29udGFpbmVyUmVmJGMgPSBoZWFkZXJDb250YWluZXJSZWYuY3VycmVudCkgPT0gbnVsbCB8fCBfaGVhZGVyQ29udGFpbmVyUmVmJGMucmVtb3ZlKCk7XG4gICAgICBjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgaGVhZGVyQ29udGFpbmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgc2V0SW5mb1dpbmRvdyhudWxsKTtcbiAgICB9O1xuICB9LFxuICAvLyBgaW5mb1dpbmRvd09wdGlvbnNgIGFuZCBvdGhlciBwcm9wcyBhcmUgbWlzc2luZyBmcm9tIGRlcGVuZGVuY2llczpcbiAgLy9cbiAgLy8gV2UgZG9uJ3Qgd2FudCB0byByZS1jcmVhdGUgdGhlIGluZm93aW5kb3cgaW5zdGFuY2VcbiAgLy8gd2hlbiB0aGUgb3B0aW9ucyBjaGFuZ2UuXG4gIC8vIFVwZGF0aW5nIHRoZSBvcHRpb25zIGlzIGhhbmRsZWQgaW4gdGhlIHVzZUVmZmVjdCBiZWxvdy5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbbWFwc0xpYnJhcnldKTtcbiAgLy8gIyMgdXBkYXRlIGNsYXNzTmFtZSBhbmQgc3R5bGVzIGZvciBgY29udGVudENvbnRhaW5lcmBcbiAgLy8gc3RvcmVzIHByZXZpb3VzbHkgYXBwbGllZCBzdHlsZSBwcm9wZXJ0aWVzLCBzbyB0aGV5IGNhbiBiZSByZW1vdmVkIHdoZW4gdW5zZXRcbiAgY29uc3QgcHJldlN0eWxlUmVmID0gdXNlUmVmKG51bGwpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaW5mb1dpbmRvdyB8fCAhY29udGVudENvbnRhaW5lclJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgc2V0VmFsdWVGb3JTdHlsZXMoY29udGVudENvbnRhaW5lclJlZi5jdXJyZW50LCBzdHlsZSB8fCBudWxsLCBwcmV2U3R5bGVSZWYuY3VycmVudCk7XG4gICAgcHJldlN0eWxlUmVmLmN1cnJlbnQgPSBzdHlsZSB8fCBudWxsO1xuICAgIGlmIChjbGFzc05hbWUgIT09IGNvbnRlbnRDb250YWluZXJSZWYuY3VycmVudC5jbGFzc05hbWUpIGNvbnRlbnRDb250YWluZXJSZWYuY3VycmVudC5jbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgJyc7XG4gIH0sIFtpbmZvV2luZG93LCBjbGFzc05hbWUsIHN0eWxlXSk7XG4gIC8vICMjIHVwZGF0ZSBvcHRpb25zXG4gIHVzZURlZXBDb21wYXJlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWluZm9XaW5kb3cpIHJldHVybjtcbiAgICBjb25zdCBvcHRzID0gaW5mb1dpbmRvd09wdGlvbnM7XG4gICAgaWYgKCFwaXhlbE9mZnNldCkge1xuICAgICAgb3B0cy5waXhlbE9mZnNldCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMucGl4ZWxPZmZzZXQgPSBuZXcgZ29vZ2xlLm1hcHMuU2l6ZShwaXhlbE9mZnNldFswXSwgcGl4ZWxPZmZzZXRbMV0pO1xuICAgIH1cbiAgICBpZiAoIWhlYWRlckNvbnRlbnQpIHtcbiAgICAgIG9wdHMuaGVhZGVyQ29udGVudCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMuaGVhZGVyQ29udGVudCA9IHR5cGVvZiBoZWFkZXJDb250ZW50ID09PSAnc3RyaW5nJyA/IGhlYWRlckNvbnRlbnQgOiBoZWFkZXJDb250YWluZXJSZWYuY3VycmVudDtcbiAgICB9XG4gICAgaW5mb1dpbmRvdy5zZXRPcHRpb25zKGluZm9XaW5kb3dPcHRpb25zKTtcbiAgfSxcbiAgLy8gZGVwZW5kZW5jeSBgaW5mb1dpbmRvd2AgaXNuJ3QgbmVlZGVkIHNpbmNlIG9wdGlvbnMgYXJlIGFsc28gcGFzc2VkXG4gIC8vIHRvIHRoZSBjb25zdHJ1Y3RvciB3aGVuIGEgbmV3IGluZm9XaW5kb3cgaXMgY3JlYXRlZC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbaW5mb1dpbmRvd09wdGlvbnMsIHBpeGVsT2Zmc2V0LCBoZWFkZXJDb250ZW50XSk7XG4gIC8vICMjIGJpbmQgZXZlbnQgaGFuZGxlcnNcbiAgdXNlTWFwc0V2ZW50TGlzdGVuZXIoaW5mb1dpbmRvdywgJ2Nsb3NlJywgb25DbG9zZSk7XG4gIHVzZU1hcHNFdmVudExpc3RlbmVyKGluZm9XaW5kb3csICdjbG9zZWNsaWNrJywgb25DbG9zZUNsaWNrKTtcbiAgLy8gIyMgb3BlbiBpbmZvIHdpbmRvdyB3aGVuIGNvbnRlbnQgYW5kIG1hcCBhcmUgYXZhaWxhYmxlXG4gIGNvbnN0IG1hcCA9IHVzZU1hcCgpO1xuICB1c2VEZWVwQ29tcGFyZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gYGFuY2hvciA9PT0gbnVsbGAgbWVhbnMgYW4gYW5jaG9yIGlzIGRlZmluZWQgYnV0IG5vdCByZWFkeSB5ZXQuXG4gICAgaWYgKCFtYXAgfHwgIWluZm9XaW5kb3cgfHwgYW5jaG9yID09PSBudWxsKSByZXR1cm47XG4gICAgY29uc3QgaXNPcGVuZWRXaXRoQW5jaG9yID0gISFhbmNob3I7XG4gICAgY29uc3Qgb3Blbk9wdGlvbnMgPSB7XG4gICAgICBtYXBcbiAgICB9O1xuICAgIGlmIChhbmNob3IpIHtcbiAgICAgIG9wZW5PcHRpb25zLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgIC8vIE9ubHkgZG8gdGhlIGluZm93aW5kb3cgYWRqdXN0aW5nIHdoZW4gZGVhbGluZyB3aXRoIGFuIEFkdmFuY2VkTWFya2VyXG4gICAgICBpZiAoaXNBZHZhbmNlZE1hcmtlcihhbmNob3IpICYmIGFuY2hvci5jb250ZW50IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gYW5jaG9yLmNvbnRlbnQ7XG4gICAgICAgIGNvbnN0IHdyYXBwZXJCY3IgPSB3cmFwcGVyID09IG51bGwgPyB2b2lkIDAgOiB3cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAvLyBUaGlzIGNoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGUgYW5jaG9yIGhhcyBjdXN0b20gY29udGVudCB3aXRoIG91ciBvd25cbiAgICAgICAgLy8gZGl2IHdyYXBwZXIuIElmIG5vdCwgdGhhdCBtZWFucyB3ZSBoYXZlIGEgcmVndWxhciBBZHZhbmNlZE1hcmtlciB3aXRob3V0IGFueSBjaGlsZHJlbi5cbiAgICAgICAgLy8gSW4gdGhhdCBjYXNlIHdlIGRvIG5vdCB3YW50IHRvIGFkanVzdCB0aGUgaW5mb3dpbmRvdyBzaW5jZSBpdCBpcyBhbGwgaGFuZGxlZCBjb3JyZWN0bHlcbiAgICAgICAgLy8gYnkgdGhlIEdvb2dsZSBNYXBzIEFQSS5cbiAgICAgICAgaWYgKHdyYXBwZXJCY3IgJiYgd3JhcHBlciAhPSBudWxsICYmIHdyYXBwZXIuaXNDdXN0b21NYXJrZXIpIHtcbiAgICAgICAgICB2YXIgX2FuY2hvciRjb250ZW50JGZpcnN0O1xuICAgICAgICAgIC8vIFdlIGNhbiBzYWZlbHkgdHlwZWNhc3QgaGVyZSBzaW5jZSB3ZSBjb250cm9sIHRoYXQgZWxlbWVudCBhbmQgd2Uga25vdyB0aGF0XG4gICAgICAgICAgLy8gaXQgaXMgYSBkaXZcbiAgICAgICAgICBjb25zdCBhbmNob3JEb21Db250ZW50ID0gKF9hbmNob3IkY29udGVudCRmaXJzdCA9IGFuY2hvci5jb250ZW50LmZpcnN0RWxlbWVudENoaWxkKSA9PSBudWxsID8gdm9pZCAwIDogX2FuY2hvciRjb250ZW50JGZpcnN0LmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnRCY3IgPSBhbmNob3JEb21Db250ZW50ID09IG51bGwgPyB2b2lkIDAgOiBhbmNob3JEb21Db250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIC8vIGNlbnRlciBpbmZvd2luZG93IGFib3ZlIG1hcmtlclxuICAgICAgICAgIGNvbnN0IGFuY2hvck9mZnNldFggPSBjb250ZW50QmNyLnggLSB3cmFwcGVyQmNyLnggKyAoY29udGVudEJjci53aWR0aCAtIHdyYXBwZXJCY3Iud2lkdGgpIC8gMjtcbiAgICAgICAgICBjb25zdCBhbmNob3JPZmZzZXRZID0gY29udGVudEJjci55IC0gd3JhcHBlckJjci55O1xuICAgICAgICAgIGNvbnN0IG9wdHMgPSBpbmZvV2luZG93T3B0aW9ucztcbiAgICAgICAgICBvcHRzLnBpeGVsT2Zmc2V0ID0gbmV3IGdvb2dsZS5tYXBzLlNpemUocGl4ZWxPZmZzZXQgPyBwaXhlbE9mZnNldFswXSArIGFuY2hvck9mZnNldFggOiBhbmNob3JPZmZzZXRYLCBwaXhlbE9mZnNldCA/IHBpeGVsT2Zmc2V0WzFdICsgYW5jaG9yT2Zmc2V0WSA6IGFuY2hvck9mZnNldFkpO1xuICAgICAgICAgIGluZm9XaW5kb3cuc2V0T3B0aW9ucyhvcHRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2hvdWxkRm9jdXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3Blbk9wdGlvbnMuc2hvdWxkRm9jdXMgPSBzaG91bGRGb2N1cztcbiAgICB9XG4gICAgaW5mb1dpbmRvdy5vcGVuKG9wZW5PcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gTm90ZTogd2hlbiB0aGUgaW5mb3dpbmRvdyBoYXMgYW4gYW5jaG9yLCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgc2hvdyB1cCBhZ2FpbiB3aGVuIHRoZVxuICAgICAgLy8gYW5jaG9yIHdhcyByZW1vdmVkIGZyb20gdGhlIG1hcCBiZWZvcmUgaW5mb1dpbmRvdy5jbG9zZSgpIGlzIGNhbGxlZCBidXQgdGhlIGl0IGdldHNcbiAgICAgIC8vIGFkZGVkIGJhY2sgdG8gdGhlIG1hcCBhZnRlciB0aGF0LlxuICAgICAgLy8gTW9yZSBpbmZvcm1hdGlvbiBoZXJlOiBodHRwczovL2lzc3VldHJhY2tlci5nb29nbGUuY29tL2lzc3Vlcy8zNDM3NTA4NDlcbiAgICAgIGlmIChpc09wZW5lZFdpdGhBbmNob3IpIGluZm9XaW5kb3cuc2V0KCdhbmNob3InLCBudWxsKTtcbiAgICAgIGluZm9XaW5kb3cuY2xvc2UoKTtcbiAgICB9O1xuICB9LCBbaW5mb1dpbmRvdywgYW5jaG9yLCBtYXAsIHNob3VsZEZvY3VzLCBpbmZvV2luZG93T3B0aW9ucywgcGl4ZWxPZmZzZXRdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQgJiYgY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQpLCBoZWFkZXJDb250YWluZXJSZWYuY3VycmVudCAhPT0gbnVsbCAmJiBjcmVhdGVQb3J0YWwoaGVhZGVyQ29udGVudCwgaGVhZGVyQ29udGFpbmVyUmVmLmN1cnJlbnQpKTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyBhIGxvY2F0aW9uIGludG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gc3VpdGFibGUgZm9yIEdvb2dsZSBTdGF0aWMgTWFwcyBBUEkuXG4gKlxuICogQHBhcmFtIGxvY2F0aW9uIC0gVGhlIGxvY2F0aW9uIHRvIGZvcm1hdCwgY2FuIGJlIGVpdGhlciBhIHN0cmluZyBvciBhbiBvYmplY3Qgd2l0aCBsYXQvbG5nIHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsb2NhdGlvbiBpbiB0aGUgZm9ybWF0IFwibGF0LGxuZ1wiIG9yIHRoZSBvcmlnaW5hbCBzdHJpbmdcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUmV0dXJucyBcIjQwLjcxNDcyOCwtNzMuOTk4NjcyXCJcbiAqIGZvcm1hdExvY2F0aW9uKHsgbGF0OiA0MC43MTQ3MjgsIGxuZzogLTczLjk5ODY3MiB9KVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXR1cm5zIFwiTmV3IFlvcmssIE5ZXCJcbiAqIGZvcm1hdExvY2F0aW9uKFwiTmV3IFlvcmssIE5ZXCIpXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnID8gbG9jYXRpb24gOiBgJHtsb2NhdGlvbi5sYXR9LCR7bG9jYXRpb24ubG5nfWA7XG59XG4vLyBVc2VkIGZvciByZW1vdmluZyB0aGUgbGVhZGluZyBwaXBlIGZyb20gdGhlIHBhcmFtIHN0cmluZ1xuZnVuY3Rpb24gZm9ybWF0UGFyYW0oc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuc2xpY2UoMSk7XG59XG5cbi8qKlxuICogQXNzZW1ibGVzIG1hcmtlciBwYXJhbWV0ZXJzIGZvciBzdGF0aWMgbWFwcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGFycmF5IG9mIG1hcmtlcnMgYW5kIGdyb3VwcyB0aGVtIGJ5IHRoZWlyIHN0eWxlIHByb3BlcnRpZXMuXG4gKiBJdCB0aGVuIGNyZWF0ZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlc2UgbWFya2VycywgaW5jbHVkaW5nIHRoZWlyIHN0eWxlcyBhbmQgbG9jYXRpb25zLFxuICogd2hpY2ggY2FuIGJlIHVzZWQgYXMgcGFyYW1ldGVycyBmb3Igc3RhdGljIG1hcCBBUElzLlxuICpcbiAqIEBwYXJhbSB7U3RhdGljTWFwc01hcmtlcltdfSBbbWFya2Vycz1bXV0gLSBBbiBhcnJheSBvZiBtYXJrZXJzIHRvIGJlIHByb2Nlc3NlZC4gRWFjaCBtYXJrZXIgY2FuIGhhdmUgcHJvcGVydGllcyBzdWNoIGFzIGNvbG9yLCBsYWJlbCwgc2l6ZSwgc2NhbGUsIGljb24sIGFuY2hvciwgYW5kIGxvY2F0aW9uLlxuICogQHJldHVybnMge3N0cmluZ1tdfSBBbiBhcnJheSBvZiBzdHJpbmdzLCBlYWNoIHJlcHJlc2VudGluZyBhIGdyb3VwIG9mIG1hcmtlcnMgd2l0aCB0aGVpciBzdHlsZXMgYW5kIGxvY2F0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbWFya2VycyA9IFtcbiAqICAgeyBjb2xvcjogJ2JsdWUnLCBsYWJlbDogJ0EnLCBzaXplOiAnbWlkJywgbG9jYXRpb246ICc0MC43MTQ3MjgsLTczLjk5ODY3MicgfSxcbiAqICAgeyBjb2xvcjogJ2JsdWUnLCBsYWJlbDogJ0InLCBzaXplOiAnbWlkJywgbG9jYXRpb246ICc0MC43MTQ3MjgsLTczLjk5ODY3MicgfSxcbiAqICAgeyBpY29uOiAnaHR0cDovL2V4YW1wbGUuY29tL2ljb24ucG5nJywgbG9jYXRpb246IHsgbGF0OiA0MC43MTQ3MjgsIGxuZzogLTczLjk5ODY3MiB9IH1cbiAqIF07XG4gKiBjb25zdCBwYXJhbXMgPSBhc3NlbWJsZU1hcmtlclBhcmFtcyhtYXJrZXJzKTtcbiAqIC8vIFBhcmFtcyB3aWxsIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBtYXJrZXIgcGFyYW1ldGVyc1xuICogRXhhbXBsZSBvdXRwdXQ6IFtcbiAqICAgXCJjb2xvcjpibHVlfGxhYmVsOkF8c2l6ZTptaWR8NDAuNzE0NzI4LC03My45OTg2NzJ8NDAuNzE0NzI4LC03My45OTg2NzJcIixcbiAqICAgXCJjb2xvcjpibHVlfGxhYmVsOkJ8c2l6ZTptaWR8NDAuNzE0NzI4LC03My45OTg2NzJ8NDAuNzE0NzI4LC03My45OTg2NzJcIixcbiAqICAgXCJpY29uOmh0dHA6Ly9leGFtcGxlLmNvbS9pY29uLnBuZ3w0MC43MTQ3MjgsLTczLjk5ODY3MlwiXG4gKiBdXG4gKi9cbmZ1bmN0aW9uIGFzc2VtYmxlTWFya2VyUGFyYW1zKG1hcmtlcnMgPSBbXSkge1xuICBjb25zdCBtYXJrZXJQYXJhbXMgPSBbXTtcbiAgLy8gR3JvdXAgbWFya2VycyBieSBzdHlsZVxuICBjb25zdCBtYXJrZXJzQnlTdHlsZSA9IG1hcmtlcnMgPT0gbnVsbCA/IHZvaWQgMCA6IG1hcmtlcnMucmVkdWNlKChzdHlsZXMsIG1hcmtlcikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbG9yID0gJ3JlZCcsXG4gICAgICBsYWJlbCxcbiAgICAgIHNpemUsXG4gICAgICBzY2FsZSxcbiAgICAgIGljb24sXG4gICAgICBhbmNob3JcbiAgICB9ID0gbWFya2VyO1xuICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBzdHlsZSBrZXkgYmFzZWQgb24gZWl0aGVyIGljb24gcHJvcGVydGllcyBvciBzdGFuZGFyZCBtYXJrZXIgcHJvcGVydGllc1xuICAgIGNvbnN0IHJlbGV2YW50UHJvcHMgPSBpY29uID8gW2ljb24sIGFuY2hvciwgc2NhbGVdIDogW2NvbG9yLCBsYWJlbCwgc2l6ZV07XG4gICAgY29uc3Qga2V5ID0gcmVsZXZhbnRQcm9wcy5maWx0ZXIoQm9vbGVhbikuam9pbignLScpO1xuICAgIHN0eWxlc1trZXldID0gc3R5bGVzW2tleV0gfHwgW107XG4gICAgc3R5bGVzW2tleV0ucHVzaChtYXJrZXIpO1xuICAgIHJldHVybiBzdHlsZXM7XG4gIH0sIHt9KTtcbiAgT2JqZWN0LnZhbHVlcyhtYXJrZXJzQnlTdHlsZSAhPSBudWxsID8gbWFya2Vyc0J5U3R5bGUgOiB7fSkuZm9yRWFjaChtYXJrZXJzID0+IHtcbiAgICBsZXQgbWFya2VyUGFyYW0gPSAnJztcbiAgICBjb25zdCB7XG4gICAgICBpY29uXG4gICAgfSA9IG1hcmtlcnNbMF07XG4gICAgLy8gQ3JlYXRlIG1hcmtlciBzdHlsZSBmcm9tIGZpcnN0IG1hcmtlciBpbiBncm91cCBzaW5jZSBhbGwgbWFya2VycyBzaGFyZSB0aGUgc2FtZSBzdHlsZS5cbiAgICBPYmplY3QuZW50cmllcyhtYXJrZXJzWzBdKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgYmFzZWQgb24gd2hldGhlciBtYXJrZXIgdXNlcyBjdXN0b20gaWNvblxuICAgICAgY29uc3QgcmVsZXZhbnRLZXlzID0gaWNvbiA/IFsnaWNvbicsICdhbmNob3InLCAnc2NhbGUnXSA6IFsnY29sb3InLCAnbGFiZWwnLCAnc2l6ZSddO1xuICAgICAgaWYgKHJlbGV2YW50S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIG1hcmtlclBhcmFtICs9IGB8JHtrZXl9OiR7dmFsdWV9YDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBBZGQgbG9jYXRpb24gY29vcmRpbmF0ZXMgZm9yIGVhY2ggbWFya2VyIGluIHRoZSBzdHlsZSBncm91cFxuICAgIC8vIEhhbmRsZXMgYm90aCBzdHJpbmcgbG9jYXRpb25zIGFuZCBsYXQvbG5nIG9iamVjdCBmb3JtYXRzLlxuICAgIGZvciAoY29uc3QgbWFya2VyIG9mIG1hcmtlcnMpIHtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gdHlwZW9mIG1hcmtlci5sb2NhdGlvbiA9PT0gJ3N0cmluZycgPyBtYXJrZXIubG9jYXRpb24gOiBgJHttYXJrZXIubG9jYXRpb24ubGF0fSwke21hcmtlci5sb2NhdGlvbi5sbmd9YDtcbiAgICAgIG1hcmtlclBhcmFtICs9IGB8JHtsb2NhdGlvbn1gO1xuICAgIH1cbiAgICBtYXJrZXJQYXJhbXMucHVzaChtYXJrZXJQYXJhbSk7XG4gIH0pO1xuICByZXR1cm4gbWFya2VyUGFyYW1zLm1hcChmb3JtYXRQYXJhbSk7XG59XG5cbi8qKlxuICogQXNzZW1ibGVzIHBhdGggcGFyYW1ldGVycyBmb3IgdGhlIFN0YXRpYyBNYXBzIEFwaSBmcm9tIGFuIGFycmF5IG9mIHBhdGhzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZ3JvdXBzIHBhdGhzIGJ5IHRoZWlyIHN0eWxlIHByb3BlcnRpZXMgKGNvbG9yLCB3ZWlnaHQsIGZpbGxjb2xvciwgZ2VvZGVzaWMpXG4gKiBhbmQgdGhlbiBjb25zdHJ1Y3RzIGEgc3RyaW5nIG9mIHBhdGggcGFyYW1ldGVycyBmb3IgZWFjaCBncm91cC4gRWFjaCBwYXRoIHBhcmFtZXRlciBzdHJpbmdcbiAqIGluY2x1ZGVzIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIGFuZCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBhdGhzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8U3RhdGljTWFwc1BhdGg+fSBbcGF0aHM9W11dIC0gQW4gYXJyYXkgb2YgcGF0aHMgdG8gYmUgYXNzZW1ibGVkIGludG8gcGF0aCBwYXJhbWV0ZXJzLlxuICogQHJldHVybnMge0FycmF5PHN0cmluZz59IEFuIGFycmF5IG9mIHBhdGggcGFyYW1ldGVyIHN0cmluZ3MuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHBhdGhzID0gW1xuICogICB7XG4gKiAgICAgY29sb3I6ICdyZWQnLFxuICogICAgIHdlaWdodDogNSxcbiAqICAgICBjb29yZGluYXRlczogW1xuICogICAgICAgeyBsYXQ6IDQwLjcxNDcyOCwgbG5nOiAtNzMuOTk4NjcyIH0sXG4gKiAgICAgICB7IGxhdDogNDAuNzE4MjE3LCBsbmc6IC03My45OTgyODQgfVxuICogICAgIF1cbiAqICAgfVxuICogXTtcbiAqXG4gKiBjb25zdCBwYXRoUGFyYW1zID0gYXNzZW1ibGVQYXRoUGFyYW1zKHBhdGhzKTtcbiAqIE91dHB1dDogW1xuICogICAgJ2NvbG9yOnJlZHx3ZWlnaHQ6NXw0MC43MTQ3MjgsLTczLjk5ODY3Mnw0MC43MTgyMTcsLTczLjk5ODI4NCdcbiAqICBdXG4gKi9cbmZ1bmN0aW9uIGFzc2VtYmxlUGF0aFBhcmFtcyhwYXRocyA9IFtdKSB7XG4gIGNvbnN0IHBhdGhQYXJhbXMgPSBbXTtcbiAgLy8gR3JvdXAgcGF0aHMgYnkgdGhlaXIgc3R5bGUgcHJvcGVydGllcyAoY29sb3IsIHdlaWdodCwgZmlsbGNvbG9yLCBnZW9kZXNpYylcbiAgLy8gdG8gY29tYmluZSBwYXRocyB3aXRoIGlkZW50aWNhbCBzdHlsZXMgaW50byBzaW5nbGUgcGFyYW1ldGVyIHN0cmluZ3NcbiAgY29uc3QgcGF0aHNCeVN0eWxlID0gcGF0aHMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhdGhzLnJlZHVjZSgoc3R5bGVzLCBwYXRoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY29sb3IgPSAnZGVmYXVsdCcsXG4gICAgICB3ZWlnaHQsXG4gICAgICBmaWxsY29sb3IsXG4gICAgICBnZW9kZXNpY1xuICAgIH0gPSBwYXRoO1xuICAgIC8vIENyZWF0ZSB1bmlxdWUga2V5IGZvciB0aGlzIHN0eWxlIGNvbWJpbmF0aW9uXG4gICAgY29uc3Qga2V5ID0gW2NvbG9yLCB3ZWlnaHQsIGZpbGxjb2xvciwgZ2VvZGVzaWNdLmZpbHRlcihCb29sZWFuKS5qb2luKCctJyk7XG4gICAgc3R5bGVzW2tleV0gPSBzdHlsZXNba2V5XSB8fCBbXTtcbiAgICBzdHlsZXNba2V5XS5wdXNoKHBhdGgpO1xuICAgIHJldHVybiBzdHlsZXM7XG4gIH0sIHt9KTtcbiAgLy8gUHJvY2VzcyBlYWNoIGdyb3VwIG9mIHBhdGhzIHdpdGggaWRlbnRpY2FsIHN0eWxlc1xuICBPYmplY3QudmFsdWVzKHBhdGhzQnlTdHlsZSAhPSBudWxsID8gcGF0aHNCeVN0eWxlIDoge30pLmZvckVhY2gocGF0aHMgPT4ge1xuICAgIGxldCBwYXRoUGFyYW0gPSAnJztcbiAgICAvLyBCdWlsZCBzdHlsZSBwYXJhbWV0ZXIgc3RyaW5nIHVzaW5nIHByb3BlcnRpZXMgZnJvbSBmaXJzdCBwYXRoIGluIGdyb3VwXG4gICAgLy8gc2luY2UgYWxsIHBhdGhzIGluIHRoaXMgZ3JvdXAgc2hhcmUgdGhlIHNhbWUgc3R5bGVcbiAgICBPYmplY3QuZW50cmllcyhwYXRoc1swXSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAoWydjb2xvcicsICd3ZWlnaHQnLCAnZmlsbGNvbG9yJywgJ2dlb2Rlc2ljJ10uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICBwYXRoUGFyYW0gKz0gYHwke2tleX06JHt2YWx1ZX1gO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEFkZCBsb2NhdGlvbiBmb3IgYWxsIG1hcmtlciBpbiBzdHlsZSBncm91cFxuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoLmNvb3JkaW5hdGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXRoUGFyYW0gKz0gYHwke2RlY29kZVVSSUNvbXBvbmVudChwYXRoLmNvb3JkaW5hdGVzKX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBsb2NhdGlvbiBvZiBwYXRoLmNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgcGF0aFBhcmFtICs9IGB8JHtmb3JtYXRMb2NhdGlvbihsb2NhdGlvbil9YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwYXRoUGFyYW1zLnB1c2gocGF0aFBhcmFtKTtcbiAgfSk7XG4gIHJldHVybiBwYXRoUGFyYW1zLm1hcChmb3JtYXRQYXJhbSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gYXJyYXkgb2YgR29vZ2xlIE1hcHMgc3R5bGUgb2JqZWN0cyBpbnRvIGFuIGFycmF5IG9mIHN0eWxlIHN0cmluZ3NcbiAqIGNvbXBhdGlibGUgd2l0aCB0aGUgR29vZ2xlIFN0YXRpYyBNYXBzIEFQSS5cbiAqXG4gKiBAcGFyYW0gc3R5bGVzIC0gQW4gYXJyYXkgb2YgR29vZ2xlIE1hcHMgTWFwVHlwZVN0eWxlIG9iamVjdHMgdGhhdCBkZWZpbmUgdGhlIHN0eWxpbmcgcnVsZXNcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGZvcm1hdHRlZCBzdHlsZSBzdHJpbmdzIHJlYWR5IHRvIGJlIHVzZWQgd2l0aCB0aGUgU3RhdGljIE1hcHMgQVBJXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHN0eWxlcyA9IFt7XG4gKiAgIGZlYXR1cmVUeXBlOiBcInJvYWRcIixcbiAqICAgZWxlbWVudFR5cGU6IFwiZ2VvbWV0cnlcIixcbiAqICAgc3R5bGVyczogW3tjb2xvcjogXCIjZmYwMDAwXCJ9LCB7d2VpZ2h0OiAxfV1cbiAqIH1dO1xuICpcbiAqIGNvbnN0IHN0eWxlU3RyaW5ncyA9IGFzc2VtYmxlTWFwVHlwZVN0eWxlcyhzdHlsZXMpO1xuICogLy8gUmV0dXJuczogW1wifGZlYXR1cmU6cm9hZHxlbGVtZW50Omdlb21ldHJ5fGNvbG9yOjB4ZmYwMDAwfHdlaWdodDoxXCJdXG4gKlxuICogRWFjaCBzdHlsZSBzdHJpbmcgZm9sbG93cyB0aGUgZm9ybWF0OlxuICogXCJmZWF0dXJlOntmZWF0dXJlVHlwZX18ZWxlbWVudDp7ZWxlbWVudFR5cGV9fHtzdHlsZXJOYW1lfTp7c3R5bGVyVmFsdWV9XCJcbiAqXG4gKiBOb3RlOiBDb2xvciB2YWx1ZXMgd2l0aCBoZXhhZGVjaW1hbCBub3RhdGlvbiAoIykgYXJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkXG4gKiB0byB0aGUgcmVxdWlyZWQgMHggZm9ybWF0IGZvciB0aGUgU3RhdGljIE1hcHMgQVBJLlxuICovXG5mdW5jdGlvbiBhc3NlbWJsZU1hcFR5cGVTdHlsZXMoc3R5bGVzKSB7XG4gIHJldHVybiBzdHlsZXMubWFwKG1hcFR5cGVTdHlsZSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZmVhdHVyZVR5cGUsXG4gICAgICBlbGVtZW50VHlwZSxcbiAgICAgIHN0eWxlcnMgPSBbXVxuICAgIH0gPSBtYXBUeXBlU3R5bGU7XG4gICAgbGV0IHN0eWxlU3RyaW5nID0gJyc7XG4gICAgaWYgKGZlYXR1cmVUeXBlKSB7XG4gICAgICBzdHlsZVN0cmluZyArPSBgfGZlYXR1cmU6JHtmZWF0dXJlVHlwZX1gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudFR5cGUpIHtcbiAgICAgIHN0eWxlU3RyaW5nICs9IGB8ZWxlbWVudDoke2VsZW1lbnRUeXBlfWA7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc3R5bGVyIG9mIHN0eWxlcnMpIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHN0eWxlcikuZm9yRWFjaCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgICAgICBzdHlsZVN0cmluZyArPSBgfCR7bmFtZX06JHtTdHJpbmcodmFsdWUpLnJlcGxhY2UoJyMnLCAnMHgnKX1gO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZVN0cmluZztcbiAgfSkubWFwKGZvcm1hdFBhcmFtKTtcbn1cblxuY29uc3QgU1RBVElDX01BUFNfQkFTRSA9ICdodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvc3RhdGljbWFwJztcbi8qKlxuICogQ3JlYXRlcyBhIFVSTCBmb3IgdGhlIEdvb2dsZSBTdGF0aWMgTWFwcyBBUEkgd2l0aCB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgc3RhdGljIG1hcFxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYXBpS2V5IC0gWW91ciBHb29nbGUgTWFwcyBBUEkga2V5IChyZXF1aXJlZClcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLndpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBtYXAgaW1hZ2UgaW4gcGl4ZWxzIChyZXF1aXJlZClcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIG1hcCBpbWFnZSBpbiBwaXhlbHMgKHJlcXVpcmVkKVxuICogQHBhcmFtIHtTdGF0aWNNYXBzTG9jYXRpb259IFtvcHRpb25zLmNlbnRlcl0gLSBUaGUgY2VudGVyIHBvaW50IG9mIHRoZSBtYXAgKGxhdC9sbmcgb3IgYWRkcmVzcykuXG4gKiAgUmVxdWlyZWQgaWYgbm8gbWFya2VycyBvciBwYXRocyBvciBcInZpc2libGUgbG9jYXRpb25zXCIgYXJlIHByb3ZpZGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnpvb21dIC0gVGhlIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC4gUmVxdWlyZWQgaWYgbm8gbWFya2VycyBvciBwYXRocyBvciBcInZpc2libGUgbG9jYXRpb25zXCIgYXJlIHByb3ZpZGVkLlxuICogQHBhcmFtIHsxfDJ8NH0gW29wdGlvbnMuc2NhbGVdIC0gVGhlIHJlc29sdXRpb24gb2YgdGhlIG1hcCAoMSwgMiwgb3IgNClcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mb3JtYXRdIC0gVGhlIGltYWdlIGZvcm1hdCAocG5nLCBwbmc4LCBwbmczMiwgZ2lmLCBqcGcsIGpwZy1iYXNlbGluZSlcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5tYXBUeXBlXSAtIFRoZSB0eXBlIG9mIG1hcCAocm9hZG1hcCwgc2F0ZWxsaXRlLCB0ZXJyYWluLCBoeWJyaWQpXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2VdIC0gVGhlIGxhbmd1YWdlIG9mIHRoZSBtYXAgbGFiZWxzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucmVnaW9uXSAtIFRoZSByZWdpb24gY29kZSBmb3IgdGhlIG1hcFxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcF9pZF0gLSBUaGUgQ2xvdWQtYmFzZWQgbWFwIHN0eWxlIElEXG4gKiBAcGFyYW0ge1N0YXRpY01hcHNNYXJrZXJbXX0gW29wdGlvbnMubWFya2Vycz1bXV0gLSBBcnJheSBvZiBtYXJrZXJzIHRvIGRpc3BsYXkgb24gdGhlIG1hcFxuICogQHBhcmFtIHtTdGF0aWNNYXBzUGF0aFtdfSBbb3B0aW9ucy5wYXRocz1bXV0gLSBBcnJheSBvZiBwYXRocyB0byBkaXNwbGF5IG9uIHRoZSBtYXBcbiAqIEBwYXJhbSB7U3RhdGljTWFwc0xvY2F0aW9uW119IFtvcHRpb25zLnZpc2libGU9W11dIC0gQXJyYXkgb2YgbG9jYXRpb25zIHRoYXQgc2hvdWxkIGJlIHZpc2libGUgb24gdGhlIG1hcFxuICogQHBhcmFtIHtNYXBUeXBlU3R5bGVbXX0gW29wdGlvbnMuc3R5bGU9W11dIC0gQXJyYXkgb2Ygc3R5bGUgb2JqZWN0cyB0byBjdXN0b21pemUgdGhlIG1hcCBhcHBlYXJhbmNlXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbXBsZXRlIEdvb2dsZSBTdGF0aWMgTWFwcyBBUEkgVVJMXG4gKlxuICogQHRocm93cyB7RXJyb3J9IElmIEFQSSBrZXkgaXMgbm90IHByb3ZpZGVkXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgd2lkdGggb3IgaGVpZ2h0IGlzIG5vdCBwcm92aWRlZFxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCB1cmwgPSBjcmVhdGVTdGF0aWNNYXBzVXJsKHtcbiAqICAgYXBpS2V5OiAnWU9VUl9BUElfS0VZJyxcbiAqICAgd2lkdGg6IDYwMCxcbiAqICAgaGVpZ2h0OiA0MDAsXG4gKiAgIGNlbnRlcjogeyBsYXQ6IDQwLjcxNDcyOCwgbG5nOiAtNzMuOTk4NjcyIH0sXG4gKiAgIHpvb206IDEyLFxuICogICBtYXJrZXJzOiBbXG4gKiAgICAge1xuICogICAgICAgbG9jYXRpb246IHsgbGF0OiA0MC43MTQ3MjgsIGxuZzogLTczLjk5ODY3MiB9LFxuICogICAgICAgY29sb3I6ICdyZWQnLFxuICogICAgICAgbGFiZWw6ICdBJ1xuICogICAgIH1cbiAqICAgXSxcbiAqICAgcGF0aHM6IFtcbiAqICAgICB7XG4gKiAgICAgICBjb29yZGluYXRlczogW1xuICogICAgICAgICB7IGxhdDogNDAuNzE0NzI4LCBsbmc6IC03My45OTg2NzIgfSxcbiAqICAgICAgICAgeyBsYXQ6IDQwLjcxOTcyOCwgbG5nOiAtNzMuOTkxNjcyIH1cbiAqICAgICAgIF0sXG4gKiAgICAgICBjb2xvcjogJzB4MDAwMGZmJyxcbiAqICAgICAgIHdlaWdodDogNVxuICogICAgIH1cbiAqICAgXSxcbiAqICAgc3R5bGU6IFtcbiAqICAgICB7XG4gKiAgICAgICBmZWF0dXJlVHlwZTogJ3JvYWQnLFxuICogICAgICAgZWxlbWVudFR5cGU6ICdnZW9tZXRyeScsXG4gKiAgICAgICBzdHlsZXJzOiBbe2NvbG9yOiAnIzAwZmYwMCd9XVxuICogICAgIH1cbiAqICAgXVxuICogfSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbiBVUkwgc2ltaWxhciB0bzpcbiAqIC8vIGh0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9zdGF0aWNtYXA/a2V5PVlPVVJfQVBJX0tFWVxuICogLy8gJnNpemU9NjAweDQwMFxuICogLy8gJmNlbnRlcj00MC43MTQ3MjgsLTczLjk5ODY3MiZ6b29tPTEyXG4gKiAvLyAmbWFya2Vycz1jb2xvcjpyZWR8bGFiZWw6QXw0MC43MTQ3MjgsLTczLjk5ODY3MlxuICogLy8gJnBhdGg9Y29sb3I6MHgwMDAwZmZ8d2VpZ2h0OjV8NDAuNzE0NzI4LC03My45OTg2NzJ8NDAuNzE5NzI4LC03My45OTE2NzJcbiAqIC8vICZzdHlsZT1mZWF0dXJlOnJvYWR8ZWxlbWVudDpnZW9tZXRyeXxjb2xvcjoweDAwZmYwMFxuICovXG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNNYXBzVXJsKHtcbiAgYXBpS2V5LFxuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBjZW50ZXIsXG4gIHpvb20sXG4gIHNjYWxlLFxuICBmb3JtYXQsXG4gIG1hcFR5cGUsXG4gIGxhbmd1YWdlLFxuICByZWdpb24sXG4gIG1hcElkLFxuICBtYXJrZXJzID0gW10sXG4gIHBhdGhzID0gW10sXG4gIHZpc2libGUgPSBbXSxcbiAgc3R5bGUgPSBbXVxufSkge1xuICBpZiAoIWFwaUtleSkge1xuICAgIGNvbnNvbGUud2FybignQVBJIGtleSBpcyByZXF1aXJlZCcpO1xuICB9XG4gIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xuICAgIGNvbnNvbGUud2FybignV2lkdGggYW5kIGhlaWdodCBhcmUgcmVxdWlyZWQnKTtcbiAgfVxuICBjb25zdCBwYXJhbXMgPSBfZXh0ZW5kcyh7XG4gICAga2V5OiBhcGlLZXksXG4gICAgc2l6ZTogYCR7d2lkdGh9eCR7aGVpZ2h0fWBcbiAgfSwgY2VudGVyICYmIHtcbiAgICBjZW50ZXI6IGZvcm1hdExvY2F0aW9uKGNlbnRlcilcbiAgfSwgem9vbSAmJiB7XG4gICAgem9vbVxuICB9LCBzY2FsZSAmJiB7XG4gICAgc2NhbGVcbiAgfSwgZm9ybWF0ICYmIHtcbiAgICBmb3JtYXRcbiAgfSwgbWFwVHlwZSAmJiB7XG4gICAgbWFwdHlwZTogbWFwVHlwZVxuICB9LCBsYW5ndWFnZSAmJiB7XG4gICAgbGFuZ3VhZ2VcbiAgfSwgcmVnaW9uICYmIHtcbiAgICByZWdpb25cbiAgfSwgbWFwSWQgJiYge1xuICAgIG1hcF9pZDogbWFwSWRcbiAgfSk7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoU1RBVElDX01BUFNfQkFTRSk7XG4gIC8vIFBhcmFtcyB0aGF0IGRvbid0IG5lZWQgc3BlY2lhbCBoYW5kbGluZ1xuICBPYmplY3QuZW50cmllcyhwYXJhbXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgU3RyaW5nKHZhbHVlKSk7XG4gIH0pO1xuICAvLyBBc3NlbWJsZSBNYXJrZXJzXG4gIGZvciAoY29uc3QgbWFya2VyUGFyYW0gb2YgYXNzZW1ibGVNYXJrZXJQYXJhbXMobWFya2VycykpIHtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnbWFya2VycycsIG1hcmtlclBhcmFtKTtcbiAgfVxuICAvLyBBc3NlbWJsZSBQYXRoc1xuICBmb3IgKGNvbnN0IHBhdGhQYXJhbSBvZiBhc3NlbWJsZVBhdGhQYXJhbXMocGF0aHMpKSB7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ3BhdGgnLCBwYXRoUGFyYW0pO1xuICB9XG4gIC8vIEFzc2VtYmxlIHZpc2libGUgbG9jYXRpb25zXG4gIGlmICh2aXNpYmxlLmxlbmd0aCkge1xuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCd2aXNpYmxlJywgdmlzaWJsZS5tYXAobG9jYXRpb24gPT4gZm9ybWF0TG9jYXRpb24obG9jYXRpb24pKS5qb2luKCd8JykpO1xuICB9XG4gIC8vIEFzc2VtYmxlIE1hcCBUeXBlIFN0eWxlc1xuICBmb3IgKGNvbnN0IHN0eWxlU3RyaW5nIG9mIGFzc2VtYmxlTWFwVHlwZVN0eWxlcyhzdHlsZSkpIHtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnc3R5bGUnLCBzdHlsZVN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIHVybC50b1N0cmluZygpO1xufVxuXG5jb25zdCBTdGF0aWNNYXAgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IHtcbiAgICB1cmwsXG4gICAgY2xhc3NOYW1lXG4gIH0gPSBwcm9wcztcbiAgaWYgKCF1cmwpIHRocm93IG5ldyBFcnJvcignVVJMIGlzIHJlcXVpcmVkJyk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImltZ1wiLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgc3JjOiB1cmwsXG4gICAgd2lkdGg6IFwiMTAwJVwiXG4gIH0pO1xufTtcblxuLyoqXG4gKiBDb3B5IG9mIHRoZSBgZ29vZ2xlLm1hcHMuQ29udHJvbFBvc2l0aW9uYCBjb25zdGFudHMuXG4gKiBUaGV5IGhhdmUgdG8gYmUgZHVwbGljYXRlZCBoZXJlIHNpbmNlIHdlIGNhbid0IHdhaXQgZm9yIHRoZSBtYXBzIEFQSSB0byBsb2FkIHRvIGJlIGFibGUgdG8gdXNlIHRoZW0uXG4gKi9cbmNvbnN0IENvbnRyb2xQb3NpdGlvbiA9IHtcbiAgVE9QX0xFRlQ6IDEsXG4gIFRPUF9DRU5URVI6IDIsXG4gIFRPUDogMixcbiAgVE9QX1JJR0hUOiAzLFxuICBMRUZUX0NFTlRFUjogNCxcbiAgTEVGVF9UT1A6IDUsXG4gIExFRlQ6IDUsXG4gIExFRlRfQk9UVE9NOiA2LFxuICBSSUdIVF9UT1A6IDcsXG4gIFJJR0hUOiA3LFxuICBSSUdIVF9DRU5URVI6IDgsXG4gIFJJR0hUX0JPVFRPTTogOSxcbiAgQk9UVE9NX0xFRlQ6IDEwLFxuICBCT1RUT01fQ0VOVEVSOiAxMSxcbiAgQk9UVE9NOiAxMSxcbiAgQk9UVE9NX1JJR0hUOiAxMixcbiAgQ0VOVEVSOiAxMyxcbiAgQkxPQ0tfU1RBUlRfSU5MSU5FX1NUQVJUOiAxNCxcbiAgQkxPQ0tfU1RBUlRfSU5MSU5FX0NFTlRFUjogMTUsXG4gIEJMT0NLX1NUQVJUX0lOTElORV9FTkQ6IDE2LFxuICBJTkxJTkVfU1RBUlRfQkxPQ0tfQ0VOVEVSOiAxNyxcbiAgSU5MSU5FX1NUQVJUX0JMT0NLX1NUQVJUOiAxOCxcbiAgSU5MSU5FX1NUQVJUX0JMT0NLX0VORDogMTksXG4gIElOTElORV9FTkRfQkxPQ0tfU1RBUlQ6IDIwLFxuICBJTkxJTkVfRU5EX0JMT0NLX0NFTlRFUjogMjEsXG4gIElOTElORV9FTkRfQkxPQ0tfRU5EOiAyMixcbiAgQkxPQ0tfRU5EX0lOTElORV9TVEFSVDogMjMsXG4gIEJMT0NLX0VORF9JTkxJTkVfQ0VOVEVSOiAyNCxcbiAgQkxPQ0tfRU5EX0lOTElORV9FTkQ6IDI1XG59O1xuY29uc3QgTWFwQ29udHJvbCA9ICh7XG4gIGNoaWxkcmVuLFxuICBwb3NpdGlvblxufSkgPT4ge1xuICBjb25zdCBjb250cm9sQ29udGFpbmVyID0gdXNlTWVtbygoKSA9PiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgW10pO1xuICBjb25zdCBtYXAgPSB1c2VNYXAoKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1hcCkgcmV0dXJuO1xuICAgIGNvbnN0IGNvbnRyb2xzID0gbWFwLmNvbnRyb2xzW3Bvc2l0aW9uXTtcbiAgICBjb250cm9scy5wdXNoKGNvbnRyb2xDb250YWluZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBjb250cm9sc0FycmF5ID0gY29udHJvbHMuZ2V0QXJyYXkoKTtcbiAgICAgIC8vIGNvbnRyb2xzQXJyYXkgY291bGQgYmUgdW5kZWZpbmVkIGlmIHRoZSBtYXAgaXMgaW4gYW4gdW5kZWZpbmVkIHN0YXRlIChlLmcuIGludmFsaWQgQVBJLWtleSwgc2VlICMyNzZcbiAgICAgIGlmICghY29udHJvbHNBcnJheSkgcmV0dXJuO1xuICAgICAgY29uc3QgaW5kZXggPSBjb250cm9sc0FycmF5LmluZGV4T2YoY29udHJvbENvbnRhaW5lcik7XG4gICAgICBjb250cm9scy5yZW1vdmVBdChpbmRleCk7XG4gICAgfTtcbiAgfSwgW2NvbnRyb2xDb250YWluZXIsIG1hcCwgcG9zaXRpb25dKTtcbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udHJvbENvbnRhaW5lcik7XG59O1xuXG5jb25zdCBfZXhjbHVkZWQgPSBbXCJvbkNsaWNrXCIsIFwib25EcmFnXCIsIFwib25EcmFnU3RhcnRcIiwgXCJvbkRyYWdFbmRcIiwgXCJvbk1vdXNlT3ZlclwiLCBcIm9uTW91c2VPdXRcIl07XG5mdW5jdGlvbiB1c2VNYXJrZXIocHJvcHMpIHtcbiAgY29uc3QgW21hcmtlciwgc2V0TWFya2VyXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBtYXAgPSB1c2VNYXAoKTtcbiAgY29uc3Qge1xuICAgICAgb25DbGljayxcbiAgICAgIG9uRHJhZyxcbiAgICAgIG9uRHJhZ1N0YXJ0LFxuICAgICAgb25EcmFnRW5kLFxuICAgICAgb25Nb3VzZU92ZXIsXG4gICAgICBvbk1vdXNlT3V0XG4gICAgfSA9IHByb3BzLFxuICAgIG1hcmtlck9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkKTtcbiAgY29uc3Qge1xuICAgIHBvc2l0aW9uLFxuICAgIGRyYWdnYWJsZVxuICB9ID0gbWFya2VyT3B0aW9ucztcbiAgLy8gY3JlYXRlIG1hcmtlciBpbnN0YW5jZSBhbmQgYWRkIHRvIHRoZSBtYXAgb25jZSB0aGUgbWFwIGlzIGF2YWlsYWJsZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFwKSB7XG4gICAgICBpZiAobWFwID09PSB1bmRlZmluZWQpIGNvbnNvbGUuZXJyb3IoJzxNYXJrZXI+IGhhcyB0byBiZSBpbnNpZGUgYSBNYXAgY29tcG9uZW50LicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdNYXJrZXIgPSBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKG1hcmtlck9wdGlvbnMpO1xuICAgIG5ld01hcmtlci5zZXRNYXAobWFwKTtcbiAgICBzZXRNYXJrZXIobmV3TWFya2VyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbmV3TWFya2VyLnNldE1hcChudWxsKTtcbiAgICAgIHNldE1hcmtlcihudWxsKTtcbiAgICB9O1xuICAgIC8vIFdlIGRvIG5vdCB3YW50IHRvIHJlLXJlbmRlciB0aGUgd2hvbGUgbWFya2VyIHdoZW4gdGhlIG9wdGlvbnMgY2hhbmdlLlxuICAgIC8vIE1hcmtlciBvcHRpb25zIHVwZGF0ZSBpcyBoYW5kbGVkIGluIGEgdXNlRWZmZWN0IGJlbG93LlxuICAgIC8vIEV4Y2x1ZGluZyBtYXJrZXJPcHRpb25zIGZyb20gZGVwZW5kZW5jeSBhcnJheSBvbiBwdXJwb3NlIGhlcmUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbbWFwXSk7XG4gIC8vIGF0dGFjaCBhbmQgcmUtYXR0YWNoIGV2ZW50LWhhbmRsZXJzIHdoZW4gYW55IG9mIHRoZSBwcm9wZXJ0aWVzIGNoYW5nZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFya2VyKSByZXR1cm47XG4gICAgY29uc3QgbSA9IG1hcmtlcjtcbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgY29uc3QgZ21lID0gZ29vZ2xlLm1hcHMuZXZlbnQ7XG4gICAgaWYgKG9uQ2xpY2spIGdtZS5hZGRMaXN0ZW5lcihtLCAnY2xpY2snLCBvbkNsaWNrKTtcbiAgICBpZiAob25EcmFnKSBnbWUuYWRkTGlzdGVuZXIobSwgJ2RyYWcnLCBvbkRyYWcpO1xuICAgIGlmIChvbkRyYWdTdGFydCkgZ21lLmFkZExpc3RlbmVyKG0sICdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydCk7XG4gICAgaWYgKG9uRHJhZ0VuZCkgZ21lLmFkZExpc3RlbmVyKG0sICdkcmFnZW5kJywgb25EcmFnRW5kKTtcbiAgICBpZiAob25Nb3VzZU92ZXIpIGdtZS5hZGRMaXN0ZW5lcihtLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpO1xuICAgIGlmIChvbk1vdXNlT3V0KSBnbWUuYWRkTGlzdGVuZXIobSwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCk7XG4gICAgbWFya2VyLnNldERyYWdnYWJsZShCb29sZWFuKGRyYWdnYWJsZSkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBnbWUuY2xlYXJJbnN0YW5jZUxpc3RlbmVycyhtKTtcbiAgICB9O1xuICB9LCBbbWFya2VyLCBkcmFnZ2FibGUsIG9uQ2xpY2ssIG9uRHJhZywgb25EcmFnU3RhcnQsIG9uRHJhZ0VuZCwgb25Nb3VzZU92ZXIsIG9uTW91c2VPdXRdKTtcbiAgLy8gdXBkYXRlIG1hcmtlck9wdGlvbnMgKG5vdGUgdGhlIGRlcGVuZGVuY2llcyBhcmVuJ3QgcHJvcGVybHkgY2hlY2tlZFxuICAvLyBoZXJlLCB3ZSBqdXN0IGFzc3VtZSB0aGF0IHNldE9wdGlvbnMgaXMgc21hcnQgZW5vdWdoIHRvIG5vdCB3YXN0ZSBhXG4gIC8vIGxvdCBvZiB0aW1lIHVwZGF0aW5nIHZhbHVlcyB0aGF0IGRpZG4ndCBjaGFuZ2UpXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXJrZXIpIHJldHVybjtcbiAgICBpZiAobWFya2VyT3B0aW9ucykgbWFya2VyLnNldE9wdGlvbnMobWFya2VyT3B0aW9ucyk7XG4gIH0sIFttYXJrZXIsIG1hcmtlck9wdGlvbnNdKTtcbiAgLy8gdXBkYXRlIHBvc2l0aW9uIHdoZW4gY2hhbmdlZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFNob3VsZCBub3QgdXBkYXRlIHBvc2l0aW9uIHdoZW4gZHJhZ2dhYmxlXG4gICAgaWYgKGRyYWdnYWJsZSB8fCAhcG9zaXRpb24gfHwgIW1hcmtlcikgcmV0dXJuO1xuICAgIG1hcmtlci5zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gIH0sIFtkcmFnZ2FibGUsIHBvc2l0aW9uLCBtYXJrZXJdKTtcbiAgcmV0dXJuIG1hcmtlcjtcbn1cbi8qKlxuICogQ29tcG9uZW50IHRvIHJlbmRlciBhIG1hcmtlciBvbiBhIG1hcFxuICovXG5jb25zdCBNYXJrZXIgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IG1hcmtlciA9IHVzZU1hcmtlcihwcm9wcyk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiBtYXJrZXIsIFttYXJrZXJdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsKTtcbn0pO1xuZnVuY3Rpb24gdXNlTWFya2VyUmVmKCkge1xuICBjb25zdCBbbWFya2VyLCBzZXRNYXJrZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHJlZkNhbGxiYWNrID0gdXNlQ2FsbGJhY2sobSA9PiB7XG4gICAgc2V0TWFya2VyKG0pO1xuICB9LCBbXSk7XG4gIHJldHVybiBbcmVmQ2FsbGJhY2ssIG1hcmtlcl07XG59XG5cbi8qKlxuICogQ29tcG9uZW50IHRvIGNvbmZpZ3VyZSB0aGUgYXBwZWFyYW5jZSBvZiBhbiBBZHZhbmNlZE1hcmtlclxuICovXG5jb25zdCBQaW4gPSBwcm9wcyA9PiB7XG4gIHZhciBfdXNlQ29udGV4dDtcbiAgY29uc3QgYWR2YW5jZWRNYXJrZXIgPSAoX3VzZUNvbnRleHQgPSB1c2VDb250ZXh0KEFkdmFuY2VkTWFya2VyQ29udGV4dCkpID09IG51bGwgPyB2b2lkIDAgOiBfdXNlQ29udGV4dC5tYXJrZXI7XG4gIGNvbnN0IGdseXBoQ29udGFpbmVyID0gdXNlTWVtbygoKSA9PiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgW10pO1xuICAvLyBDcmVhdGUgUGluIFZpZXcgaW5zdGFuY2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX2FkdmFuY2VkTWFya2VyJGNvbnRlO1xuICAgIGlmICghYWR2YW5jZWRNYXJrZXIpIHtcbiAgICAgIGlmIChhZHZhbmNlZE1hcmtlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZSA8UGluPiBjb21wb25lbnQgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgPEFkdmFuY2VkTWFya2VyPi4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmdseXBoICYmIHByb3BzLmNoaWxkcmVuKSB7XG4gICAgICBsb2dFcnJvck9uY2UoJ1RoZSA8UGluPiBjb21wb25lbnQgb25seSB1c2VzIGNoaWxkcmVuIHRvIHJlbmRlciB0aGUgZ2x5cGggaWYgYm90aCB0aGUgZ2x5cGggcHJvcGVydHkgYW5kIGNoaWxkcmVuIGFyZSBwcmVzZW50LicpO1xuICAgIH1cbiAgICBpZiAoQ2hpbGRyZW4uY291bnQocHJvcHMuY2hpbGRyZW4pID4gMSkge1xuICAgICAgbG9nRXJyb3JPbmNlKCdQYXNzaW5nIG11bHRpcGxlIGNoaWxkcmVuIHRvIHRoZSA8UGluPiBjb21wb25lbnQgbWlnaHQgbGVhZCB0byB1bmV4cGVjdGVkIHJlc3VsdHMuJyk7XG4gICAgfVxuICAgIGNvbnN0IHBpblZpZXdPcHRpb25zID0gX2V4dGVuZHMoe30sIHByb3BzKTtcbiAgICBjb25zdCBwaW5FbGVtZW50ID0gbmV3IGdvb2dsZS5tYXBzLm1hcmtlci5QaW5FbGVtZW50KHBpblZpZXdPcHRpb25zKTtcbiAgICAvLyBTZXQgZ2x5cGggdG8gZ2x5cGggY29udGFpbmVyIGlmIGNoaWxkcmVuIGFyZSBwcmVzZW50IChyZW5kZXJlZCB2aWEgcG9ydGFsKS5cbiAgICAvLyBJZiBib3RoIHByb3BzLmdseXBoIGFuZCBwcm9wcy5jaGlsZHJlbiBhcmUgcHJlc2VudCwgcHJvcHMuY2hpbGRyZW4gdGFrZXMgcHJpb3JpdHkuXG4gICAgaWYgKHByb3BzLmNoaWxkcmVuKSB7XG4gICAgICBwaW5FbGVtZW50LmdseXBoID0gZ2x5cGhDb250YWluZXI7XG4gICAgfVxuICAgIC8vIFNldCBjb250ZW50IG9mIEFkdmFuY2VkIE1hcmtlciBWaWV3IHRvIHRoZSBQaW4gVmlldyBlbGVtZW50XG4gICAgLy8gSGVyZSB3ZSBhcmUgc2VsZWN0aW5nIHRoZSBhbmNob3IgY29udGFpbmVyLlxuICAgIC8vIFRoZSBoaWVyYXJjaHkgaXMgYXMgZm9sbG93czpcbiAgICAvLyBcImFkdmFuY2VkTWFya2VyLmNvbnRlbnRcIiAoZnJvbSBnb29nbGUpIC0+IFwicG9pbnRlciBldmVudHMgcmVzZXQgZGl2XCIgLT4gXCJhbmNob3IgY29udGFpbmVyXCJcbiAgICBjb25zdCBtYXJrZXJDb250ZW50ID0gKF9hZHZhbmNlZE1hcmtlciRjb250ZSA9IGFkdmFuY2VkTWFya2VyLmNvbnRlbnQpID09IG51bGwgfHwgKF9hZHZhbmNlZE1hcmtlciRjb250ZSA9IF9hZHZhbmNlZE1hcmtlciRjb250ZS5maXJzdENoaWxkKSA9PSBudWxsID8gdm9pZCAwIDogX2FkdmFuY2VkTWFya2VyJGNvbnRlLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKG1hcmtlckNvbnRlbnQgIT0gbnVsbCAmJiBtYXJrZXJDb250ZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIG1hcmtlckNvbnRlbnQucmVtb3ZlQ2hpbGQobWFya2VyQ29udGVudC5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgaWYgKG1hcmtlckNvbnRlbnQpIHtcbiAgICAgIG1hcmtlckNvbnRlbnQuYXBwZW5kQ2hpbGQocGluRWxlbWVudC5lbGVtZW50KTtcbiAgICB9XG4gIH0sIFthZHZhbmNlZE1hcmtlciwgZ2x5cGhDb250YWluZXIsIHByb3BzXSk7XG4gIHJldHVybiBjcmVhdGVQb3J0YWwocHJvcHMuY2hpbGRyZW4sIGdseXBoQ29udGFpbmVyKTtcbn07XG5cbmNvbnN0IG1hcExpbmVhciA9ICh4LCBhMSwgYTIsIGIxLCBiMikgPT4gYjEgKyAoeCAtIGExKSAqIChiMiAtIGIxKSAvIChhMiAtIGExKTtcbmNvbnN0IGdldE1hcE1heFRpbHQgPSB6b29tID0+IHtcbiAgaWYgKHpvb20gPD0gMTApIHtcbiAgICByZXR1cm4gMzA7XG4gIH1cbiAgaWYgKHpvb20gPj0gMTUuNSkge1xuICAgIHJldHVybiA2Ny41O1xuICB9XG4gIC8vIHJhbmdlIFsxMC4uLjE0XVxuICBpZiAoem9vbSA8PSAxNCkge1xuICAgIHJldHVybiBtYXBMaW5lYXIoem9vbSwgMTAsIDE0LCAzMCwgNDUpO1xuICB9XG4gIC8vIHJhbmdlIFsxNC4uLjE1LjVdXG4gIHJldHVybiBtYXBMaW5lYXIoem9vbSwgMTQsIDE1LjUsIDQ1LCA2Ny41KTtcbn07XG4vKipcbiAqIEZ1bmN0aW9uIHRvIGxpbWl0IHRoZSB0aWx0IHJhbmdlIG9mIHRoZSBHb29nbGUgbWFwIHdoZW4gdXBkYXRpbmcgdGhlIHZpZXcgc3RhdGVcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGxpbWl0VGlsdFJhbmdlID0gKHtcbiAgdmlld1N0YXRlXG59KSA9PiB7XG4gIGNvbnN0IHBpdGNoID0gdmlld1N0YXRlLnBpdGNoO1xuICBjb25zdCBnbVpvb20gPSB2aWV3U3RhdGUuem9vbSArIDE7XG4gIGNvbnN0IG1heFRpbHQgPSBnZXRNYXBNYXhUaWx0KGdtWm9vbSk7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgdmlld1N0YXRlLCB7XG4gICAgZm92eTogMjUsXG4gICAgcGl0Y2g6IE1hdGgubWluKG1heFRpbHQsIHBpdGNoKVxuICB9KTtcbn07XG5cbmV4cG9ydCB7IEFQSUxvYWRpbmdTdGF0dXMsIEFQSVByb3ZpZGVyLCBBUElQcm92aWRlckNvbnRleHQsIEFkdmFuY2VkTWFya2VyLCBBZHZhbmNlZE1hcmtlckFuY2hvclBvaW50LCBBZHZhbmNlZE1hcmtlckNvbnRleHQsIENvbGxpc2lvbkJlaGF2aW9yLCBDb2xvclNjaGVtZSwgQ29udHJvbFBvc2l0aW9uLCBHb29nbGVNYXBzQ29udGV4dCwgSW5mb1dpbmRvdywgTWFwLCBNYXBDb250cm9sLCBNYXJrZXIsIFBpbiwgUmVuZGVyaW5nVHlwZSwgU3RhdGljTWFwLCBjcmVhdGVTdGF0aWNNYXBzVXJsLCBpc0FkdmFuY2VkTWFya2VyLCBpc0xhdExuZ0xpdGVyYWwsIGxhdExuZ0VxdWFscywgbGltaXRUaWx0UmFuZ2UsIHRvTGF0TG5nTGl0ZXJhbCwgdXNlQWR2YW5jZWRNYXJrZXJSZWYsIHVzZUFwaUlzTG9hZGVkLCB1c2VBcGlMb2FkaW5nU3RhdHVzLCB1c2VNYXAsIHVzZU1hcHNMaWJyYXJ5LCB1c2VNYXJrZXJSZWYgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1vZGVybi5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fast-deep-equal/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fast-deep-equal/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixVQUFVO0FBQy9COztBQUVBLHFCQUFxQixVQUFVO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHBsZS9Qcm9qZWN0cy9Qcm9kYW5jZS9GRS9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gZG8gbm90IGVkaXQgLmpzIGZpbGVzIGRpcmVjdGx5IC0gZWRpdCBzcmMvaW5kZXguanN0XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG5cbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fast-deep-equal/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fapple%2FProjects%2FProdance%2FFE%2Fsrc%2Fapp%2Ftheme-provider.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fapple%2FProjects%2FProdance%2FFE%2Fsrc%2Fcomponents%2FSmoothScrollProvider.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fapple%2FProjects%2FProdance%2FFE%2Fsrc%2Fstyles%2Ftailwind.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fapple%2FProjects%2FProdance%2FFE%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Poppins%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22display%5C%22%3A%5C%22swap%5C%22%2C%5C%22weight%5C%22%3A%5B%5C%22300%5C%22%2C%5C%22400%5C%22%2C%5C%22500%5C%22%2C%5C%22600%5C%22%2C%5C%22700%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22poppins%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fapple%2FProjects%2FProdance%2FFE%2Fnode_modules%2Frc-slider%2Fassets%2Findex.css%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fapple%2FProjects%2FProdance%2FFE%2Fsrc%2Fapp%2Ftheme-provider.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fapple%2FProjects%2FProdance%2FFE%2Fsrc%2Fcomponents%2FSmoothScrollProvider.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fapple%2FProjects%2FProdance%2FFE%2Fsrc%2Fstyles%2Ftailwind.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fapple%2FProjects%2FProdance%2FFE%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Poppins%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22display%5C%22%3A%5C%22swap%5C%22%2C%5C%22weight%5C%22%3A%5B%5C%22300%5C%22%2C%5C%22400%5C%22%2C%5C%22500%5C%22%2C%5C%22600%5C%22%2C%5C%22700%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22poppins%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fapple%2FProjects%2FProdance%2FFE%2Fnode_modules%2Frc-slider%2Fassets%2Findex.css%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/theme-provider.tsx */ \"(app-pages-browser)/./src/app/theme-provider.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/SmoothScrollProvider.tsx */ \"(app-pages-browser)/./src/components/SmoothScrollProvider.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/styles/tailwind.css */ \"(app-pages-browser)/./src/styles/tailwind.css\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"src/app/layout.tsx\",\"import\":\"Poppins\",\"arguments\":[{\"subsets\":[\"latin\"],\"display\":\"swap\",\"weight\":[\"300\",\"400\",\"500\",\"600\",\"700\"]}],\"variableName\":\"poppins\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"src/app/layout.tsx\\\",\\\"import\\\":\\\"Poppins\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"],\\\"display\\\":\\\"swap\\\",\\\"weight\\\":[\\\"300\\\",\\\"400\\\",\\\"500\\\",\\\"600\\\",\\\"700\\\"]}],\\\"variableName\\\":\\\"poppins\\\"}\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./node_modules/rc-slider/assets/index.css */ \"(app-pages-browser)/./node_modules/rc-slider/assets/index.css\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZhcHBsZSUyRlByb2plY3RzJTJGUHJvZGFuY2UlMkZGRSUyRnNyYyUyRmFwcCUyRnRoZW1lLXByb3ZpZGVyLnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiUyMmRlZmF1bHQlMjIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZhcHBsZSUyRlByb2plY3RzJTJGUHJvZGFuY2UlMkZGRSUyRnNyYyUyRmNvbXBvbmVudHMlMkZTbW9vdGhTY3JvbGxQcm92aWRlci50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJkZWZhdWx0JTIyJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRlVzZXJzJTJGYXBwbGUlMkZQcm9qZWN0cyUyRlByb2RhbmNlJTJGRkUlMkZzcmMlMkZzdHlsZXMlMkZ0YWlsd2luZC5jc3MlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZhcHBsZSUyRlByb2plY3RzJTJGUHJvZGFuY2UlMkZGRSUyRm5vZGVfbW9kdWxlcyUyRm5leHQlMkZmb250JTJGZ29vZ2xlJTJGdGFyZ2V0LmNzcyUzRiU3QiU1QyUyMnBhdGglNUMlMjIlM0ElNUMlMjJzcmMlMkZhcHAlMkZsYXlvdXQudHN4JTVDJTIyJTJDJTVDJTIyaW1wb3J0JTVDJTIyJTNBJTVDJTIyUG9wcGlucyU1QyUyMiUyQyU1QyUyMmFyZ3VtZW50cyU1QyUyMiUzQSU1QiU3QiU1QyUyMnN1YnNldHMlNUMlMjIlM0ElNUIlNUMlMjJsYXRpbiU1QyUyMiU1RCUyQyU1QyUyMmRpc3BsYXklNUMlMjIlM0ElNUMlMjJzd2FwJTVDJTIyJTJDJTVDJTIyd2VpZ2h0JTVDJTIyJTNBJTVCJTVDJTIyMzAwJTVDJTIyJTJDJTVDJTIyNDAwJTVDJTIyJTJDJTVDJTIyNTAwJTVDJTIyJTJDJTVDJTIyNjAwJTVDJTIyJTJDJTVDJTIyNzAwJTVDJTIyJTVEJTdEJTVEJTJDJTVDJTIydmFyaWFibGVOYW1lJTVDJTIyJTNBJTVDJTIycG9wcGlucyU1QyUyMiU3RCUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZVc2VycyUyRmFwcGxlJTJGUHJvamVjdHMlMkZQcm9kYW5jZSUyRkZFJTJGbm9kZV9tb2R1bGVzJTJGcmMtc2xpZGVyJTJGYXNzZXRzJTJGaW5kZXguY3NzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsa0xBQThIO0FBQzlIO0FBQ0EsNE1BQTJJO0FBQzNJO0FBQ0EsNEtBQThGO0FBQzlGO0FBQ0Esc2tCQUF5VDtBQUN6VDtBQUNBLDRNQUE4RyIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiLCB3ZWJwYWNrRXhwb3J0czogW1wiZGVmYXVsdFwiXSAqLyBcIi9Vc2Vycy9hcHBsZS9Qcm9qZWN0cy9Qcm9kYW5jZS9GRS9zcmMvYXBwL3RoZW1lLXByb3ZpZGVyLnRzeFwiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiLCB3ZWJwYWNrRXhwb3J0czogW1wiZGVmYXVsdFwiXSAqLyBcIi9Vc2Vycy9hcHBsZS9Qcm9qZWN0cy9Qcm9kYW5jZS9GRS9zcmMvY29tcG9uZW50cy9TbW9vdGhTY3JvbGxQcm92aWRlci50c3hcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9hcHBsZS9Qcm9qZWN0cy9Qcm9kYW5jZS9GRS9zcmMvc3R5bGVzL3RhaWx3aW5kLmNzc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL2FwcGxlL1Byb2plY3RzL1Byb2RhbmNlL0ZFL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1xcXCJwYXRoXFxcIjpcXFwic3JjL2FwcC9sYXlvdXQudHN4XFxcIixcXFwiaW1wb3J0XFxcIjpcXFwiUG9wcGluc1xcXCIsXFxcImFyZ3VtZW50c1xcXCI6W3tcXFwic3Vic2V0c1xcXCI6W1xcXCJsYXRpblxcXCJdLFxcXCJkaXNwbGF5XFxcIjpcXFwic3dhcFxcXCIsXFxcIndlaWdodFxcXCI6W1xcXCIzMDBcXFwiLFxcXCI0MDBcXFwiLFxcXCI1MDBcXFwiLFxcXCI2MDBcXFwiLFxcXCI3MDBcXFwiXX1dLFxcXCJ2YXJpYWJsZU5hbWVcXFwiOlxcXCJwb3BwaW5zXFxcIn1cIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9hcHBsZS9Qcm9qZWN0cy9Qcm9kYW5jZS9GRS9ub2RlX21vZHVsZXMvcmMtc2xpZGVyL2Fzc2V0cy9pbmRleC5jc3NcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fapple%2FProjects%2FProdance%2FFE%2Fsrc%2Fapp%2Ftheme-provider.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fapple%2FProjects%2FProdance%2FFE%2Fsrc%2Fcomponents%2FSmoothScrollProvider.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fapple%2FProjects%2FProdance%2FFE%2Fsrc%2Fstyles%2Ftailwind.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fapple%2FProjects%2FProdance%2FFE%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Poppins%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22display%5C%22%3A%5C%22swap%5C%22%2C%5C%22weight%5C%22%3A%5B%5C%22300%5C%22%2C%5C%22400%5C%22%2C%5C%22500%5C%22%2C%5C%22600%5C%22%2C%5C%22700%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22poppins%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fapple%2FProjects%2FProdance%2FFE%2Fnode_modules%2Frc-slider%2Fassets%2Findex.css%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(()=>{\"use strict\";var e={529:(e,r,t)=>{var n=t(191);var i=Object.create(null);var a=typeof document===\"undefined\";var o=Array.prototype.forEach;function debounce(e,r){var t=0;return function(){var n=this;var i=arguments;var a=function functionCall(){return e.apply(n,i)};clearTimeout(t);t=setTimeout(a,r)}}function noop(){}function getCurrentScriptUrl(e){var r=i[e];if(!r){if(document.currentScript){r=document.currentScript.src}else{var t=document.getElementsByTagName(\"script\");var a=t[t.length-1];if(a){r=a.src}}i[e]=r}return function(e){if(!r){return null}var t=r.split(/([^\\\\/]+)\\.js$/);var i=t&&t[1];if(!i){return[r.replace(\".js\",\".css\")]}if(!e){return[r.replace(\".js\",\".css\")]}return e.split(\",\").map((function(e){var t=new RegExp(\"\".concat(i,\"\\\\.js$\"),\"g\");return n(r.replace(t,\"\".concat(e.replace(/{fileName}/g,i),\".css\")))}))}}function updateCss(e,r){if(!r){if(!e.href){return}r=e.href.split(\"?\")[0]}if(!isUrlRequest(r)){return}if(e.isLoaded===false){return}if(!r||!(r.indexOf(\".css\")>-1)){return}e.visited=true;var t=e.cloneNode();t.isLoaded=false;t.addEventListener(\"load\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.addEventListener(\"error\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.href=\"\".concat(r,\"?\").concat(Date.now());if(e.nextSibling){e.parentNode.insertBefore(t,e.nextSibling)}else{e.parentNode.appendChild(t)}}function getReloadUrl(e,r){var t;e=n(e,{stripWWW:false});r.some((function(n){if(e.indexOf(r)>-1){t=n}}));return t}function reloadStyle(e){if(!e){return false}var r=document.querySelectorAll(\"link\");var t=false;o.call(r,(function(r){if(!r.href){return}var n=getReloadUrl(r.href,e);if(!isUrlRequest(n)){return}if(r.visited===true){return}if(n){updateCss(r,n);t=true}}));return t}function reloadAll(){var e=document.querySelectorAll(\"link\");o.call(e,(function(e){if(e.visited===true){return}updateCss(e)}))}function isUrlRequest(e){if(!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)){return false}return true}e.exports=function(e,r){if(a){console.log(\"no window.document found, will not HMR CSS\");return noop}var t=getCurrentScriptUrl(e);function update(){var e=t(r.filename);var n=reloadStyle(e);if(r.locals){console.log(\"[HMR] Detected local css modules. Reload all css\");reloadAll();return}if(n){console.log(\"[HMR] css reload %s\",e.join(\" \"))}else{console.log(\"[HMR] Reload all css\");reloadAll()}}return debounce(update,50)}},191:e=>{function normalizeUrl(e){return e.reduce((function(e,r){switch(r){case\"..\":e.pop();break;case\".\":break;default:e.push(r)}return e}),[]).join(\"/\")}e.exports=function(e){e=e.trim();if(/^data:/i.test(e)){return e}var r=e.indexOf(\"//\")!==-1?e.split(\"//\")[0]+\"//\":\"\";var t=e.replace(new RegExp(r,\"i\"),\"\").split(\"/\");var n=t[0].toLowerCase().replace(/\\.$/,\"\");t[0]=\"\";var i=normalizeUrl(t);return r+n+i}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var i=r[t]={exports:{}};var a=true;try{e[t](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(529);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLGFBQWEsT0FBTyxjQUFjLGFBQWEsMEJBQTBCLG9DQUFvQyw4QkFBOEIsdUJBQXVCLFFBQVEsa0JBQWtCLFdBQVcsZ0JBQWdCLDhCQUE4QixxQkFBcUIsZ0JBQWdCLG1CQUFtQixpQkFBaUIsZ0NBQWdDLFdBQVcsT0FBTywyQkFBMkIsNkJBQTZCLEtBQUssOENBQThDLG9CQUFvQixNQUFNLFNBQVMsT0FBTyxtQkFBbUIsT0FBTyxZQUFZLGdDQUFnQyxjQUFjLE9BQU8sZ0NBQWdDLE9BQU8sZ0NBQWdDLHFDQUFxQyw0Q0FBNEMsMkNBQTJDLFNBQVMsZ0JBQWdCLElBQUksd0JBQXdCLE9BQU8sWUFBWSxPQUFPLHVCQUF1QixxQkFBcUIsT0FBTyx1QkFBdUIsT0FBTyxnQ0FBZ0MsT0FBTyxlQUFlLG9CQUFvQixpQkFBaUIsc0NBQXNDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsdUNBQXVDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsMkNBQTJDLGtCQUFrQiwyQ0FBMkMsS0FBSyw2QkFBNkIsMkJBQTJCLE1BQU0sT0FBTyxlQUFlLEVBQUUsb0JBQW9CLG9CQUFvQixLQUFLLEdBQUcsU0FBUyx3QkFBd0IsT0FBTyxhQUFhLHdDQUF3QyxZQUFZLHNCQUFzQixZQUFZLE9BQU8sNkJBQTZCLHFCQUFxQixPQUFPLHFCQUFxQixPQUFPLE1BQU0sZUFBZSxRQUFRLEdBQUcsU0FBUyxxQkFBcUIsd0NBQXdDLHNCQUFzQixxQkFBcUIsT0FBTyxhQUFhLEdBQUcseUJBQXlCLHlDQUF5QyxhQUFhLFlBQVksd0JBQXdCLE1BQU0sMERBQTBELFlBQVksNkJBQTZCLGtCQUFrQixvQkFBb0IscUJBQXFCLGFBQWEsZ0VBQWdFLFlBQVksT0FBTyxNQUFNLCtDQUErQyxLQUFLLG9DQUFvQyxhQUFhLDRCQUE0QixTQUFTLHlCQUF5QiwrQkFBK0IsVUFBVSxpQkFBaUIsTUFBTSxjQUFjLGtCQUFrQixTQUFTLGdCQUFnQixzQkFBc0IsV0FBVyxzQkFBc0IsU0FBUyxvREFBb0QsaURBQWlELDJDQUEyQyxRQUFRLHNCQUFzQixnQkFBZ0IsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsiL1VzZXJzL2FwcGxlL1Byb2plY3RzL1Byb2RhbmNlL0ZFL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs1Mjk6KGUscix0KT0+e3ZhciBuPXQoMTkxKTt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO3ZhciBhPXR5cGVvZiBkb2N1bWVudD09PVwidW5kZWZpbmVkXCI7dmFyIG89QXJyYXkucHJvdG90eXBlLmZvckVhY2g7ZnVuY3Rpb24gZGVib3VuY2UoZSxyKXt2YXIgdD0wO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXM7dmFyIGk9YXJndW1lbnRzO3ZhciBhPWZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbCgpe3JldHVybiBlLmFwcGx5KG4saSl9O2NsZWFyVGltZW91dCh0KTt0PXNldFRpbWVvdXQoYSxyKX19ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0VXJsKGUpe3ZhciByPWlbZV07aWYoIXIpe2lmKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3I9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmN9ZWxzZXt2YXIgdD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTt2YXIgYT10W3QubGVuZ3RoLTFdO2lmKGEpe3I9YS5zcmN9fWlbZV09cn1yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXIpe3JldHVybiBudWxsfXZhciB0PXIuc3BsaXQoLyhbXlxcXFwvXSspXFwuanMkLyk7dmFyIGk9dCYmdFsxXTtpZighaSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19aWYoIWUpe3JldHVybltyLnJlcGxhY2UoXCIuanNcIixcIi5jc3NcIildfXJldHVybiBlLnNwbGl0KFwiLFwiKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBSZWdFeHAoXCJcIi5jb25jYXQoaSxcIlxcXFwuanMkXCIpLFwiZ1wiKTtyZXR1cm4gbihyLnJlcGxhY2UodCxcIlwiLmNvbmNhdChlLnJlcGxhY2UoL3tmaWxlTmFtZX0vZyxpKSxcIi5jc3NcIikpKX0pKX19ZnVuY3Rpb24gdXBkYXRlQ3NzKGUscil7aWYoIXIpe2lmKCFlLmhyZWYpe3JldHVybn1yPWUuaHJlZi5zcGxpdChcIj9cIilbMF19aWYoIWlzVXJsUmVxdWVzdChyKSl7cmV0dXJufWlmKGUuaXNMb2FkZWQ9PT1mYWxzZSl7cmV0dXJufWlmKCFyfHwhKHIuaW5kZXhPZihcIi5jc3NcIik+LTEpKXtyZXR1cm59ZS52aXNpdGVkPXRydWU7dmFyIHQ9ZS5jbG9uZU5vZGUoKTt0LmlzTG9hZGVkPWZhbHNlO3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtpZih0LmlzTG9hZGVkKXtyZXR1cm59dC5pc0xvYWRlZD10cnVlO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuaHJlZj1cIlwiLmNvbmNhdChyLFwiP1wiKS5jb25jYXQoRGF0ZS5ub3coKSk7aWYoZS5uZXh0U2libGluZyl7ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpfWVsc2V7ZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHQpfX1mdW5jdGlvbiBnZXRSZWxvYWRVcmwoZSxyKXt2YXIgdDtlPW4oZSx7c3RyaXBXV1c6ZmFsc2V9KTtyLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKGUuaW5kZXhPZihyKT4tMSl7dD1ufX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRTdHlsZShlKXtpZighZSl7cmV0dXJuIGZhbHNlfXZhciByPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO3ZhciB0PWZhbHNlO28uY2FsbChyLChmdW5jdGlvbihyKXtpZighci5ocmVmKXtyZXR1cm59dmFyIG49Z2V0UmVsb2FkVXJsKHIuaHJlZixlKTtpZighaXNVcmxSZXF1ZXN0KG4pKXtyZXR1cm59aWYoci52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufWlmKG4pe3VwZGF0ZUNzcyhyLG4pO3Q9dHJ1ZX19KSk7cmV0dXJuIHR9ZnVuY3Rpb24gcmVsb2FkQWxsKCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7by5jYWxsKGUsKGZ1bmN0aW9uKGUpe2lmKGUudmlzaXRlZD09PXRydWUpe3JldHVybn11cGRhdGVDc3MoZSl9KSl9ZnVuY3Rpb24gaXNVcmxSZXF1ZXN0KGUpe2lmKCEvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo6Ly50ZXN0KGUpKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7aWYoYSl7Y29uc29sZS5sb2coXCJubyB3aW5kb3cuZG9jdW1lbnQgZm91bmQsIHdpbGwgbm90IEhNUiBDU1NcIik7cmV0dXJuIG5vb3B9dmFyIHQ9Z2V0Q3VycmVudFNjcmlwdFVybChlKTtmdW5jdGlvbiB1cGRhdGUoKXt2YXIgZT10KHIuZmlsZW5hbWUpO3ZhciBuPXJlbG9hZFN0eWxlKGUpO2lmKHIubG9jYWxzKXtjb25zb2xlLmxvZyhcIltITVJdIERldGVjdGVkIGxvY2FsIGNzcyBtb2R1bGVzLiBSZWxvYWQgYWxsIGNzc1wiKTtyZWxvYWRBbGwoKTtyZXR1cm59aWYobil7Y29uc29sZS5sb2coXCJbSE1SXSBjc3MgcmVsb2FkICVzXCIsZS5qb2luKFwiIFwiKSl9ZWxzZXtjb25zb2xlLmxvZyhcIltITVJdIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpfX1yZXR1cm4gZGVib3VuY2UodXBkYXRlLDUwKX19LDE5MTplPT57ZnVuY3Rpb24gbm9ybWFsaXplVXJsKGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXtzd2l0Y2gocil7Y2FzZVwiLi5cIjplLnBvcCgpO2JyZWFrO2Nhc2VcIi5cIjpicmVhaztkZWZhdWx0OmUucHVzaChyKX1yZXR1cm4gZX0pLFtdKS5qb2luKFwiL1wiKX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7ZT1lLnRyaW0oKTtpZigvXmRhdGE6L2kudGVzdChlKSl7cmV0dXJuIGV9dmFyIHI9ZS5pbmRleE9mKFwiLy9cIikhPT0tMT9lLnNwbGl0KFwiLy9cIilbMF0rXCIvL1wiOlwiXCI7dmFyIHQ9ZS5yZXBsYWNlKG5ldyBSZWdFeHAocixcImlcIiksXCJcIikuc3BsaXQoXCIvXCIpO3ZhciBuPXRbMF0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4kLyxcIlwiKTt0WzBdPVwiXCI7dmFyIGk9bm9ybWFsaXplVXJsKHQpO3JldHVybiByK24raX19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBuPXJbdF07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNTI5KTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        self,\n        source,\n        getOwner(),\n        maybeKey,\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      \"react-stack-bottom-frame\": function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React[\"react-stack-bottom-frame\"].bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        source,\n        self,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFnRDtBQUNoRSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0EsZ0NBQWdDLGtDQUFrQyxPQUFPO0FBQ3pFO0FBQ0EsZ0dBQWdHLFNBQVMsVUFBVSxzRkFBc0YsYUFBYSxVQUFVLFVBQVU7QUFDMU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHIiwic291cmNlcyI6WyIvVXNlcnMvYXBwbGUvUHJvamVjdHMvUHJvZGFuY2UvRkUvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0VcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgICBjYXNlIFJFQUNUX0FDVElWSVRZX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiQWN0aXZpdHlcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgdmFyIGlubmVyVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgICAgICgodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgKHR5cGUgPSBcIlwiICE9PSB0eXBlID8gXCJGb3J3YXJkUmVmKFwiICsgdHlwZSArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgID8gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITA7XG4gICAgICB9XG4gICAgICBpZiAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGNvbnNvbGU7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuZXJyb3I7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPVxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTeW1ib2wgJiZcbiAgICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyAmJlxuICAgICAgICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSkgfHxcbiAgICAgICAgICB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8XG4gICAgICAgICAgXCJPYmplY3RcIjtcbiAgICAgICAgSlNDb21waWxlcl90ZW1wX2NvbnN0LmNhbGwoXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRhc2tOYW1lKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSByZXR1cm4gXCI8PlwiO1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRVxuICAgICAgKVxuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHJldHVybiBuYW1lID8gXCI8XCIgKyBuYW1lICsgXCI+XCIgOiBcIjwuLi4+XCI7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBcIjwuLi4+XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE93bmVyKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgICAgcmV0dXJuIG51bGwgPT09IGRpc3BhdGNoZXIgPyBudWxsIDogZGlzcGF0Y2hlci5nZXRPd25lcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVbmtub3duT3duZXIoKSB7XG4gICAgICByZXR1cm4gRXJyb3IoXCJyZWFjdC1zdGFjay10b3AtZnJhbWVcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxuICAgICAgICAgICgoc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gITA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICgoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KFxuICAgICAgdHlwZSxcbiAgICAgIGtleSxcbiAgICAgIHNlbGYsXG4gICAgICBzb3VyY2UsXG4gICAgICBvd25lcixcbiAgICAgIHByb3BzLFxuICAgICAgZGVidWdTdGFjayxcbiAgICAgIGRlYnVnVGFza1xuICAgICkge1xuICAgICAgc2VsZiA9IHByb3BzLnJlZjtcbiAgICAgIHR5cGUgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIF9vd25lcjogb3duZXJcbiAgICAgIH07XG4gICAgICBudWxsICE9PSAodm9pZCAwICE9PSBzZWxmID8gc2VsZiA6IG51bGwpXG4gICAgICAgID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgZ2V0OiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgIH0pXG4gICAgICAgIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHsgZW51bWVyYWJsZTogITEsIHZhbHVlOiBudWxsIH0pO1xuICAgICAgdHlwZS5fc3RvcmUgPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogMFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdJbmZvXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnU3RhY2tcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogZGVidWdTdGFja1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdUYXNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnVGFza1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKHR5cGUucHJvcHMpLCBPYmplY3QuZnJlZXplKHR5cGUpKTtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBqc3hERVZJbXBsKFxuICAgICAgdHlwZSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1heWJlS2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNlbGYsXG4gICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgZGVidWdUYXNrXG4gICAgKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjb25maWcuY2hpbGRyZW47XG4gICAgICBpZiAodm9pZCAwICE9PSBjaGlsZHJlbilcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pXG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9IDA7XG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPCBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4rK1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpc1N0YXRpY0NoaWxkcmVuXSk7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiBZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuIFVzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIGVsc2UgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4pO1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICBjaGlsZHJlbiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICAgIHJldHVybiBcImtleVwiICE9PSBrO1xuICAgICAgICB9KTtcbiAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9XG4gICAgICAgICAgMCA8IGtleXMubGVuZ3RoXG4gICAgICAgICAgICA/IFwie2tleTogc29tZUtleSwgXCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIlxuICAgICAgICAgICAgOiBcIntrZXk6IHNvbWVLZXl9XCI7XG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dIHx8XG4gICAgICAgICAgKChrZXlzID1cbiAgICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aCA/IFwie1wiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCIgOiBcInt9XCIpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuICBsZXQgcHJvcHMgPSAlcztcXG4gIDwlcyB7Li4ucHJvcHN9IC8+XFxuUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuICBsZXQgcHJvcHMgPSAlcztcXG4gIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLFxuICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAga2V5cyxcbiAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gPSAhMCkpO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4gPSBudWxsO1xuICAgICAgdm9pZCAwICE9PSBtYXliZUtleSAmJlxuICAgICAgICAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBtYXliZUtleSkpO1xuICAgICAgaGFzVmFsaWRLZXkoY29uZmlnKSAmJlxuICAgICAgICAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIGNvbmZpZy5rZXkpKTtcbiAgICAgIGlmIChcImtleVwiIGluIGNvbmZpZykge1xuICAgICAgICBtYXliZUtleSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBjb25maWcpXG4gICAgICAgICAgXCJrZXlcIiAhPT0gcHJvcE5hbWUgJiYgKG1heWJlS2V5W3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV0pO1xuICAgICAgfSBlbHNlIG1heWJlS2V5ID0gY29uZmlnO1xuICAgICAgY2hpbGRyZW4gJiZcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIoXG4gICAgICAgICAgbWF5YmVLZXksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZVxuICAgICAgICAgICAgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBcIlVua25vd25cIlxuICAgICAgICAgICAgOiB0eXBlXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gUmVhY3RFbGVtZW50KFxuICAgICAgICB0eXBlLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgc2VsZixcbiAgICAgICAgc291cmNlLFxuICAgICAgICBnZXRPd25lcigpLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgZGVidWdTdGFjayxcbiAgICAgICAgZGVidWdUYXNrXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlKSB7XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJlxuICAgICAgICBudWxsICE9PSBub2RlICYmXG4gICAgICAgIG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSAmJlxuICAgICAgICBub2RlLl9zdG9yZSAmJlxuICAgICAgICAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgfVxuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIiksXG4gICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgICAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpO1xuICAgIHZhciBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLFxuICAgICAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gICAgICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICAgICAgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksXG4gICAgICBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSxcbiAgICAgIFJFQUNUX0FDVElWSVRZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuYWN0aXZpdHlcIiksXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGNyZWF0ZVRhc2sgPSBjb25zb2xlLmNyZWF0ZVRhc2tcbiAgICAgICAgPyBjb25zb2xlLmNyZWF0ZVRhc2tcbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9O1xuICAgIFJlYWN0ID0ge1xuICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKGNhbGxTdGFja0ZvckVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsU3RhY2tGb3JFcnJvcigpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xuICAgIHZhciBkaWRXYXJuQWJvdXRFbGVtZW50UmVmID0ge307XG4gICAgdmFyIHVua25vd25Pd25lckRlYnVnU3RhY2sgPSBSZWFjdFtcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKFxuICAgICAgUmVhY3QsXG4gICAgICBVbmtub3duT3duZXJcbiAgICApKCk7XG4gICAgdmFyIHVua25vd25Pd25lckRlYnVnVGFzayA9IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUoVW5rbm93bk93bmVyKSk7XG4gICAgdmFyIGRpZFdhcm5BYm91dEtleVNwcmVhZCA9IHt9O1xuICAgIGV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgIGV4cG9ydHMuanN4REVWID0gZnVuY3Rpb24gKFxuICAgICAgdHlwZSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1heWJlS2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNlbGZcbiAgICApIHtcbiAgICAgIHZhciB0cmFja0FjdHVhbE93bmVyID1cbiAgICAgICAgMWU0ID4gUmVhY3RTaGFyZWRJbnRlcm5hbHMucmVjZW50bHlDcmVhdGVkT3duZXJTdGFja3MrKztcbiAgICAgIHJldHVybiBqc3hERVZJbXBsKFxuICAgICAgICB0eXBlLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHNlbGYsXG4gICAgICAgIHRyYWNrQWN0dWFsT3duZXJcbiAgICAgICAgICA/IEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpXG4gICAgICAgICAgOiB1bmtub3duT3duZXJEZWJ1Z1N0YWNrLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyID8gY3JlYXRlVGFzayhnZXRUYXNrTmFtZSh0eXBlKSkgOiB1bmtub3duT3duZXJEZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHBsZS9Qcm9qZWN0cy9Qcm9kYW5jZS9GRS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"src/app/layout.tsx\",\"import\":\"Poppins\",\"arguments\":[{\"subsets\":[\"latin\"],\"display\":\"swap\",\"weight\":[\"300\",\"400\",\"500\",\"600\",\"700\"]}],\"variableName\":\"poppins\"}":
/*!**************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"src/app/layout.tsx","import":"Poppins","arguments":[{"subsets":["latin"],"display":"swap","weight":["300","400","500","600","700"]}],"variableName":"poppins"} ***!
  \**************************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'Poppins', 'Poppins Fallback'\",\"fontStyle\":\"normal\"},\"className\":\"__className_51684b\"};\n    if(true) {\n      // 1755917884778\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwic3JjL2FwcC9sYXlvdXQudHN4XCIsXCJpbXBvcnRcIjpcIlBvcHBpbnNcIixcImFyZ3VtZW50c1wiOlt7XCJzdWJzZXRzXCI6W1wibGF0aW5cIl0sXCJkaXNwbGF5XCI6XCJzd2FwXCIsXCJ3ZWlnaHRcIjpbXCIzMDBcIixcIjQwMFwiLFwiNTAwXCIsXCI2MDBcIixcIjcwMFwiXX1dLFwidmFyaWFibGVOYW1lXCI6XCJwb3BwaW5zXCJ9IiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCLFNBQVMsa0VBQWtFO0FBQzdGLE9BQU8sSUFBVTtBQUNqQjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHdNQUF1SCxjQUFjLHNEQUFzRDtBQUN6TixNQUFNLFVBQVU7QUFDaEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXBwbGUvUHJvamVjdHMvUHJvZGFuY2UvRkUvbm9kZV9tb2R1bGVzL25leHQvZm9udC9nb29nbGUvdGFyZ2V0LmNzcz97XCJwYXRoXCI6XCJzcmMvYXBwL2xheW91dC50c3hcIixcImltcG9ydFwiOlwiUG9wcGluc1wiLFwiYXJndW1lbnRzXCI6W3tcInN1YnNldHNcIjpbXCJsYXRpblwiXSxcImRpc3BsYXlcIjpcInN3YXBcIixcIndlaWdodFwiOltcIjMwMFwiLFwiNDAwXCIsXCI1MDBcIixcIjYwMFwiLFwiNzAwXCJdfV0sXCJ2YXJpYWJsZU5hbWVcIjpcInBvcHBpbnNcIn0iXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcInN0eWxlXCI6e1wiZm9udEZhbWlseVwiOlwiJ1BvcHBpbnMnLCAnUG9wcGlucyBGYWxsYmFjaydcIixcImZvbnRTdHlsZVwiOlwibm9ybWFsXCJ9LFwiY2xhc3NOYW1lXCI6XCJfX2NsYXNzTmFtZV81MTY4NGJcIn07XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTc1NTkxNzg4NDc3OFxuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCIvVXNlcnMvYXBwbGUvUHJvamVjdHMvUHJvZGFuY2UvRkUvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIvX25leHQvXCIsXCJlc01vZHVsZVwiOmZhbHNlLFwibG9jYWxzXCI6dHJ1ZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"src/app/layout.tsx\",\"import\":\"Poppins\",\"arguments\":[{\"subsets\":[\"latin\"],\"display\":\"swap\",\"weight\":[\"300\",\"400\",\"500\",\"600\",\"700\"]}],\"variableName\":\"poppins\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rc-slider/assets/index.css":
/*!*************************************************!*\
  !*** ./node_modules/rc-slider/assets/index.css ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"b76f7947a42a\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yYy1zbGlkZXIvYXNzZXRzL2luZGV4LmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHBsZS9Qcm9qZWN0cy9Qcm9kYW5jZS9GRS9ub2RlX21vZHVsZXMvcmMtc2xpZGVyL2Fzc2V0cy9pbmRleC5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJiNzZmNzk0N2E0MmFcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rc-slider/assets/index.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/theme-provider.tsx":
/*!************************************!*\
  !*** ./src/app/theme-provider.tsx ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ThemeContext: () => (/* binding */ ThemeContext),\n/* harmony export */   \"default\": () => (/* binding */ ThemeProvider)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _vis_gl_react_google_maps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vis.gl/react-google-maps */ \"(app-pages-browser)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* __next_internal_client_entry_do_not_use__ ThemeContext,default auto */ \nvar _s = $RefreshSig$();\n\n\nconst ThemeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_2__.createContext)(null);\nfunction ThemeProvider(param) {\n    let { children } = param;\n    _s();\n    const [isDarkMode, setIsDarkMode] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [themeDir, setThemeDir] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)('ltr');\n    // themeMode\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"ThemeProvider.useEffect\": ()=>{\n            if (localStorage.getItem('theme') === 'dark-mode') {\n                setIsDarkMode(true);\n                const root = document.querySelector('html');\n                if (root && !root.classList.contains('dark')) {\n                    root.classList.add('dark');\n                }\n            } else {\n                setIsDarkMode(false);\n                const root = document.querySelector('html');\n                if (root) {\n                    root.classList.remove('dark');\n                }\n            }\n        }\n    }[\"ThemeProvider.useEffect\"], []);\n    // themeDir\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"ThemeProvider.useEffect\": ()=>{\n            if (true) {\n                document.documentElement.getAttribute('dir') === 'rtl' ? setThemeDir('rtl') : setThemeDir('ltr');\n            }\n        }\n    }[\"ThemeProvider.useEffect\"], []);\n    // Update themeDir when it changes\n    // This ensures that the document's direction is set correctly\n    // when the themeDir state changes.\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"ThemeProvider.useEffect\": ()=>{\n            if (true) {\n                document.documentElement.setAttribute('dir', themeDir);\n            }\n        }\n    }[\"ThemeProvider.useEffect\"], [\n        themeDir\n    ]);\n    // toggleDarkMode\n    // This function toggles the dark mode state and updates the localStorage\n    // and the HTML class accordingly\n    const toggleDarkMode = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)({\n        \"ThemeProvider.useCallback[toggleDarkMode]\": ()=>{\n            if (localStorage.getItem('theme') === 'light-mode') {\n                setIsDarkMode(true);\n                const root = document.querySelector('html');\n                if (root && !root.classList.contains('dark')) {\n                    root.classList.add('dark');\n                }\n                localStorage.setItem('theme', 'dark-mode');\n            } else {\n                setIsDarkMode(false);\n                const root = document.querySelector('html');\n                if (root) {\n                    root.classList.remove('dark');\n                }\n                localStorage.setItem('theme', 'light-mode');\n            }\n        }\n    }[\"ThemeProvider.useCallback[toggleDarkMode]\"], []);\n    //\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_vis_gl_react_google_maps__WEBPACK_IMPORTED_MODULE_1__.APIProvider, {\n        apiKey: process.env.NEXT_PUBLIC_GOOGLE_MAP_API_KEY || '',\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ThemeContext.Provider, {\n            value: {\n                isDarkMode,\n                toggleDarkMode,\n                themeDir,\n                setThemeDir\n            },\n            children: children\n        }, void 0, false, {\n            fileName: \"/Users/apple/Projects/Prodance/FE/src/app/theme-provider.tsx\",\n            lineNumber: 76,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/apple/Projects/Prodance/FE/src/app/theme-provider.tsx\",\n        lineNumber: 75,\n        columnNumber: 5\n    }, this);\n}\n_s(ThemeProvider, \"U17LsIcrufYngb7/hVTqbLD49qs=\");\n_c = ThemeProvider;\nvar _c;\n$RefreshReg$(_c, \"ThemeProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvdGhlbWUtcHJvdmlkZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUV1RDtBQUNnQjtBQVNoRSxNQUFNSyw2QkFBZUosb0RBQWFBLENBQTJCLE1BQUs7QUFFMUQsU0FBU0ssY0FBYyxLQUEyQztRQUEzQyxFQUFFQyxRQUFRLEVBQWlDLEdBQTNDOztJQUNwQyxNQUFNLENBQUNDLFlBQVlDLGNBQWMsR0FBR0wsK0NBQVFBLENBQVU7SUFDdEQsTUFBTSxDQUFDTSxVQUFVQyxZQUFZLEdBQUdQLCtDQUFRQSxDQUFnQjtJQUV4RCxZQUFZO0lBQ1pELGdEQUFTQTttQ0FBQztZQUNSLElBQUlTLGFBQWFDLE9BQU8sQ0FBQyxhQUFhLGFBQWE7Z0JBQ2pESixjQUFjO2dCQUNkLE1BQU1LLE9BQU9DLFNBQVNDLGFBQWEsQ0FBQztnQkFDcEMsSUFBSUYsUUFBUSxDQUFDQSxLQUFLRyxTQUFTLENBQUNDLFFBQVEsQ0FBQyxTQUFTO29CQUM1Q0osS0FBS0csU0FBUyxDQUFDRSxHQUFHLENBQUM7Z0JBQ3JCO1lBQ0YsT0FBTztnQkFDTFYsY0FBYztnQkFDZCxNQUFNSyxPQUFPQyxTQUFTQyxhQUFhLENBQUM7Z0JBQ3BDLElBQUlGLE1BQU07b0JBQ1JBLEtBQUtHLFNBQVMsQ0FBQ0csTUFBTSxDQUFDO2dCQUN4QjtZQUNGO1FBQ0Y7a0NBQUcsRUFBRTtJQUVMLFdBQVc7SUFDWGpCLGdEQUFTQTttQ0FBQztZQUNSLElBQUksSUFBNkIsRUFBRTtnQkFDakNZLFNBQVNNLGVBQWUsQ0FBQ0MsWUFBWSxDQUFDLFdBQVcsUUFBUVgsWUFBWSxTQUFTQSxZQUFZO1lBQzVGO1FBQ0Y7a0NBQUcsRUFBRTtJQUVMLGtDQUFrQztJQUNsQyw4REFBOEQ7SUFDOUQsbUNBQW1DO0lBQ25DUixnREFBU0E7bUNBQUM7WUFDUixJQUFJLElBQTZCLEVBQUU7Z0JBQ2pDWSxTQUFTTSxlQUFlLENBQUNFLFlBQVksQ0FBQyxPQUFPYjtZQUMvQztRQUNGO2tDQUFHO1FBQUNBO0tBQVM7SUFFYixpQkFBaUI7SUFDakIseUVBQXlFO0lBQ3pFLGlDQUFpQztJQUNqQyxNQUFNYyxpQkFBaUJ0QixrREFBV0E7cURBQUM7WUFDakMsSUFBSVUsYUFBYUMsT0FBTyxDQUFDLGFBQWEsY0FBYztnQkFDbERKLGNBQWM7Z0JBQ2QsTUFBTUssT0FBT0MsU0FBU0MsYUFBYSxDQUFDO2dCQUNwQyxJQUFJRixRQUFRLENBQUNBLEtBQUtHLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDLFNBQVM7b0JBQzVDSixLQUFLRyxTQUFTLENBQUNFLEdBQUcsQ0FBQztnQkFDckI7Z0JBQ0FQLGFBQWFhLE9BQU8sQ0FBQyxTQUFTO1lBQ2hDLE9BQU87Z0JBQ0xoQixjQUFjO2dCQUNkLE1BQU1LLE9BQU9DLFNBQVNDLGFBQWEsQ0FBQztnQkFDcEMsSUFBSUYsTUFBTTtvQkFDUkEsS0FBS0csU0FBUyxDQUFDRyxNQUFNLENBQUM7Z0JBQ3hCO2dCQUNBUixhQUFhYSxPQUFPLENBQUMsU0FBUztZQUNoQztRQUNGO29EQUFHLEVBQUU7SUFFTCxFQUFFO0lBQ0YscUJBQ0UsOERBQUN6QixrRUFBV0E7UUFBQzBCLFFBQVFDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsOEJBQThCLElBQUk7a0JBQ2pFLDRFQUFDeEIsYUFBYXlCLFFBQVE7WUFDcEJDLE9BQU87Z0JBQ0x2QjtnQkFDQWdCO2dCQUNBZDtnQkFDQUM7WUFDRjtzQkFFQ0o7Ozs7Ozs7Ozs7O0FBSVQ7R0F6RXdCRDtLQUFBQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwcGxlL1Byb2plY3RzL1Byb2RhbmNlL0ZFL3NyYy9hcHAvdGhlbWUtcHJvdmlkZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyBBUElQcm92aWRlciB9IGZyb20gJ0B2aXMuZ2wvcmVhY3QtZ29vZ2xlLW1hcHMnXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuXG5pbnRlcmZhY2UgVGhlbWVDb250ZXh0VmFsdWUge1xuICBpc0RhcmtNb2RlOiBib29sZWFuXG4gIHRvZ2dsZURhcmtNb2RlOiAoKSA9PiB2b2lkXG4gIHRoZW1lRGlyOiAncnRsJyB8ICdsdHInXG4gIHNldFRoZW1lRGlyOiAodmFsdWU6ICdydGwnIHwgJ2x0cicpID0+IHZvaWRcbn1cblxuZXhwb3J0IGNvbnN0IFRoZW1lQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VGhlbWVDb250ZXh0VmFsdWUgfCBudWxsPihudWxsKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUaGVtZVByb3ZpZGVyKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0pIHtcbiAgY29uc3QgW2lzRGFya01vZGUsIHNldElzRGFya01vZGVdID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpXG4gIGNvbnN0IFt0aGVtZURpciwgc2V0VGhlbWVEaXJdID0gdXNlU3RhdGU8J3J0bCcgfCAnbHRyJz4oJ2x0cicpXG5cbiAgLy8gdGhlbWVNb2RlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0aGVtZScpID09PSAnZGFyay1tb2RlJykge1xuICAgICAgc2V0SXNEYXJrTW9kZSh0cnVlKVxuICAgICAgY29uc3Qgcm9vdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2h0bWwnKVxuICAgICAgaWYgKHJvb3QgJiYgIXJvb3QuY2xhc3NMaXN0LmNvbnRhaW5zKCdkYXJrJykpIHtcbiAgICAgICAgcm9vdC5jbGFzc0xpc3QuYWRkKCdkYXJrJylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SXNEYXJrTW9kZShmYWxzZSlcbiAgICAgIGNvbnN0IHJvb3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdodG1sJylcbiAgICAgIGlmIChyb290KSB7XG4gICAgICAgIHJvb3QuY2xhc3NMaXN0LnJlbW92ZSgnZGFyaycpXG4gICAgICB9XG4gICAgfVxuICB9LCBbXSlcblxuICAvLyB0aGVtZURpclxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlyJykgPT09ICdydGwnID8gc2V0VGhlbWVEaXIoJ3J0bCcpIDogc2V0VGhlbWVEaXIoJ2x0cicpXG4gICAgfVxuICB9LCBbXSlcblxuICAvLyBVcGRhdGUgdGhlbWVEaXIgd2hlbiBpdCBjaGFuZ2VzXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBkb2N1bWVudCdzIGRpcmVjdGlvbiBpcyBzZXQgY29ycmVjdGx5XG4gIC8vIHdoZW4gdGhlIHRoZW1lRGlyIHN0YXRlIGNoYW5nZXMuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2V0QXR0cmlidXRlKCdkaXInLCB0aGVtZURpcilcbiAgICB9XG4gIH0sIFt0aGVtZURpcl0pXG5cbiAgLy8gdG9nZ2xlRGFya01vZGVcbiAgLy8gVGhpcyBmdW5jdGlvbiB0b2dnbGVzIHRoZSBkYXJrIG1vZGUgc3RhdGUgYW5kIHVwZGF0ZXMgdGhlIGxvY2FsU3RvcmFnZVxuICAvLyBhbmQgdGhlIEhUTUwgY2xhc3MgYWNjb3JkaW5nbHlcbiAgY29uc3QgdG9nZ2xlRGFya01vZGUgPSB1c2VDYWxsYmFjaygoKTogdm9pZCA9PiB7XG4gICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0aGVtZScpID09PSAnbGlnaHQtbW9kZScpIHtcbiAgICAgIHNldElzRGFya01vZGUodHJ1ZSlcbiAgICAgIGNvbnN0IHJvb3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdodG1sJylcbiAgICAgIGlmIChyb290ICYmICFyb290LmNsYXNzTGlzdC5jb250YWlucygnZGFyaycpKSB7XG4gICAgICAgIHJvb3QuY2xhc3NMaXN0LmFkZCgnZGFyaycpXG4gICAgICB9XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndGhlbWUnLCAnZGFyay1tb2RlJylcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SXNEYXJrTW9kZShmYWxzZSlcbiAgICAgIGNvbnN0IHJvb3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdodG1sJylcbiAgICAgIGlmIChyb290KSB7XG4gICAgICAgIHJvb3QuY2xhc3NMaXN0LnJlbW92ZSgnZGFyaycpXG4gICAgICB9XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndGhlbWUnLCAnbGlnaHQtbW9kZScpXG4gICAgfVxuICB9LCBbXSlcblxuICAvL1xuICByZXR1cm4gKFxuICAgIDxBUElQcm92aWRlciBhcGlLZXk9e3Byb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0dPT0dMRV9NQVBfQVBJX0tFWSB8fCAnJ30+XG4gICAgICA8VGhlbWVDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgIHZhbHVlPXt7XG4gICAgICAgICAgaXNEYXJrTW9kZSxcbiAgICAgICAgICB0b2dnbGVEYXJrTW9kZSxcbiAgICAgICAgICB0aGVtZURpcixcbiAgICAgICAgICBzZXRUaGVtZURpcixcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9UaGVtZUNvbnRleHQuUHJvdmlkZXI+XG4gICAgPC9BUElQcm92aWRlcj5cbiAgKVxufVxuIl0sIm5hbWVzIjpbIkFQSVByb3ZpZGVyIiwiY3JlYXRlQ29udGV4dCIsInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJUaGVtZUNvbnRleHQiLCJUaGVtZVByb3ZpZGVyIiwiY2hpbGRyZW4iLCJpc0RhcmtNb2RlIiwic2V0SXNEYXJrTW9kZSIsInRoZW1lRGlyIiwic2V0VGhlbWVEaXIiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwicm9vdCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwiYWRkIiwicmVtb3ZlIiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwidG9nZ2xlRGFya01vZGUiLCJzZXRJdGVtIiwiYXBpS2V5IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0dPT0dMRV9NQVBfQVBJX0tFWSIsIlByb3ZpZGVyIiwidmFsdWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/theme-provider.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/SmoothScrollProvider.tsx":
/*!*************************************************!*\
  !*** ./src/components/SmoothScrollProvider.tsx ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SmoothScrollProvider)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ default auto */ var _s = $RefreshSig$();\n\nfunction SmoothScrollProvider() {\n    _s();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"SmoothScrollProvider.useEffect\": ()=>{\n            // Check if user prefers reduced motion\n            const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n            if (prefersReducedMotion) {\n                return; // Don't apply smooth scrolling if user prefers reduced motion\n            }\n            // Apply CSS smooth scrolling only - much more performant\n            document.documentElement.style.scrollBehavior = 'smooth';\n            document.body.style.scrollBehavior = 'smooth';\n            // Cleanup function\n            return ({\n                \"SmoothScrollProvider.useEffect\": ()=>{\n                    document.documentElement.style.scrollBehavior = 'auto';\n                    document.body.style.scrollBehavior = 'auto';\n                }\n            })[\"SmoothScrollProvider.useEffect\"];\n        }\n    }[\"SmoothScrollProvider.useEffect\"], []);\n    return null // This component doesn't render anything\n    ;\n}\n_s(SmoothScrollProvider, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = SmoothScrollProvider;\nvar _c;\n$RefreshReg$(_c, \"SmoothScrollProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1Ntb290aFNjcm9sbFByb3ZpZGVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBRWlDO0FBRWxCLFNBQVNDOztJQUN0QkQsZ0RBQVNBOzBDQUFDO1lBQ1IsdUNBQXVDO1lBQ3ZDLE1BQU1FLHVCQUF1QkMsT0FBT0MsVUFBVSxDQUFDLG9DQUFvQ0MsT0FBTztZQUUxRixJQUFJSCxzQkFBc0I7Z0JBQ3hCLFFBQU8sOERBQThEO1lBQ3ZFO1lBRUEseURBQXlEO1lBQ3pESSxTQUFTQyxlQUFlLENBQUNDLEtBQUssQ0FBQ0MsY0FBYyxHQUFHO1lBQ2hESCxTQUFTSSxJQUFJLENBQUNGLEtBQUssQ0FBQ0MsY0FBYyxHQUFHO1lBRXJDLG1CQUFtQjtZQUNuQjtrREFBTztvQkFDTEgsU0FBU0MsZUFBZSxDQUFDQyxLQUFLLENBQUNDLGNBQWMsR0FBRztvQkFDaERILFNBQVNJLElBQUksQ0FBQ0YsS0FBSyxDQUFDQyxjQUFjLEdBQUc7Z0JBQ3ZDOztRQUNGO3lDQUFHLEVBQUU7SUFFTCxPQUFPLEtBQUsseUNBQXlDOztBQUN2RDtHQXJCd0JSO0tBQUFBIiwic291cmNlcyI6WyIvVXNlcnMvYXBwbGUvUHJvamVjdHMvUHJvZGFuY2UvRkUvc3JjL2NvbXBvbmVudHMvU21vb3RoU2Nyb2xsUHJvdmlkZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU21vb3RoU2Nyb2xsUHJvdmlkZXIoKSB7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gQ2hlY2sgaWYgdXNlciBwcmVmZXJzIHJlZHVjZWQgbW90aW9uXG4gICAgY29uc3QgcHJlZmVyc1JlZHVjZWRNb3Rpb24gPSB3aW5kb3cubWF0Y2hNZWRpYSgnKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSknKS5tYXRjaGVzXG4gICAgXG4gICAgaWYgKHByZWZlcnNSZWR1Y2VkTW90aW9uKSB7XG4gICAgICByZXR1cm4gLy8gRG9uJ3QgYXBwbHkgc21vb3RoIHNjcm9sbGluZyBpZiB1c2VyIHByZWZlcnMgcmVkdWNlZCBtb3Rpb25cbiAgICB9XG5cbiAgICAvLyBBcHBseSBDU1Mgc21vb3RoIHNjcm9sbGluZyBvbmx5IC0gbXVjaCBtb3JlIHBlcmZvcm1hbnRcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSAnc21vb3RoJ1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSAnc21vb3RoJ1xuXG4gICAgLy8gQ2xlYW51cCBmdW5jdGlvblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSAnYXV0bydcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSAnYXV0bydcbiAgICB9XG4gIH0sIFtdKVxuXG4gIHJldHVybiBudWxsIC8vIFRoaXMgY29tcG9uZW50IGRvZXNuJ3QgcmVuZGVyIGFueXRoaW5nXG59Il0sIm5hbWVzIjpbInVzZUVmZmVjdCIsIlNtb290aFNjcm9sbFByb3ZpZGVyIiwicHJlZmVyc1JlZHVjZWRNb3Rpb24iLCJ3aW5kb3ciLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJzY3JvbGxCZWhhdmlvciIsImJvZHkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/SmoothScrollProvider.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/styles/tailwind.css":
/*!*********************************!*\
  !*** ./src/styles/tailwind.css ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"03895be1266e\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdHlsZXMvdGFpbHdpbmQuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksSUFBVSxJQUFJLGlCQUFpQiIsInNvdXJjZXMiOlsiL1VzZXJzL2FwcGxlL1Byb2plY3RzL1Byb2RhbmNlL0ZFL3NyYy9zdHlsZXMvdGFpbHdpbmQuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiMDM4OTViZTEyNjZlXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/styles/tailwind.css\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fapple%2FProjects%2FProdance%2FFE%2Fsrc%2Fapp%2Ftheme-provider.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fapple%2FProjects%2FProdance%2FFE%2Fsrc%2Fcomponents%2FSmoothScrollProvider.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fapple%2FProjects%2FProdance%2FFE%2Fsrc%2Fstyles%2Ftailwind.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fapple%2FProjects%2FProdance%2FFE%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Poppins%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22display%5C%22%3A%5C%22swap%5C%22%2C%5C%22weight%5C%22%3A%5B%5C%22300%5C%22%2C%5C%22400%5C%22%2C%5C%22500%5C%22%2C%5C%22600%5C%22%2C%5C%22700%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22poppins%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fapple%2FProjects%2FProdance%2FFE%2Fnode_modules%2Frc-slider%2Fassets%2Findex.css%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);